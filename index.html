<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1400, user-scalable=yes" id="viewport-meta">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:;">
    <title>Album Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .sync-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
        }

        .sync-status.compact {
            padding: 8px 12px;
            border-radius: 12px;
            min-width: 100px;
            width: auto;
            max-width: 120px;
        }

        .sync-status.compact .sync-details {
            max-width: 0;
            opacity: 0;
            transition: all 0.3s;
        }

        .sync-status.compact:hover {
            padding: 10px 20px;
        }

        .sync-status.compact:hover .sync-details {
            max-width: 200px;
            opacity: 1;
            margin-left: 10px;
        }

        .sync-status:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }

        .sync-details {
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
        }

        .sync-main-text {
            font-weight: 600;
        }

        .sync-sub-text {
            font-size: 0.75em;
            color: #666;
        }

        .sync-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .sync-indicator.connected {
            background: #28a745;
        }

        .sync-indicator.syncing {
            background: #ffc107;
        }

        .sync-indicator.offline {
            background: #6c757d;
        }

        .sync-indicator.error {
            background: #dc3545;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sync-menu {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 15px;
            min-width: 250px;
            z-index: 999;
            display: none;
        }

        .sync-menu.active {
            display: block;
            animation: fadeIn 0.2s;
        }

        .sync-menu-item {
            padding: 10px;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-menu-item:hover {
            background: #f8f9fa;
        }

        .sync-menu-divider {
            height: 1px;
            background: #e9ecef;
            margin: 10px 0;
        }

        .nav {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .nav button {
            padding: 12px 24px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .nav button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .nav button.active {
            background: #764ba2;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Vinyl Record Button */
        .vinyl-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 5px;
            transition: transform 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-weight: 600;
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 10;
        }

        .vinyl-button:hover {
            transform: translateY(-50%) scale(1.1);
        }

        .vinyl-record {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4), inset 0 2px 5px rgba(255,255,255,0.1);
            animation: spin 4s linear infinite;
        }

        .vinyl-button:hover .vinyl-record {
            animation: spin 2s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .vinyl-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 22px;
            height: 22px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            box-shadow: 0 0 0 2px #1a1a1a, 0 2px 5px rgba(0,0,0,0.3);
        }

        .vinyl-text {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .vinyl-text text {
            fill: white;
            font-size: 9px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* Mobile optimization for header */
        @media (max-width: 768px) {
            .header h1 {
                font-size: 1.5em;
                margin-left: 90px;
                margin-right: 10px;
            }

            .header p {
                font-size: 0.85em;
                margin-left: 90px;
                margin-right: 10px;
            }

            .vinyl-button {
                left: 10px;
            }

            .vinyl-record {
                width: 60px;
                height: 60px;
            }

            .vinyl-center {
                width: 18px;
                height: 18px;
            }

            .vinyl-text text {
                font-size: 8px;
                letter-spacing: 1.5px;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.3em;
                margin-left: 75px;
            }

            .header p {
                font-size: 0.75em;
                margin-left: 75px;
            }

            .vinyl-button {
                left: 5px;
            }

            .vinyl-record {
                width: 50px;
                height: 50px;
            }

            .vinyl-center {
                width: 16px;
                height: 16px;
            }

            .vinyl-text text {
                font-size: 7px;
                letter-spacing: 1px;
            }
        }

        .vinyl-groove {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 45px;
            height: 45px;
            border: 2px solid rgba(255,255,255,0.05);
            border-radius: 50%;
        }

        .vinyl-groove::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
        }

        /* Settings Button */
        .settings-button {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            transition: all 0.3s;
            z-index: 10;
        }

        .settings-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-50%) rotate(90deg);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .view-toggle-button {
            position: absolute;
            right: 75px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            z-index: 10;
            display: none; /* Hidden by default, shown on mobile */
        }

        .view-toggle-button:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .view-toggle-button {
                display: block; /* Show on mobile/tablet */
            }
        }

        @media (max-width: 768px) {
            .settings-button {
                right: 10px;
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            .settings-button {
                right: 5px;
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.3s;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .settings-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-header h2 {
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .settings-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .settings-body {
            padding: 30px;
        }

        .settings-section {
            margin-bottom: 35px;
            padding-bottom: 35px;
            border-bottom: 2px solid #f0f0f0;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-section h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-section p {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }

        .settings-input-group {
            margin-bottom: 15px;
        }

        .settings-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .settings-input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: monospace;
        }

        .settings-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .settings-button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .settings-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .settings-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .settings-btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e9ecef;
        }

        .settings-btn-secondary:hover {
            background: #e9ecef;
        }

        .settings-btn-link {
            background: transparent;
            color: #667eea;
            text-decoration: underline;
            padding: 10px 0;
        }

        .settings-btn-link:hover {
            color: #764ba2;
        }

        .settings-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .settings-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .settings-status.disconnected {
            background: #fff3cd;
            color: #856404;
        }

        .settings-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Instructions Modal */
        .instructions-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10001;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .instructions-modal.active {
            display: flex;
        }

        .instructions-content {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .instructions-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .instructions-header h2 {
            font-size: 1.5em;
        }

        .instructions-body {
            padding: 30px;
        }

        .instruction-step {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            align-items: flex-start;
        }

        .instruction-number {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .instruction-text {
            flex: 1;
            padding-top: 5px;
        }

        .instruction-text p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .instruction-link {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .instruction-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .instruction-note {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
        }

        .instruction-note strong {
            color: #667eea;
            display: block;
            margin-bottom: 5px;
        }

        /* Discogs Results Styles */
        .discogs-result-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            gap: 15px;
        }

        .discogs-result-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .discogs-result-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .discogs-result-image {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            background: #f0f0f0;
            flex-shrink: 0;
        }

        .discogs-result-info {
            flex: 1;
        }

        .discogs-result-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .discogs-result-details {
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .discogs-result-details strong {
            color: #333;
        }

        .discogs-result-button {
            align-self: center;
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .discogs-result-button:hover {
            background: #5568d3;
            transform: scale(1.05);
        }

        .vinyl-groove::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
        }

        .content {
            padding: 30px;
            min-height: 500px;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .random-album-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 30px;
            color: white;
            margin-bottom: 30px;
        }

        .random-album-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .album-artwork {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .album-details {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .album-details h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .album-details p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .wiki-link {
            display: inline-block;
            margin-left: 8px;
            color: #fff;
            opacity: 0.7;
            transition: opacity 0.2s;
            text-decoration: none;
            font-size: 0.85em;
            vertical-align: middle;
        }

        .wiki-link:hover {
            opacity: 1;
        }

        .wiki-link svg {
            width: 16px;
            height: 16px;
            vertical-align: middle;
        }

        .spotify-link {
            display: inline-block;
            margin-left: 8px;
            color: #1DB954;
            opacity: 0.9;
            transition: all 0.2s;
            text-decoration: none;
            font-size: 0.85em;
            vertical-align: middle;
        }

        .spotify-link:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .spotify-link svg {
            width: 18px;
            height: 18px;
            vertical-align: middle;
        }

        .rating-form {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .filters {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            margin-top: 4px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #e9ecef;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-artwork {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            background: #e9ecef;
        }

        .search-result-info {
            flex: 1;
        }

        .search-result-album {
            font-weight: 600;
            color: #212529;
            margin-bottom: 2px;
        }

        .search-result-artist {
            font-size: 14px;
            color: #6c757d;
        }

        .search-no-results {
            padding: 20px;
            text-align: center;
            color: #6c757d;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .album-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .album-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s;
            cursor: pointer;
        }

        .album-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .album-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .album-card-info {
            padding: 15px;
        }

        .album-card-info h3 {
            font-size: 1em;
            margin-bottom: 5px;
            color: #333;
        }

        .album-card-info p {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-top: 8px;
        }

        .score-high {
            background: #28a745;
            color: white;
        }

        .score-medium {
            background: #ffc107;
            color: #333;
        }

        .score-low {
            background: #dc3545;
            color: white;
        }

        .score-unrated {
            background: #e9ecef;
            color: #6c757d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .chart {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid #e9ecef;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .chart-label {
            width: 150px;
            font-size: 0.9em;
            color: #333;
        }

        .chart-bar-fill {
            height: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            min-width: 40px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 2em;
            cursor: pointer;
            color: #6c757d;
            line-height: 1;
        }

        .modal-close:hover {
            color: #333;
        }

        .file-upload {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload:hover {
            background: #f8f9fa;
            border-color: #764ba2;
        }

        .file-upload input {
            display: none;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Duplicate Cleanup Styles */
        .duplicate-group {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .duplicate-group.query {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .duplicate-item {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .duplicate-item.keep {
            border-color: #28a745;
            background: #d4edda;
        }

        .duplicate-item.delete {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .duplicate-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .duplicate-info {
            flex: 1;
        }

        .duplicate-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-keep {
            background: #28a745;
            color: white;
        }

        .badge-delete {
            background: #dc3545;
            color: white;
        }

        .badge-query {
            background: #ffc107;
            color: #333;
        }

        .badge-master {
            background: #764ba2;
            color: white;
        }

        @media (max-width: 768px) {
            .random-album-content {
                grid-template-columns: 1fr;
            }

            .album-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .nav {
                flex-direction: column;
            }

            .nav button {
                width: 100%;
            }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .tag {
            display: inline-block;
            padding: 4px 10px;
            background: #e9ecef;
            border-radius: 12px;
            font-size: 0.85em;
            margin: 2px;
            color: #495057;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .album-checkbox {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 10;
            accent-color: #9b59b6;
        }

        .album-card.multi-select-mode {
            cursor: pointer;
        }

        .album-card.selected {
            outline: 3px solid #9b59b6;
            outline-offset: -3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <!-- Random Album Button (Vinyl Record Style) -->
            <button onclick="pickRandomAlbum()" class="vinyl-button" title="Pick an Album">
                <div class="vinyl-record">
                    <svg class="vinyl-text" viewBox="0 0 100 100">
                        <defs>
                            <path id="circlePath" d="M 50, 50 m -35, 0 a 35,35 0 1,1 70,0 a 35,35 0 1,1 -70,0"/>
                        </defs>
                        <text>
                            <textPath href="#circlePath" startOffset="0%">
                                PICK AN ALBUM ‚Ä¢ PICK AN ALBUM ‚Ä¢ 
                            </textPath>
                        </text>
                    </svg>
                    <div class="vinyl-center"></div>
                    <div class="vinyl-groove"></div>
                </div>
            </button>
            
            <h1>üéµ Album Tracker</h1>
            <p>Track, Rate, and Discover Your Music Journey</p>
            
            <!-- View Toggle Button (Mobile Only) -->
            <button onclick="toggleViewMode()" class="view-toggle-button" id="viewToggleBtn" title="Toggle View Mode">
                üì± Mobile View
            </button>
            
            <!-- Settings Button -->
            <button onclick="openSettings()" class="settings-button" title="Settings">
                ‚öôÔ∏è
            </button>
        </div>

        <div class="nav">
            <button onclick="showSection('browse', event)" class="active">Browse Albums</button>
            <button onclick="showSection('import', event)">Import/Export Data</button>
            <button onclick="showSection('stats', event)">Statistics</button>
        </div>

        <div class="content">
            <!-- Random Album Section -->
            <div id="random" class="section">
                <div class="random-album-card">
                    <h2 style="text-align: center;">Discover Your Next Album</h2>
                    <div style="text-align: center; margin: 20px 0; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="selectRandomAlbum()" style="font-size: 1.2em; padding: 15px 40px;">
                            üé≤ Pick Again
                        </button>
                        <button class="btn btn-primary" onclick="generateRandomList()" style="font-size: 1.2em; padding: 15px 40px;">
                            üìã Generate List of 10
                        </button>
                    </div>
                    <div id="randomAlbumDisplay"></div>
                    <div id="randomListDisplay" style="display: none;"></div>
                </div>
            </div>

            <!-- Browse Albums Section -->
            <div id="browse" class="section active">
                <h2>Browse Albums</h2>
                
                <!-- Multi-select Controls -->
                <div id="multiSelectControls" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; display: none;">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="toggleSelectAll()">
                            <span id="selectAllText">Select All</span>
                        </button>
                        <button class="btn btn-danger" onclick="deleteSelectedAlbums()" id="deleteSelectedBtn" disabled>
                            üóëÔ∏è Delete Selected (<span id="selectedCount">0</span>)
                        </button>
                        <button class="btn btn-secondary" onclick="toggleMultiSelectMode()">
                            Cancel
                        </button>
                        <span style="color: #666; margin-left: auto;">Multi-select mode active</span>
                    </div>
                </div>
                
                <!-- Search Box -->
                <div class="search-container">
                    <input 
                        type="text" 
                        id="searchInput" 
                        class="search-input" 
                        placeholder="Search by album name or artist..."
                        autocomplete="off"
                    >
                    <span class="search-icon">üîç</span>
                    <div id="searchResults" class="search-results"></div>
                </div>
                
                <div class="filters">
                    <h3 style="margin-bottom: 15px;">Filters</h3>
                    <div class="filters-grid">
                        <div class="form-group">
                            <label>Genre</label>
                            <select id="filterGenre" onchange="applyFilters()">
                                <option value="">All Genres</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Source List</label>
                            <select id="filterSource" onchange="applyFilters()">
                                <option value="">All Sources</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="filterStatus" onchange="applyFilters()">
                                <option value="">All</option>
                                <option value="listened">Listened</option>
                                <option value="unlistened">Unlistened</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Sort By</label>
                            <select id="sortBy" onchange="applyFilters()">
                                <option value="name-asc">Album Name (A-Z)</option>
                                <option value="name-desc">Album Name (Z-A)</option>
                                <option value="artist-asc">Artist (A-Z)</option>
                                <option value="artist-desc">Artist (Z-A)</option>
                                <option value="score-desc">Score (High-Low)</option>
                                <option value="score-asc">Score (Low-High)</option>
                                <option value="date-desc">Date Listened (Newest)</option>
                                <option value="date-asc">Date Listened (Oldest)</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>
                        <button class="btn" onclick="toggleMultiSelectMode()">
                            <span id="multiSelectModeBtn">üìã Multi-Select</span>
                        </button>
                        <button class="btn btn-success" onclick="showAddAlbumForm()" style="margin-left: auto;">
                            ‚ûï Add Album
                        </button>
                    </div>
                </div>

                <!-- Add Album Form (Initially Hidden) -->
                <div id="addAlbumFormContainer" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 12px; border: 2px solid #667eea;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Add New Album</h3>
                        <button class="btn btn-secondary" onclick="hideAddAlbumForm()">‚úï Cancel</button>
                    </div>
                    
                    <!-- Quick Search Section -->
                    <div id="discogsQuickSearch" style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
                        <h4 style="margin: 0 0 10px 0; color: #667eea;">üîç Quick Search</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end;">
                            <div class="form-group" style="margin: 0;">
                                <label>Artist Name</label>
                                <input type="text" id="quickSearchArtist" placeholder="e.g., Pink Floyd">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label>Album Name</label>
                                <input type="text" id="quickSearchAlbum" placeholder="e.g., Dark Side of the Moon">
                            </div>
                            <button type="button" class="btn" onclick="searchDiscogs()" style="background: #667eea; margin: 0;">
                                üîç Find on Discogs
                            </button>
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                            <div class="form-group" style="margin: 0;">
                                <label>Or paste Discogs URL</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="url" id="discogsUrl" placeholder="https://www.discogs.com/release/..." style="flex: 1;">
                                    <button type="button" class="btn" onclick="fetchFromDiscogsUrl()" style="background: #667eea;">
                                        üì• Import from URL
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="btn btn-secondary" onclick="clearQuickSearch()" style="font-size: 0.9em;">
                                Clear
                            </button>
                            <button type="button" class="btn btn-secondary" onclick="openDiscogsManually()" style="font-size: 0.9em;">
                                üåê Search on Discogs
                            </button>
                        </div>
                        <div id="discogsSearchStatus" style="margin-top: 10px; padding: 8px; border-radius: 4px; display: none;"></div>
                    </div>
                    
                    <form id="addAlbumFormInline" onsubmit="addAlbumInline(event)">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div class="form-group">
                                <label>Album Name *</label>
                                <input type="text" id="albumNameInline" required>
                            </div>
                            <div class="form-group">
                                <label>Artist *</label>
                                <input type="text" id="artistInline" required>
                            </div>
                            <div class="form-group">
                                <label>Year *</label>
                                <input type="number" id="yearInline" min="1900" max="2100" required>
                            </div>
                            <div class="form-group">
                                <label>Album Artwork URL *</label>
                                <input type="url" id="artworkUrlInline" required placeholder="https://...">
                            </div>
                            <div class="form-group">
                                <label>Genre</label>
                                <input type="text" id="genreInline" placeholder="Rock; Alternative">
                            </div>
                            <div class="form-group">
                                <label>Style</label>
                                <input type="text" id="styleInline" placeholder="Indie Rock; Post-Punk">
                            </div>
                            <div class="form-group">
                                <label>Source / Reason</label>
                                <input type="text" id="reasonInline" placeholder="Manual or source lists">
                            </div>
                            <div class="form-group">
                                <label>Discogs URL</label>
                                <input type="url" id="discogsUrlInline" placeholder="https://www.discogs.com/...">
                            </div>
                            <div class="form-group">
                                <label>Score (0-10)</label>
                                <input type="number" id="scoreInline" min="0" max="10" step="0.1">
                            </div>
                        </div>
                        <button type="submit" class="btn" style="margin-top: 15px;">Add Album</button>
                    </form>
                </div>

                <div id="albumGrid" class="album-grid"></div>
            </div>

            <!-- Add Album Section (Hidden - replaced by inline form) -->
            <div id="add" class="section">
                <h2>Add New Album</h2>
                <form id="addAlbumForm" onsubmit="addAlbum(event)">
                    <div class="form-group">
                        <label>Album Name *</label>
                        <input type="text" id="albumName" required>
                    </div>
                    <div class="form-group">
                        <label>Artist *</label>
                        <input type="text" id="artist" required>
                    </div>
                    <div class="form-group">
                        <label>Artist ID</label>
                        <input type="text" id="artistId">
                    </div>
                    <div class="form-group">
                        <label>Year *</label>
                        <input type="number" id="year" min="1900" max="2100" required>
                    </div>
                    <div class="form-group">
                        <label>Album Artwork URL *</label>
                        <input type="url" id="artworkUrl" required placeholder="https://...">
                    </div>
                    <div class="form-group">
                        <label>Discogs URL</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="url" id="discogsUrl" placeholder="https://www.discogs.com/..." style="flex: 1;">
                            <button type="button" class="btn" onclick="fetchFromDiscogs()" style="white-space: nowrap;">Fetch from Discogs</button>
                        </div>
                        <small id="discogsStatus" style="color: #888; margin-top: 5px; display: block;"></small>
                    </div>
                    <div class="form-group">
                        <label>Genre (semicolon-separated for multiple)</label>
                        <input type="text" id="genre" placeholder="Rock; Alternative">
                    </div>
                    <div class="form-group">
                        <label>Style (semicolon-separated for multiple)</label>
                        <input type="text" id="style" placeholder="Indie Rock; Post-Punk">
                    </div>
                    <div class="form-group">
                        <label>Reason</label>
                        <input type="text" id="reason" value="Manual" placeholder="Manual or source lists separated by semicolons">
                    </div>
                    <div class="form-group">
                        <label>Score (0-10, leave empty if not rated)</label>
                        <input type="number" id="score" min="0" max="10" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Date Listened</label>
                        <input type="date" id="dateListened">
                    </div>
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="notes" placeholder="Your thoughts about this album..."></textarea>
                    </div>
                    <button type="submit" class="btn">Add Album</button>
                </form>
            </div>

            <!-- Import/Export Data Section -->
            <div id="import" class="section">
                <h2>Import/Export Album Data</h2>
                
                <!-- Export Section -->
                <div style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <h3 style="margin-bottom: 15px;">üì§ Export Data</h3>
                    <p style="color: #666; margin-bottom: 15px;">Download your album collection as an Excel file</p>
                    <button class="btn btn-success" onclick="exportData()" style="font-size: 1.1em; padding: 12px 30px;">
                        üì• Export to Excel
                    </button>
                </div>

                <!-- Import Section -->
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px;">üì• Import Data</h3>
                    <div class="alert alert-info">
                        <strong>Supported Format:</strong> Excel files (.xlsx, .xls) with columns: ID, Album Name, Artist, Year, Reason, Album Artwork URL, Discogs URL, Artist ID, Genre, Style, Score, Date Listened, Notes
                    </div>
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="importExcel(event)">
                        <p style="font-size: 3em; margin-bottom: 10px;">üìÅ</p>
                        <p style="font-size: 1.2em; color: #667eea; font-weight: 600;">Click to upload Excel file</p>
                        <p style="color: #6c757d; margin-top: 10px;">Existing albums will be updated with new data</p>
                    </div>
                    <div id="importStatus"></div>
                </div>

                <!-- Template Download -->
                <div style="padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <h3 style="margin-bottom: 15px;">üìã Import Template</h3>
                    <p style="color: #666; margin-bottom: 15px;">Download a template with the correct column headers to get started</p>
                    <button class="btn btn-secondary" onclick="downloadImportTemplate()" style="font-size: 1.1em; padding: 12px 30px;">
                        üìÑ Download Import Template
                    </button>
                </div>
            </div>

            <!-- Statistics Section -->
            <div id="stats" class="section">
                <h2>Statistics & Analytics</h2>
                <div id="statsContent"></div>
            </div>
        </div>
    </div>

    <!-- Album Detail Modal -->
    <div id="albumModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div id="albumModalContent"></div>
        </div>
    </div>

    <!-- OneDrive Sync Status -->
    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button onclick="closeSettings()" class="settings-close">‚úï</button>
            </div>
            <div class="settings-body">
                <!-- Discogs Integration Section -->
                <div class="settings-section">
                    <h3>üéµ Discogs Integration</h3>
                    <p>Enable auto-fill album details from Discogs when adding new albums.</p>
                    
                    <div class="settings-input-group">
                        <label for="discogsToken">API Token:</label>
                        <input 
                            type="text" 
                            id="discogsToken" 
                            placeholder="Paste your Discogs API token here"
                            autocomplete="off"
                        >
                    </div>
                    
                    <div class="settings-button-group">
                        <button onclick="saveDiscogsToken()" class="settings-btn settings-btn-primary">
                            üíæ Save Token
                        </button>
                        <button onclick="clearDiscogsToken()" class="settings-btn settings-btn-secondary">
                            üóëÔ∏è Clear Token
                        </button>
                    </div>
                    
                    <div id="discogsStatus"></div>
                    
                    <button onclick="showDiscogsInstructions()" class="settings-btn settings-btn-link">
                        üìñ How to get your Discogs API token
                    </button>
                </div>
                
                <!-- OneDrive Sync Section -->
                <div class="settings-section">
                    <h3>‚òÅÔ∏è OneDrive Sync</h3>
                    <p>Sync your album collection across devices using Microsoft OneDrive.</p>
                    
                    <div id="oneDriveSettingsStatus"></div>
                    
                    <div class="settings-button-group" id="oneDriveSettingsButtons">
                        <!-- Buttons will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Data Management Section -->
                <div class="settings-section">
                    <h3>üìä Data Management</h3>
                    <p>Manage your local album data and backups.</p>
                    
                    <div class="settings-button-group">
                        <button onclick="exportBackup()" class="settings-btn settings-btn-secondary">
                            üì• Export Backup
                        </button>
                        <button onclick="confirmClearData()" class="settings-btn settings-btn-secondary">
                            üóëÔ∏è Clear All Data
                        </button>
                    </div>
                    
                    <div class="settings-button-group" style="margin-top: 15px;">
                        <button onclick="openDuplicateCleanup()" class="settings-btn settings-btn-secondary">
                            üîç Clean Up Duplicate Albums
                        </button>
                        <button onclick="cleanupIDs()" class="settings-btn settings-btn-secondary">
                            üî¢ Clean Up IDs
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Instructions Modal -->
    <div class="instructions-modal" id="instructionsModal">
        <div class="instructions-content">
            <div class="instructions-header">
                <h2>How to Get Your Discogs API Token</h2>
                <button onclick="closeInstructions()" class="settings-close">‚úï</button>
            </div>
            <div class="instructions-body">
                <div class="instruction-step">
                    <div class="instruction-number">1</div>
                    <div class="instruction-text">
                        <p><strong>Go to Discogs Settings</strong></p>
                        <p>Click the button below to open Discogs Developer Settings in a new tab.</p>
                        <a href="https://www.discogs.com/settings/developers" target="_blank" class="instruction-link">
                            Open Discogs Settings ‚Üí
                        </a>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-number">2</div>
                    <div class="instruction-text">
                        <p><strong>Generate a New Token</strong></p>
                        <p>On the Developers page, click "Generate new token" button.</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-number">3</div>
                    <div class="instruction-text">
                        <p><strong>Copy the Token</strong></p>
                        <p>Discogs will display your new token. Copy it to your clipboard.</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-number">4</div>
                    <div class="instruction-text">
                        <p><strong>Paste in Settings</strong></p>
                        <p>Return to this app, paste the token in the Settings, and click "Save Token".</p>
                    </div>
                </div>
                
                <div class="instruction-note">
                    <strong>üîí Privacy & Security</strong>
                    <p>Your API token is stored locally on your device only. It's never sent to anyone except Discogs when you use the "Find on Discogs" feature.</p>
                    <p>‚ö†Ô∏è Keep your token private! Don't share it with others. You can revoke and regenerate it anytime on Discogs.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Discogs Results Modal -->
    <div class="modal" id="discogsResultsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>Select the Correct Album</h2>
                <button onclick="closeDiscogsResults()" class="modal-close">‚úï</button>
            </div>
            <div class="modal-body">
                <p style="color: #666; margin-bottom: 20px;">Found multiple versions. Select the one that matches your album:</p>
                <div id="discogsResultsList" style="max-height: 500px; overflow-y: auto;"></div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="openDiscogsManually()">üåê Search on Discogs</button>
                <button class="btn btn-secondary" onclick="closeDiscogsResults()">Manual Entry</button>
            </div>
        </div>
    </div>

    <!-- Duplicate Cleanup Modal -->
    <div class="modal" id="duplicateCleanupModal">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h2>üîç Clean Up Duplicate Albums</h2>
                <button onclick="closeDuplicateCleanup()" class="modal-close">‚úï</button>
            </div>
            <div class="modal-body">
                <div id="duplicateCleanupContent">
                    <p style="color: #666; margin-bottom: 20px;">Scanning for duplicate albums...</p>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: space-between;">
                <button class="btn btn-secondary" onclick="closeDuplicateCleanup()">Cancel</button>
                <button class="btn btn-danger" id="deleteDuplicatesBtn" onclick="deleteDuplicates()" style="display: none;">
                    üóëÔ∏è Delete Selected Duplicates
                </button>
            </div>
        </div>
    </div>

    <div class="sync-status" id="syncStatus" onclick="toggleSyncMenu()">
        <div class="sync-indicator offline" id="syncIndicator"></div>
        <div id="syncText">
            <span class="sync-main-text">Offline Mode</span>
        </div>
    </div>

    <!-- Sync Menu -->
    <div class="sync-menu" id="syncMenu">
        <div id="syncMenuContent"></div>
    </div>

    <!-- Include SheetJS library for Excel parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // Database Management
        class AlbumDatabase {
            constructor() {
                this.albums = this.loadFromStorage();
            }

            loadFromStorage() {
                const data = localStorage.getItem('albumTrackerData');
                return data ? JSON.parse(data) : [];
            }

            saveToStorage() {
                localStorage.setItem('albumTrackerData', JSON.stringify(this.albums));
            }

            addAlbum(album) {
                // If album has an ID, check if it already exists
                if (album.id) {
                    const existingIndex = this.albums.findIndex(a => a.id === album.id);
                    if (existingIndex !== -1) {
                        // Overwrite existing album with same ID
                        this.albums[existingIndex] = album;
                        this.saveToStorage();
                        return album;
                    }
                }
                
                // Generate new ID if not provided or doesn't exist
                const id = this.albums.length > 0 ? Math.max(...this.albums.map(a => a.id)) + 1 : 1;
                album.id = id;
                this.albums.push(album);
                this.saveToStorage();
                return album;
            }

            updateAlbum(id, updates) {
                const index = this.albums.findIndex(a => a.id === id);
                if (index !== -1) {
                    this.albums[index] = { ...this.albums[index], ...updates };
                    this.saveToStorage();
                    return this.albums[index];
                }
                return null;
            }

            deleteAlbum(id) {
                this.albums = this.albums.filter(a => a.id !== id);
                this.saveToStorage();
            }

            getAlbum(id) {
                return this.albums.find(a => a.id === id);
            }

            getAllAlbums() {
                return this.albums;
            }

            isDuplicate(albumName, artist) {
                return this.albums.some(a => 
                    String(a.albumName).toLowerCase() === String(albumName).toLowerCase() && 
                    String(a.artist).toLowerCase() === String(artist).toLowerCase()
                );
            }

            importAlbums(newAlbums) {
                let added = 0;
                let updated = 0;
                let skipped = 0;

                // Create a lookup map for faster duplicate checking
                const albumMap = new Map();
                this.albums.forEach(album => {
                    const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                    albumMap.set(key, album);
                });

                // Process in batches to avoid memory issues
                const BATCH_SIZE = 100;
                for (let i = 0; i < newAlbums.length; i += BATCH_SIZE) {
                    const batch = newAlbums.slice(i, i + BATCH_SIZE);
                    
                    batch.forEach(album => {
                        // Skip albums with truly empty names (but allow "0" or other falsy values that are valid)
                        if (album.albumName === '' || album.albumName === null || album.albumName === undefined) {
                            skipped++;
                            return;
                        }

                        // Check if album already exists using the map
                        const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                        const existingAlbum = albumMap.get(key);

                        if (existingAlbum) {
                            // Update existing album with new data (only if new data is provided)
                            const updates = {};
                            if (album.score !== null && album.score !== undefined && album.score !== '') updates.score = album.score;
                            if (album.dateListened) updates.dateListened = album.dateListened;
                            if (album.notes) updates.notes = album.notes;
                            if (album.artworkUrl) updates.artworkUrl = album.artworkUrl;
                            if (album.discogsUrl) updates.discogsUrl = album.discogsUrl;
                            if (album.genre) updates.genre = album.genre;
                            if (album.style) updates.style = album.style;
                            if (album.year) updates.year = album.year;
                            if (album.artistId) updates.artistId = album.artistId;
                            
                            // Merge reasons (source lists) if new ones are provided
                            if (album.reason && album.reason !== 'Manual') {
                                const existingReasons = this.parseMultiValue(existingAlbum.reason);
                                const newReasons = this.parseMultiValue(album.reason);
                                const mergedReasons = [...new Set([...existingReasons, ...newReasons])];
                                updates.reason = mergedReasons.join('; ');
                            }

                            if (Object.keys(updates).length > 0) {
                                this.updateAlbum(existingAlbum.id, updates);
                                updated++;
                            } else {
                                skipped++;
                            }
                        } else {
                            const newAlbum = this.addAlbum(album);
                            // Add to map for subsequent batches
                            albumMap.set(key, newAlbum);
                            added++;
                        }
                    });
                    
                    // Save after each batch to prevent memory buildup
                    this.saveToStorage();
                }

                return { added, updated, skipped };
            }

            // Async version of importAlbums with progress callback
            async importAlbumsAsync(newAlbums, progressCallback) {
                let added = 0;
                let updated = 0;
                let skipped = 0;

                // Create a map of existing albums for faster lookup
                const albumMap = new Map();
                this.albums.forEach(album => {
                    const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                    albumMap.set(key, album);
                });

                // Process in smaller batches with async breaks to prevent timeout
                const BATCH_SIZE = 50; // Smaller batches for better UI responsiveness
                const PROGRESS_UPDATE_INTERVAL = 100; // Update progress every 100 albums
                
                for (let i = 0; i < newAlbums.length; i += BATCH_SIZE) {
                    const batch = newAlbums.slice(i, i + BATCH_SIZE);
                    
                    batch.forEach(album => {
                        // Skip albums with truly empty names
                        if (album.albumName === '' || album.albumName === null || album.albumName === undefined) {
                            skipped++;
                            return;
                        }

                        // Check if album already exists using the map
                        const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                        const existingAlbum = albumMap.get(key);

                        if (existingAlbum) {
                            // Update existing album with new data - only if values are different
                            const updates = {};
                            
                            // Update score if new value exists and is different
                            if (album.score !== null && album.score !== undefined && album.score !== '' && album.score !== existingAlbum.score) {
                                updates.score = album.score;
                            }
                            
                            // Update dateListened if new value exists and is different
                            if (album.dateListened && album.dateListened !== existingAlbum.dateListened) {
                                updates.dateListened = album.dateListened;
                            }
                            
                            // Update notes if new value exists and is different
                            if (album.notes && album.notes !== existingAlbum.notes) {
                                updates.notes = album.notes;
                            }
                            
                            // Update artworkUrl if new value exists and is different
                            if (album.artworkUrl && album.artworkUrl !== existingAlbum.artworkUrl) {
                                updates.artworkUrl = album.artworkUrl;
                            }
                            
                            // Update discogsUrl if new value exists and is different
                            if (album.discogsUrl && album.discogsUrl !== existingAlbum.discogsUrl) {
                                updates.discogsUrl = album.discogsUrl;
                            }
                            
                            // Update genre if new value exists and is different
                            if (album.genre && album.genre !== existingAlbum.genre) {
                                updates.genre = album.genre;
                            }
                            
                            // Update style if new value exists and is different
                            if (album.style && album.style !== existingAlbum.style) {
                                updates.style = album.style;
                            }
                            
                            // Update year if new value exists and is different
                            if (album.year && album.year !== existingAlbum.year) {
                                updates.year = album.year;
                            }
                            
                            // Update artistId if new value exists and is different
                            if (album.artistId && album.artistId !== existingAlbum.artistId) {
                                updates.artistId = album.artistId;
                            }
                            
                            // Merge reasons (source lists)
                            if (album.reason && album.reason !== 'Manual') {
                                const existingReasons = this.parseMultiValue(existingAlbum.reason);
                                const newReasons = this.parseMultiValue(album.reason);
                                const mergedReasons = [...new Set([...existingReasons, ...newReasons])];
                                const mergedReason = mergedReasons.join('; ');
                                if (mergedReason !== existingAlbum.reason) {
                                    updates.reason = mergedReason;
                                }
                            }

                            if (Object.keys(updates).length > 0) {
                                this.updateAlbum(existingAlbum.id, updates);
                                updated++;
                            } else {
                                skipped++;
                            }
                        } else {
                            const newAlbum = this.addAlbum(album);
                            albumMap.set(key, newAlbum);
                            added++;
                        }
                    });
                    
                    // Save after each batch
                    this.saveToStorage();
                    
                    // Update progress callback
                    if (progressCallback && (i % PROGRESS_UPDATE_INTERVAL === 0 || i + BATCH_SIZE >= newAlbums.length)) {
                        progressCallback({
                            processed: Math.min(i + BATCH_SIZE, newAlbums.length),
                            total: newAlbums.length,
                            added,
                            updated,
                            skipped
                        });
                    }
                    
                    // Yield to browser to prevent freezing (every batch)
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                return { added, updated, skipped };
            }

            // Parse semicolon-separated fields
            parseMultiValue(value, isGenre = false) {
                if (!value) return [];
                
                // For genres, handle both semicolons and commas, but preserve "Folk, World, & Country"
                if (isGenre) {
                    // First, protect "Folk, World, & Country" by temporarily replacing it
                    const protectedValue = value.replace(/Folk,\s*World,\s*&\s*Country/gi, '___FOLK_WORLD_COUNTRY___');
                    
                    // Split by both semicolons and commas
                    const parts = protectedValue.split(/[;,]/).map(v => v.trim()).filter(v => v);
                    
                    // Restore the protected genre
                    return parts.map(part => part.replace(/___FOLK_WORLD_COUNTRY___/g, 'Folk, World, & Country'));
                }
                
                // For non-genres (sources, styles), use semicolon only
                return value.split(';').map(v => v.trim()).filter(v => v);
            }

            // Parse artist names - handles multiple artists intelligently
            // Artists can contain commas (e.g., "Earth, Wind & Fire")
            // So we only split on " & ", " and ", or semicolons
            parseArtists(value) {
                if (!value) return [value]; // Return original if empty
                
                // Split by semicolons first (explicit separator)
                const parts = value.split(';').map(v => v.trim()).filter(v => v);
                
                // Then split each part by " & " or " and " (but not commas)
                const artists = [];
                parts.forEach(part => {
                    // Split by " & " or " and " (case insensitive)
                    const subParts = part.split(/\s+(?:&|and)\s+/i).map(v => v.trim()).filter(v => v);
                    artists.push(...subParts);
                });
                
                return artists.length > 0 ? artists : [value];
            }

            // Get all unique genres
            getAllGenres() {
                const genres = new Set();
                this.albums.forEach(album => {
                    this.parseMultiValue(album.genre, true).forEach(g => genres.add(g));
                });
                return Array.from(genres).sort();
            }

            // Get all unique source lists
            getAllSources() {
                const sources = new Set();
                this.albums.forEach(album => {
                    if (album.reason && album.reason !== 'Manual') {
                        this.parseMultiValue(album.reason).forEach(s => sources.add(s));
                    }
                });
                return Array.from(sources).sort();
            }

            // Get all unique styles
            getAllStyles() {
                const styles = new Set();
                this.albums.forEach(album => {
                    this.parseMultiValue(album.style).forEach(s => styles.add(s));
                });
                return Array.from(styles).sort();
            }

            // Filter albums
            filterAlbums(filters) {
                return this.albums.filter(album => {
                    // Genre filter
                    if (filters.genre) {
                        const genres = this.parseMultiValue(album.genre, true);
                        if (!genres.includes(filters.genre)) return false;
                    }

                    // Source filter
                    if (filters.source) {
                        const sources = this.parseMultiValue(album.reason);
                        if (!sources.includes(filters.source)) return false;
                    }

                    // Status filter
                    if (filters.status === 'listened' && !album.dateListened) return false;
                    if (filters.status === 'unlistened' && album.dateListened) return false;

                    // Score range filter
                    if (filters.minScore !== undefined && (album.score === null || album.score < filters.minScore)) return false;
                    if (filters.maxScore !== undefined && (album.score === null || album.score > filters.maxScore)) return false;

                    return true;
                });
            }

            // Sort albums
            sortAlbums(albums, sortBy) {
                const sorted = [...albums];
                switch (sortBy) {
                    case 'name-asc':
                        return sorted.sort((a, b) => String(a.albumName).localeCompare(String(b.albumName)));
                    case 'name-desc':
                        return sorted.sort((a, b) => String(b.albumName).localeCompare(String(a.albumName)));
                    case 'artist-asc':
                        return sorted.sort((a, b) => String(a.artist).localeCompare(String(b.artist)));
                    case 'artist-desc':
                        return sorted.sort((a, b) => String(b.artist).localeCompare(String(a.artist)));
                    case 'score-desc':
                        return sorted.sort((a, b) => (b.score || 0) - (a.score || 0));
                    case 'score-asc':
                        return sorted.sort((a, b) => (a.score || 0) - (b.score || 0));
                    case 'date-desc':
                        return sorted.sort((a, b) => {
                            if (!a.dateListened) return 1;
                            if (!b.dateListened) return -1;
                            return new Date(b.dateListened) - new Date(a.dateListened);
                        });
                    case 'date-asc':
                        return sorted.sort((a, b) => {
                            if (!a.dateListened) return 1;
                            if (!b.dateListened) return -1;
                            return new Date(a.dateListened) - new Date(b.dateListened);
                        });
                    default:
                        return sorted;
                }
            }

            // Get random unscored album
            getRandomUnscoredAlbum() {
                const unscored = this.albums.filter(a => a.score === null || a.score === undefined || a.score === '');
                if (unscored.length === 0) return null;
                return unscored[Math.floor(Math.random() * unscored.length)];
            }

            // Statistics methods
            getMonthlyStats() {
                const stats = {};
                this.albums.forEach(album => {
                    if (album.dateListened) {
                        const date = new Date(album.dateListened);
                        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        if (!stats[key]) {
                            stats[key] = { count: 0, scores: [] };
                        }
                        stats[key].count++;
                        if (album.score !== null && album.score !== undefined && album.score !== '') {
                            stats[key].scores.push(parseFloat(album.score));
                        }
                    }
                });
                return stats;
            }

            getYearlyStats() {
                const stats = {};
                this.albums.forEach(album => {
                    if (album.dateListened) {
                        const date = new Date(album.dateListened);
                        const key = String(date.getFullYear());
                        if (!stats[key]) {
                            stats[key] = { count: 0, scores: [] };
                        }
                        stats[key].count++;
                        if (album.score !== null && album.score !== undefined && album.score !== '') {
                            stats[key].scores.push(parseFloat(album.score));
                        }
                    }
                });
                return stats;
            }

            getAverageScoreByArtist() {
                const artistScores = {};
                this.albums.forEach(album => {
                    if (album.score !== null && album.score !== undefined && album.score !== '') {
                        if (!artistScores[album.artist]) {
                            artistScores[album.artist] = [];
                        }
                        artistScores[album.artist].push(parseFloat(album.score));
                    }
                });

                const averages = {};
                Object.keys(artistScores).forEach(artist => {
                    const scores = artistScores[artist];
                    averages[artist] = {
                        average: scores.reduce((a, b) => a + b, 0) / scores.length,
                        count: scores.length
                    };
                });

                return Object.entries(averages)
                    .sort((a, b) => b[1].average - a[1].average)
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }

            getAverageScoreByGenre() {
                const genreScores = {};
                this.albums.forEach(album => {
                    if (album.score !== null && album.score !== undefined && album.score !== '') {
                        const genres = this.parseMultiValue(album.genre, true);
                        genres.forEach(genre => {
                            if (!genreScores[genre]) {
                                genreScores[genre] = [];
                            }
                            genreScores[genre].push(parseFloat(album.score));
                        });
                    }
                });

                const averages = {};
                Object.keys(genreScores).forEach(genre => {
                    const scores = genreScores[genre];
                    averages[genre] = scores.reduce((a, b) => a + b, 0) / scores.length;
                });

                return Object.entries(averages)
                    .sort((a, b) => b[1] - a[1])
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }

            getSourceListStats() {
                const sources = this.getAllSources();
                const stats = {};

                sources.forEach(source => {
                    const albums = this.albums.filter(album => {
                        const albumSources = this.parseMultiValue(album.reason);
                        return albumSources.includes(source);
                    });

                    const listened = albums.filter(a => a.dateListened).length;
                    const scored = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '');
                    const avgScore = scored.length > 0 
                        ? scored.reduce((sum, a) => sum + parseFloat(a.score), 0) / scored.length 
                        : null;

                    stats[source] = {
                        total: albums.length,
                        listened,
                        avgScore
                    };
                });

                return stats;
            }

            getGenreCounts() {
                const genreCounts = {};
                this.albums.forEach(album => {
                    const genres = this.parseMultiValue(album.genre, true);
                    genres.forEach(genre => {
                        if (!genreCounts[genre]) {
                            genreCounts[genre] = 0;
                        }
                        genreCounts[genre]++;
                    });
                });

                return Object.entries(genreCounts)
                    .sort((a, b) => b[1] - a[1])
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }
        }

        // OneDrive Sync Manager
        class OneDriveSyncManager {
            constructor() {
                // IMPORTANT: Replace this with your own Azure App Registration Client ID
                // Instructions: https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app
                
                // Your Azure App Registration Client ID
                this.clientId = 'b19c334e-f1e3-432d-9d79-c50a88eeef0f';
                
                // Redirect URI - automatically detect the current URL
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scopes = ['Files.ReadWrite', 'offline_access'];
                this.fileName = 'album-tracker-data.json';
                this.folderName = 'AlbumTracker';
                
                // Log setup instructions with the actual redirect URI
                console.log('');
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë                  ‚ö†Ô∏è  AZURE SETUP REQUIRED  ‚ö†Ô∏è                ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.log('');
                console.log('üìã STEP 1: COPY THIS REDIRECT URI (select and copy):');
                console.log('');
                console.log('   http://localhost');
                console.log('');
                console.log('üìã STEP 2: ADD TO AZURE PORTAL:');
                console.log('');
                console.log('   1. Go to: https://portal.azure.com');
                console.log('   2. Find app: b19c334e-f1e3-432d-9d79-c50a88eeef0f');
                console.log('   3. Click: Authentication (left sidebar)');
                console.log('   4. Scroll to: "Single-page application"');
                console.log('   5. Click: "Add URI"');
                console.log('   6. Paste: http://localhost');
                console.log('   7. Scroll to: "Implicit grant and hybrid flows"');
                console.log('   8. Check: ‚úÖ Access tokens');
                console.log('   9. Check: ‚úÖ ID tokens');
                console.log('   10. Click: Save');
                console.log('');
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë  After setup, click the sync indicator to connect OneDrive   ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.log('');
                
                this.accessToken = localStorage.getItem('onedrive_access_token');
                this.refreshToken = localStorage.getItem('onedrive_refresh_token');
                this.tokenExpiry = localStorage.getItem('onedrive_token_expiry');
                
                this.syncInProgress = false;
                this.lastSyncTime = localStorage.getItem('last_sync_time');
                
                this.updateUI();
                
                // Check if we're returning from OAuth
                this.handleOAuthCallback();
                
                // Auto-sync on load if connected
                if (this.isConnected()) {
                    this.syncFromOneDrive();
                }
            }

            isConnected() {
                return !!this.accessToken && new Date().getTime() < parseInt(this.tokenExpiry || '0');
            }

            async ensureValidToken() {
                if (!this.accessToken) {
                    throw new Error('Not authenticated');
                }

                // Check if token is expired or will expire in next 5 minutes
                const now = new Date().getTime();
                const expiry = parseInt(this.tokenExpiry || '0');
                
                if (now >= expiry - 300000) { // 5 minutes before expiry
                    await this.refreshAccessToken();
                }
            }

            async refreshAccessToken() {
                if (!this.refreshToken) {
                    throw new Error('No refresh token available');
                }

                try {
                    const response = await fetch('https://login.microsoftonline.com/consumers/oauth2/v2.0/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: this.scopes.join(' '),
                            refresh_token: this.refreshToken,
                            grant_type: 'refresh_token'
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to refresh token');
                    }

                    const data = await response.json();
                    this.saveTokens(data);
                } catch (error) {
                    console.error('Token refresh failed:', error);
                    this.disconnect();
                    throw error;
                }
            }

            connectToOneDrive() {
                // Check if client ID is configured
                if (this.clientId === 'YOUR_CLIENT_ID_HERE') {
                    alert('OneDrive integration requires setup!\n\nPlease follow these steps:\n\n1. Go to Azure Portal (portal.azure.com)\n2. Register a new app\n3. Get your Client ID\n4. Replace YOUR_CLIENT_ID_HERE in the code\n\nSee the console for more details.');
                    console.log('%cOneDrive Setup Instructions:', 'font-size: 16px; font-weight: bold; color: #0078d4;');
                    console.log('1. Go to https://portal.azure.com');
                    console.log('2. Navigate to "Azure Active Directory" > "App registrations" > "New registration"');
                    console.log('3. Name: "Album Tracker"');
                    console.log('4. Supported account types: "Personal Microsoft accounts only"');
                    console.log('5. Redirect URI: "Single-page application (SPA)" - http://localhost');
                    console.log('6. After registration, copy the "Application (client) ID"');
                    console.log('7. Go to "API permissions" > "Add a permission" > "Microsoft Graph" > "Delegated permissions"');
                    console.log('8. Add: Files.ReadWrite and offline_access');
                    console.log('9. Replace YOUR_CLIENT_ID_HERE in the code with your Client ID');
                    console.log('10. Under "Authentication", enable "Access tokens" and "ID tokens" in Implicit grant section');
                    return;
                }

                console.log('Redirect URI: http://localhost');
                console.log('Please add this exact URI to your Azure app registration under Authentication > Single-page application');

                // Show helpful instructions
                const proceed = confirm(
                    'Important:\n\n' +
                    '1. You\'ll be redirected to Microsoft login\n' +
                    '2. After login, you\'ll be sent to http://localhost\n' +
                    '3. IMPORTANT: After redirect, manually open this site again\n' +
                    '4. The app will detect your login and connect automatically\n\n' +
                    '‚ö†Ô∏è Make sure you\'ve added "http://localhost" to your Azure app\'s redirect URIs!\n\n' +
                    'Click OK to continue to Microsoft login.'
                );

                if (!proceed) {
                    return;
                }

                // Use implicit flow with token response (works for local files)
                // Use 'consumers' to force personal Microsoft accounts only
                const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                    `client_id=${this.clientId}` +
                    `&response_type=token` +
                    `&redirect_uri=${encodeURIComponent(this.redirectUri)}` +
                    `&response_mode=fragment` +
                    `&scope=${encodeURIComponent(this.scopes.join(' '))}` +
                    `&state=${Date.now()}` +
                    `&prompt=select_account`;

                // Redirect in the same window (works better for local files)
                window.location.href = authUrl;
            }

            async handleOAuthCallback() {
                // Check for implicit flow token in URL fragment (hash)
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const accessToken = params.get('access_token');
                const expiresIn = params.get('expires_in');

                if (accessToken) {
                    try {
                        this.updateUI('syncing', 'Connecting to OneDrive...');
                        
                        // Save the token (implicit flow doesn't provide refresh token)
                        const tokenData = {
                            access_token: accessToken,
                            expires_in: parseInt(expiresIn) || 3600,
                            refresh_token: null // Implicit flow doesn't provide refresh tokens
                        };
                        
                        this.saveTokens(tokenData);

                        // Clean URL (remove hash)
                        window.history.replaceState({}, document.title, window.location.pathname);

                        // Sync data
                        await this.syncFromOneDrive();
                        
                        showAlert('success', 'Connected to OneDrive successfully!');
                    } catch (error) {
                        console.error('OAuth callback error:', error);
                        showAlert('error', 'Failed to connect to OneDrive');
                        this.updateUI('offline', 'Offline Mode');
                    }
                }
            }

            saveTokens(data) {
                this.accessToken = data.access_token;
                this.refreshToken = data.refresh_token;
                const expiresIn = data.expires_in || 3600;
                this.tokenExpiry = (new Date().getTime() + (expiresIn * 1000)).toString();

                localStorage.setItem('onedrive_access_token', this.accessToken);
                localStorage.setItem('onedrive_refresh_token', this.refreshToken);
                localStorage.setItem('onedrive_token_expiry', this.tokenExpiry);

                this.updateUI('connected', 'Connected to OneDrive');
            }

            disconnect() {
                this.accessToken = null;
                this.refreshToken = null;
                this.tokenExpiry = null;

                localStorage.removeItem('onedrive_access_token');
                localStorage.removeItem('onedrive_refresh_token');
                localStorage.removeItem('onedrive_token_expiry');
                localStorage.removeItem('last_sync_time');

                this.updateUI('offline', 'Offline Mode');
                showAlert('info', 'Disconnected from OneDrive');
            }

            async syncToOneDrive() {
                if (!this.isConnected()) {
                    throw new Error('Not connected to OneDrive');
                }

                if (this.syncInProgress) {
                    return;
                }

                try {
                    this.syncInProgress = true;
                    this.updateUI('syncing', 'Syncing to OneDrive...');

                    await this.ensureValidToken();

                    // Get current data
                    const data = db.getAllAlbums();
                    const jsonData = JSON.stringify(data, null, 2);

                    // Get or create folder
                    const folderId = await this.ensureFolder();

                    // Check if file exists
                    const fileId = await this.getFileId(folderId);

                    if (fileId) {
                        // Update existing file
                        await this.updateFile(fileId, jsonData);
                    } else {
                        // Create new file
                        await this.createFile(folderId, jsonData);
                    }

                    this.lastSyncTime = new Date().toISOString();
                    localStorage.setItem('last_sync_time', this.lastSyncTime);

                    this.updateUI('connected', 'Synced to OneDrive');
                    setTimeout(() => this.updateUI(), 2000);

                } catch (error) {
                    console.error('Sync to OneDrive failed:', error);
                    this.updateUI('error', 'Sync failed');
                    setTimeout(() => this.updateUI(), 3000);
                    throw error;
                } finally {
                    this.syncInProgress = false;
                }
            }

            async syncFromOneDrive() {
                if (!this.isConnected()) {
                    throw new Error('Not connected to OneDrive');
                }

                if (this.syncInProgress) {
                    return;
                }

                try {
                    this.syncInProgress = true;
                    this.updateUI('syncing', 'Loading from OneDrive...');

                    await this.ensureValidToken();

                    // Get or create folder
                    const folderId = await this.ensureFolder();

                    // Check if file exists
                    const fileId = await this.getFileId(folderId);

                    if (fileId) {
                        // Download and merge data
                        const data = await this.downloadFile(fileId);
                        
                        if (data && Array.isArray(data)) {
                            // Merge with local data
                            const localAlbums = db.getAllAlbums();
                            const mergedData = this.mergeAlbumData(localAlbums, data);
                            
                            // Update database
                            db.albums = mergedData;
                            db.saveToStorage();

                            this.lastSyncTime = new Date().toISOString();
                            localStorage.setItem('last_sync_time', this.lastSyncTime);

                            this.updateUI('connected', 'Loaded from OneDrive');
                            
                            // Refresh UI if on browse section
                            if (document.getElementById('browse').classList.contains('active')) {
                                loadBrowseSection();
                            }
                        }
                    } else {
                        // No file exists, upload current data
                        await this.syncToOneDrive();
                    }

                    setTimeout(() => this.updateUI(), 2000);

                } catch (error) {
                    console.error('Sync from OneDrive failed:', error);
                    this.updateUI('error', 'Sync failed');
                    setTimeout(() => this.updateUI(), 3000);
                    throw error;
                } finally {
                    this.syncInProgress = false;
                }
            }

            mergeAlbumData(localAlbums, remoteAlbums) {
                const merged = new Map();

                // Add all local albums
                localAlbums.forEach(album => {
                    const key = `${album.albumName}|${album.artist}`;
                    merged.set(key, album);
                });

                // Merge remote albums
                remoteAlbums.forEach(album => {
                    const key = `${album.albumName}|${album.artist}`;
                    const existing = merged.get(key);

                    if (existing) {
                        // Merge: prefer newer data
                        const mergedAlbum = { ...existing };
                        
                        // Use remote score if local doesn't have one
                        if (album.score && !existing.score) {
                            mergedAlbum.score = album.score;
                        }
                        
                        // Use newer date listened
                        if (album.dateListened && (!existing.dateListened || 
                            new Date(album.dateListened) > new Date(existing.dateListened))) {
                            mergedAlbum.dateListened = album.dateListened;
                        }
                        
                        // Merge notes
                        if (album.notes && album.notes !== existing.notes) {
                            mergedAlbum.notes = existing.notes 
                                ? `${existing.notes}\n\n[From OneDrive]: ${album.notes}`
                                : album.notes;
                        }

                        merged.set(key, mergedAlbum);
                    } else {
                        // Add new album from remote
                        merged.set(key, album);
                    }
                });

                return Array.from(merged.values());
            }

            async ensureFolder() {
                try {
                    // Try to get existing folder
                    const response = await fetch(
                        `https://graph.microsoft.com/v1.0/me/drive/root:/${this.folderName}`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );

                    if (response.ok) {
                        const folder = await response.json();
                        return folder.id;
                    }

                    // Create folder if it doesn't exist
                    const createResponse = await fetch(
                        'https://graph.microsoft.com/v1.0/me/drive/root/children',
                        {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                name: this.folderName,
                                folder: {},
                                '@microsoft.graph.conflictBehavior': 'fail'
                            })
                        }
                    );

                    if (!createResponse.ok) {
                        throw new Error('Failed to create folder');
                    }

                    const folder = await createResponse.json();
                    return folder.id;

                } catch (error) {
                    console.error('Error ensuring folder:', error);
                    throw error;
                }
            }

            async getFileId(folderId) {
                try {
                    const response = await fetch(
                        `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}/children?$filter=name eq '${this.fileName}'`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );

                    if (!response.ok) {
                        return null;
                    }

                    const data = await response.json();
                    return data.value && data.value.length > 0 ? data.value[0].id : null;

                } catch (error) {
                    console.error('Error getting file ID:', error);
                    return null;
                }
            }

            async createFile(folderId, content) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}:/${this.fileName}:/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to create file');
                }

                return await response.json();
            }

            async updateFile(fileId, content) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to update file');
                }

                return await response.json();
            }

            async downloadFile(fileId) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,
                    {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to download file');
                }

                return await response.json();
            }

            updateUI(status, text) {
                const indicator = document.getElementById('syncIndicator');
                const statusText = document.getElementById('syncText');
                const syncStatus = document.getElementById('syncStatus');

                if (!indicator || !statusText || !syncStatus) return;

                // Remove all status classes
                indicator.classList.remove('connected', 'syncing', 'offline', 'error');
                syncStatus.classList.remove('compact');

                if (status) {
                    indicator.classList.add(status);
                    if (status === 'connected') {
                        // Use compact mode for connected status
                        syncStatus.classList.add('compact');
                        const lastSync = this.lastSyncTime 
                            ? new Date(this.lastSyncTime).toLocaleString()
                            : 'Never';
                        statusText.innerHTML = `
                            <span class="sync-main-text">Synced</span>
                            <span class="sync-details">
                                <span class="sync-sub-text">Last: ${lastSync}</span>
                            </span>
                        `;
                    } else {
                        statusText.textContent = text;
                    }
                } else {
                    // Default status based on connection
                    if (this.isConnected()) {
                        indicator.classList.add('connected');
                        syncStatus.classList.add('compact');
                        const lastSync = this.lastSyncTime 
                            ? new Date(this.lastSyncTime).toLocaleString()
                            : 'Never';
                        statusText.innerHTML = `
                            <span class="sync-main-text">Synced</span>
                            <span class="sync-details">
                                <span class="sync-sub-text">Last: ${lastSync}</span>
                            </span>
                        `;
                    } else {
                        indicator.classList.add('offline');
                        statusText.textContent = 'Offline Mode';
                    }
                }

                this.updateSyncMenu();
            }

            updateSyncMenu() {
                const menuContent = document.getElementById('syncMenuContent');
                if (!menuContent) return;

                if (this.isConnected()) {
                    const lastSync = this.lastSyncTime 
                        ? new Date(this.lastSyncTime).toLocaleString()
                        : 'Never';

                    menuContent.innerHTML = `
                        <div style="padding: 10px; color: #666; font-size: 0.9em;">
                            <strong>OneDrive Connected</strong><br>
                            Last sync: ${lastSync}
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.syncFromOneDrive()">
                            <span>‚¨áÔ∏è</span>
                            <span>Load from OneDrive</span>
                        </div>
                        <div class="sync-menu-item" onclick="syncManager.syncToOneDrive()">
                            <span>‚¨ÜÔ∏è</span>
                            <span>Save to OneDrive</span>
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.disconnect()">
                            <span>üîå</span>
                            <span>Disconnect</span>
                        </div>
                    `;
                } else {
                    menuContent.innerHTML = `
                        <div style="padding: 10px; color: #666; font-size: 0.9em;">
                            <strong>Offline Mode</strong><br>
                            Data stored locally only
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.connectToOneDrive()">
                            <span>‚òÅÔ∏è</span>
                            <span>Connect to OneDrive</span>
                        </div>
                    `;
                }
            }
        }

        // Initialize database
        const db = new AlbumDatabase();
        
        // Initialize OneDrive sync
        const syncManager = new OneDriveSyncManager();

        // Settings Functions
        function toggleViewMode() {
            const viewportMeta = document.getElementById('viewport-meta');
            const toggleBtn = document.getElementById('viewToggleBtn');
            const currentContent = viewportMeta.getAttribute('content');
            
            if (currentContent.includes('width=1400')) {
                // Switch to mobile view
                viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0');
                toggleBtn.innerHTML = 'üñ•Ô∏è Desktop View';
                localStorage.setItem('viewMode', 'mobile');
            } else {
                // Switch to desktop view
                viewportMeta.setAttribute('content', 'width=1400, user-scalable=yes');
                toggleBtn.innerHTML = 'üì± Mobile View';
                localStorage.setItem('viewMode', 'desktop');
            }
        }

        function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('active');
            loadSettingsData();
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('active');
        }

        function loadSettingsData() {
            // Load Discogs token
            const token = localStorage.getItem('discogs_api_token');
            const tokenInput = document.getElementById('discogsToken');
            if (token) {
                tokenInput.value = token;
                updateDiscogsStatus('connected');
            } else {
                tokenInput.value = '';
                updateDiscogsStatus('disconnected');
            }
            
            // Load OneDrive status
            updateOneDriveSettingsStatus();
        }

        function saveDiscogsToken() {
            const token = document.getElementById('discogsToken').value.trim();
            
            if (!token) {
                updateDiscogsStatus('error', 'Please enter a token');
                return;
            }
            
            // Validate token format (basic check)
            if (token.length < 20) {
                updateDiscogsStatus('error', 'Token appears to be invalid');
                return;
            }
            
            // Save token
            localStorage.setItem('discogs_api_token', token);
            
            // Test the token
            testDiscogsToken(token);
        }

        async function testDiscogsToken(token) {
            updateDiscogsStatus('disconnected', 'Testing token...');
            
            try {
                const response = await fetch('https://api.discogs.com/database/search?q=test&per_page=1', {
                    headers: {
                        'Authorization': `Discogs token=${token}`,
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (response.ok) {
                    updateDiscogsStatus('connected', '‚úÖ Token saved and verified successfully!');
                    
                    // Show confirmation alert
                    setTimeout(() => {
                        alert('‚úÖ Discogs API token saved successfully!\n\nYou can now use the "Find on Discogs" feature when adding albums.');
                    }, 100);
                    
                    // Sync to OneDrive if connected
                    if (oneDriveManager && oneDriveManager.isAuthenticated) {
                        await syncSettingsToOneDrive();
                    }
                } else {
                    updateDiscogsStatus('error', 'Token is invalid. Please check and try again.');
                    localStorage.removeItem('discogs_api_token');
                }
            } catch (error) {
                updateDiscogsStatus('error', 'Could not verify token. It has been saved but may not work.');
            }
        }

        function clearDiscogsToken() {
            if (confirm('Are you sure you want to remove your Discogs API token?')) {
                localStorage.removeItem('discogs_api_token');
                document.getElementById('discogsToken').value = '';
                updateDiscogsStatus('disconnected', 'Token removed');
                
                // Sync to OneDrive if connected
                if (oneDriveManager && oneDriveManager.isAuthenticated) {
                    syncSettingsToOneDrive();
                }
            }
        }

        function updateDiscogsStatus(status, message) {
            const statusDiv = document.getElementById('discogsStatus');
            
            if (status === 'connected') {
                statusDiv.innerHTML = `
                    <div class="settings-status connected">
                        ‚úÖ ${message || 'Connected to Discogs'}
                    </div>
                `;
            } else if (status === 'disconnected') {
                statusDiv.innerHTML = `
                    <div class="settings-status disconnected">
                        ‚ö†Ô∏è ${message || 'Not configured'}
                    </div>
                `;
            } else if (status === 'error') {
                statusDiv.innerHTML = `
                    <div class="settings-status error">
                        ‚ùå ${message || 'Error'}
                    </div>
                `;
            }
        }

        function updateOneDriveSettingsStatus() {
            const statusDiv = document.getElementById('oneDriveSettingsStatus');
            const buttonsDiv = document.getElementById('oneDriveSettingsButtons');
            
            if (!statusDiv || !buttonsDiv) return;
            
            if (syncManager && syncManager.isConnected()) {
                const lastSync = localStorage.getItem('last_sync_time');
                const lastSyncText = lastSync ? new Date(parseInt(lastSync)).toLocaleString() : 'Never';
                
                statusDiv.innerHTML = `
                    <div class="settings-status connected">
                        üü¢ Connected to OneDrive<br>
                        <small>Last synced: ${lastSyncText}</small>
                    </div>
                `;
                
                buttonsDiv.innerHTML = `
                    <button onclick="disconnectOneDriveFromSettings()" class="settings-btn settings-btn-secondary">
                        Disconnect from OneDrive
                    </button>
                    <button onclick="syncManager.syncToOneDrive()" class="settings-btn settings-btn-primary">
                        Sync Now
                    </button>
                `;
            } else {
                statusDiv.innerHTML = `
                    <div class="settings-status disconnected">
                        ‚ö†Ô∏è Not connected
                    </div>
                `;
                
                buttonsDiv.innerHTML = `
                    <button onclick="syncManager.connect()" class="settings-btn settings-btn-primary">
                        Connect to OneDrive
                    </button>
                `;
            }
        }

        function disconnectOneDriveFromSettings() {
            if (confirm('Are you sure you want to disconnect from OneDrive? Your local data will not be affected.')) {
                syncManager.disconnect();
                updateOneDriveSettingsStatus();
                syncManager.updateUI();
            }
        }

        async function syncSettingsToOneDrive() {
            // Sync settings (like API tokens) to OneDrive
            const settings = {
                discogs_api_token: localStorage.getItem('discogs_api_token')
            };
            
            try {
                await oneDriveManager.saveFile('settings.json', JSON.stringify(settings));
            } catch (error) {
                console.error('Failed to sync settings to OneDrive:', error);
            }
        }

        function showDiscogsInstructions() {
            const modal = document.getElementById('instructionsModal');
            modal.classList.add('active');
        }

        function closeInstructions() {
            const modal = document.getElementById('instructionsModal');
            modal.classList.remove('active');
        }

        // Discogs Integration Functions
        async function searchDiscogs() {
            const artist = document.getElementById('quickSearchArtist').value.trim();
            const album = document.getElementById('quickSearchAlbum').value.trim();
            const statusDiv = document.getElementById('discogsSearchStatus');
            
            if (!artist || !album) {
                showDiscogsStatus('Please enter both artist and album name.', 'error');
                return;
            }
            
            // Check if API token is configured
            const apiToken = localStorage.getItem('discogs_api_token');
            if (!apiToken) {
                showDiscogsStatus('‚ö†Ô∏è Discogs API not configured. Please add your API token in Settings.', 'error');
                setTimeout(() => {
                    if (confirm('Would you like to open Settings to add your Discogs API token?')) {
                        openSettings();
                    }
                }, 500);
                return;
            }
            
            showDiscogsStatus('üîç Searching Discogs...', 'loading');
            
            try {
                const query = `${artist} ${album}`;
                
                // First, try to find master release
                const masterUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(query)}&type=master&token=${apiToken}`;
                
                const masterResponse = await fetch(masterUrl, {
                    headers: {
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (!masterResponse.ok) {
                    throw new Error(`Discogs API error: ${masterResponse.status}`);
                }
                
                const masterData = await masterResponse.json();
                
                // If we found a master release with exact match, use it immediately
                if (masterData.results && masterData.results.length > 0) {
                    const exactMaster = masterData.results.find(m => {
                        const titleLower = m.title.toLowerCase();
                        const albumLower = album.toLowerCase();
                        const artistLower = artist.toLowerCase();
                        
                        // Check if title contains album name and artist name
                        return titleLower.includes(albumLower) && titleLower.includes(artistLower);
                    });
                    
                    if (exactMaster) {
                        // Found exact master match - auto-fill immediately
                        showDiscogsStatus('‚úÖ Found master release! Auto-filling...', 'success');
                        await fetchAlbumDetails(exactMaster.id, true);
                        return;
                    }
                }
                
                // If no exact master found, search all releases
                const url = `https://api.discogs.com/database/search?q=${encodeURIComponent(query)}&type=release&token=${apiToken}`;
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Discogs API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Combine master and release results
                let albums = [];
                if (masterData.results) {
                    albums = albums.concat(masterData.results);
                }
                if (data.results) {
                    albums = albums.concat(data.results.filter(r => r.type === 'release' || r.type === 'master'));
                }
                
                if (albums.length === 0) {
                    showDiscogsStatus('‚ùå No results found. Try different search terms or search manually.', 'error');
                    return;
                }
                
                // Remove duplicates (same ID)
                const uniqueAlbums = [];
                const seenIds = new Set();
                albums.forEach(a => {
                    if (!seenIds.has(a.id)) {
                        seenIds.add(a.id);
                        uniqueAlbums.push(a);
                    }
                });
                albums = uniqueAlbums;
                
                // Sort: masters first, then by year (newest first)
                albums.sort((a, b) => {
                    if (a.type === 'master' && b.type !== 'master') return -1;
                    if (a.type !== 'master' && b.type === 'master') return 1;
                    return (b.year || 0) - (a.year || 0);
                });
                
                // If there's only one master and multiple releases, auto-select the master
                const masters = albums.filter(a => a.type === 'master');
                if (masters.length === 1 && albums.length > 1) {
                    showDiscogsStatus('‚úÖ Found master release! Auto-filling...', 'success');
                    await fetchAlbumDetails(masters[0].id, true);
                    return;
                }
                
                // Check for clear match
                const exactMatch = albums.find(a => {
                    const titleLower = a.title.toLowerCase();
                    const albumLower = album.toLowerCase();
                    const artistLower = artist.toLowerCase();
                    return titleLower.includes(albumLower) && titleLower.includes(artistLower);
                });
                
                if (albums.length === 1) {
                    // Single result - auto-fill
                    const selectedAlbum = albums[0];
                    const isMaster = selectedAlbum.type === 'master';
                    await fetchAlbumDetails(selectedAlbum.id, isMaster);
                } else if (exactMatch && albums.length <= 3 && exactMatch.type === 'master') {
                    // Exact master match with few results - auto-fill
                    await fetchAlbumDetails(exactMatch.id, true);
                } else {
                    // Multiple matches - show selection UI
                    showDiscogsResults(albums.slice(0, 10)); // Show top 10 results
                }
                
            } catch (error) {
                console.error('Discogs search error:', error);
                showDiscogsStatus('‚ùå Error searching Discogs. Please try again or search manually.', 'error');
            }
        }

        async function fetchAlbumDetails(releaseId, isMaster = false) {
            const apiToken = localStorage.getItem('discogs_api_token');
            const statusDiv = document.getElementById('discogsSearchStatus');
            
            showDiscogsStatus('üì• Loading album details...', 'loading');
            
            try {
                // Use appropriate endpoint based on whether it's a master or release
                const endpoint = isMaster ? 'masters' : 'releases';
                const url = `https://api.discogs.com/${endpoint}/${releaseId}?token=${apiToken}`;
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Discogs API error: ${response.status}`);
                }
                
                const album = await response.json();
                
                // Auto-fill form fields
                fillFormFromDiscogs(album);
                
                showDiscogsStatus('‚úÖ Album details loaded! Review and save below.', 'success');
                
                // Close results modal if open
                closeDiscogsResults();
                
            } catch (error) {
                console.error('Error fetching album details:', error);
                showDiscogsStatus('‚ùå Error loading album details. Please try again.', 'error');
            }
        }

        function fillFormFromDiscogs(album) {
            // Extract data from Discogs response
            const albumName = album.title || '';
            // Join all artists with "; " separator (handles multiple artists)
            const artist = album.artists && album.artists.length > 0 
                ? album.artists.map(a => a.name).join('; ') 
                : '';
            const year = album.year || new Date().getFullYear();
            const genres = album.genres ? album.genres.join('; ') : '';
            const styles = album.styles ? album.styles.join('; ') : '';
            const labels = album.labels ? album.labels.map(l => l.name).join('; ') : '';
            const artworkUrl = album.images && album.images.length > 0 ? album.images[0].uri : '';
            const discogsUrl = album.uri || '';
            
            // Fill inline form fields
            document.getElementById('albumNameInline').value = albumName;
            document.getElementById('artistInline').value = artist;
            document.getElementById('yearInline').value = year;
            document.getElementById('genreInline').value = genres;
            document.getElementById('styleInline').value = styles;
            document.getElementById('reasonInline').value = labels ? `Discogs: ${labels}` : 'Discogs';
            document.getElementById('artworkUrlInline').value = artworkUrl;
            document.getElementById('discogsUrlInline').value = discogsUrl;
            
            // Scroll to form
            document.getElementById('addAlbumFormInline').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function showDiscogsResults(results) {
            const modal = document.getElementById('discogsResultsModal');
            const listDiv = document.getElementById('discogsResultsList');
            
            listDiv.innerHTML = results.map((result, index) => {
                const title = result.title || 'Unknown Album';
                const year = result.year || 'Unknown';
                const format = result.format ? result.format.join(', ') : 'Unknown';
                const label = result.label ? result.label.join(', ') : 'Unknown';
                const country = result.country || 'Unknown';
                const imageUrl = result.thumb || result.cover_image || '';
                const isMaster = result.type === 'master';
                const typeLabel = isMaster ? ' <span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em;">MASTER</span>' : '';
                
                return `
                    <div class="discogs-result-card" onclick="selectDiscogsResult(${result.id}, ${isMaster})">
                        ${imageUrl ? `<img src="${imageUrl}" alt="${title}" class="discogs-result-image">` : '<div class="discogs-result-image"></div>'}
                        <div class="discogs-result-info">
                            <div class="discogs-result-title">${title}${typeLabel}</div>
                            <div class="discogs-result-details">
                                <strong>Year:</strong> ${year}<br>
                                <strong>Format:</strong> ${format}<br>
                                <strong>Label:</strong> ${label}<br>
                                <strong>Country:</strong> ${country}
                            </div>
                        </div>
                        <button class="discogs-result-button" onclick="event.stopPropagation(); selectDiscogsResult(${result.id}, ${isMaster})">
                            Select This
                        </button>
                    </div>
                `;
            }).join('');
            
            modal.classList.add('active');
            showDiscogsStatus('', 'hidden');
        }

        function selectDiscogsResult(releaseId, isMaster = false) {
            fetchAlbumDetails(releaseId, isMaster);
        }

        function closeDiscogsResults() {
            const modal = document.getElementById('discogsResultsModal');
            modal.classList.remove('active');
        }

        function showDiscogsStatus(message, type) {
            const statusDiv = document.getElementById('discogsSearchStatus');
            statusDiv.textContent = message;
            statusDiv.style.display = message ? 'block' : 'none';
            
            // Set colors based on type
            if (type === 'error') {
                statusDiv.style.background = '#fee';
                statusDiv.style.color = '#c33';
                statusDiv.style.border = '1px solid #fcc';
            } else if (type === 'success') {
                statusDiv.style.background = '#efe';
                statusDiv.style.color = '#3a3';
                statusDiv.style.border = '1px solid #cfc';
            } else if (type === 'loading') {
                statusDiv.style.background = '#fef9e7';
                statusDiv.style.color = '#856404';
                statusDiv.style.border = '1px solid #ffeaa7';
            } else {
                statusDiv.style.display = 'none';
            }
        }

        function clearQuickSearch() {
            document.getElementById('quickSearchArtist').value = '';
            document.getElementById('quickSearchAlbum').value = '';
            document.getElementById('discogsUrl').value = '';
            showDiscogsStatus('', 'hidden');
        }

        async function fetchFromDiscogsUrl() {
            const urlInput = document.getElementById('discogsUrl').value.trim();
            
            if (!urlInput) {
                showDiscogsStatus('Please enter a Discogs URL.', 'error');
                return;
            }
            
            // Check if API token is configured
            const apiToken = localStorage.getItem('discogs_api_token');
            if (!apiToken) {
                showDiscogsStatus('‚ö†Ô∏è Discogs API not configured. Please add your API token in Settings.', 'error');
                setTimeout(() => {
                    if (confirm('Would you like to open Settings to add your Discogs API token?')) {
                        openSettings();
                    }
                }, 500);
                return;
            }
            
            // Extract release ID from URL
            // Formats: https://www.discogs.com/release/123456 or https://www.discogs.com/Artist-Album/release/123456
            let releaseId = null;
            let isMaster = false;
            
            const releaseMatch = urlInput.match(/\/release\/(\d+)/);
            const masterMatch = urlInput.match(/\/master\/(\d+)/);
            
            if (releaseMatch) {
                releaseId = releaseMatch[1];
                isMaster = false;
            } else if (masterMatch) {
                releaseId = masterMatch[1];
                isMaster = true;
            } else {
                showDiscogsStatus('‚ùå Invalid Discogs URL. Please use a release or master URL.', 'error');
                return;
            }
            
            showDiscogsStatus('üì• Loading album from Discogs URL...', 'loading');
            
            try {
                await fetchAlbumDetails(releaseId, isMaster);
            } catch (error) {
                console.error('Error fetching from URL:', error);
                showDiscogsStatus('‚ùå Error loading album from URL. Please check the URL and try again.', 'error');
            }
        }

        function openDiscogsManually() {
            const artist = document.getElementById('quickSearchArtist').value.trim();
            const album = document.getElementById('quickSearchAlbum').value.trim();
            
            let url = 'https://www.discogs.com/search/';
            if (artist || album) {
                const query = `${artist} ${album}`.trim();
                url += `?q=${encodeURIComponent(query)}&type=release`;
            }
            
            window.open(url, '_blank');
        }

        function exportBackup() {
            // Use existing export functionality
            exportToExcel();
        }

        function confirmClearData() {
            if (confirm('‚ö†Ô∏è WARNING: This will delete ALL your album data from this device!\n\nThis action cannot be undone. Are you absolutely sure?')) {
                if (confirm('This is your last chance! Click OK to permanently delete all data.')) {
                    localStorage.removeItem('albumTrackerData');
                    db.albums = [];
                    alert('All data has been cleared.');
                    closeSettings();
                    loadBrowseSection();
                }
            }
        }

        // Duplicate Cleanup Functions
        let duplicatesToDelete = [];

        function openDuplicateCleanup() {
            const modal = document.getElementById('duplicateCleanupModal');
            modal.classList.add('active');
            scanForDuplicates();
        }

        function closeDuplicateCleanup() {
            const modal = document.getElementById('duplicateCleanupModal');
            modal.classList.remove('active');
            duplicatesToDelete = [];
        }

        function scanForDuplicates() {
            const content = document.getElementById('duplicateCleanupContent');
            content.innerHTML = '<p style="color: #666;">Scanning for duplicates...</p>';

            // Find potential duplicates
            const duplicateGroups = [];
            const processed = new Set();

            db.albums.forEach((album, index) => {
                if (processed.has(album.id)) return;

                const potentialDupes = db.albums.filter((other, otherIndex) => {
                    if (otherIndex === index || processed.has(other.id)) return false;
                    
                    // Check if album names match
                    const nameMatch = String(album.albumName).toLowerCase().trim() === 
                                    String(other.albumName).toLowerCase().trim();
                    
                    if (!nameMatch) return false;

                    // Check if artist names are similar
                    const artist1 = String(album.artist).toLowerCase().trim();
                    const artist2 = String(other.artist).toLowerCase().trim();
                    
                    // Exact match
                    if (artist1 === artist2) return true;
                    
                    // Check if only difference is semicolon vs comma
                    const artist1Normalized = artist1.replace(/[;,]/g, '|').split('|').map(s => s.trim()).sort().join('|');
                    const artist2Normalized = artist2.replace(/[;,]/g, '|').split('|').map(s => s.trim()).sort().join('|');
                    
                    return artist1Normalized === artist2Normalized;
                });

                if (potentialDupes.length > 0) {
                    const group = [album, ...potentialDupes];
                    group.forEach(a => processed.add(a.id));
                    duplicateGroups.push(group);
                }
            });

            if (duplicateGroups.length === 0) {
                content.innerHTML = `
                    <div class="alert alert-success">
                        <strong>‚úÖ No duplicates found!</strong>
                        <p>Your album collection is clean.</p>
                    </div>
                `;
                document.getElementById('deleteDuplicatesBtn').style.display = 'none';
                return;
            }

            // Count confidence levels
            const decisions = duplicateGroups.map(g => decideDuplicateAction(g));
            const highConfidence = decisions.filter(d => d.confidence === 'high').length;
            const mediumConfidence = decisions.filter(d => d.confidence === 'medium').length;
            const lowConfidence = decisions.filter(d => d.confidence === 'low').length;
            const totalToDelete = decisions.reduce((sum, d) => sum + d.delete.length, 0);

            // Display duplicate groups
            let html = `
                <div class="alert alert-info">
                    <strong>Found ${duplicateGroups.length} duplicate group(s)</strong>
                    <p>Review the albums below and confirm which ones to delete.</p>
                    <div style="margin-top: 10px; font-size: 0.9em;">
                        <strong>Confidence:</strong> 
                        <span style="color: #28a745;">‚óè</span> High: ${highConfidence} | 
                        <span style="color: #ffc107;">‚óè</span> Medium: ${mediumConfidence} | 
                        <span style="color: #dc3545;">‚óè</span> Low: ${lowConfidence}
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="selectAllMarkedDelete()" class="btn btn-sm" style="margin-right: 5px;">Select All Marked Delete</button>
                        <button onclick="selectHighConfidenceOnly()" class="btn btn-sm" style="margin-right: 5px;">Select High Confidence Only</button>
                        <button onclick="deselectAll()" class="btn btn-sm">Deselect All</button>
                    </div>
                </div>
            `;

            duplicateGroups.forEach((group, groupIndex) => {
                const decision = decideDuplicateAction(group);
                const confidenceColor = decision.confidence === 'high' ? '#28a745' : 
                                       decision.confidence === 'medium' ? '#ffc107' : '#dc3545';
                const confidenceLabel = decision.confidence.toUpperCase();

                html += `
                    <div class="duplicate-group" data-confidence="${decision.confidence}">
                        <h4 style="margin-bottom: 10px;">
                            ${group[0].albumName} - ${group[0].artist}
                            <span style="color: ${confidenceColor}; font-size: 0.8em; margin-left: 10px;">
                                ‚óè ${confidenceLabel} CONFIDENCE
                            </span>
                        </h4>
                        <div style="font-size: 0.85em; color: #666; margin-bottom: 15px; font-style: italic;">
                            ${decision.reason}
                        </div>
                `;

                group.forEach((album, itemIndex) => {
                    const action = decision.keep.includes(album.id) ? 'keep' : 
                                 decision.delete.includes(album.id) ? 'delete' : 'query';
                    
                    const checked = action === 'delete' ? 'checked' : '';
                    const badge = action === 'keep' ? '<span class="duplicate-badge badge-keep">‚úì KEEP</span>' :
                                action === 'delete' ? '<span class="duplicate-badge badge-delete">‚úó DELETE</span>' :
                                '<span class="duplicate-badge badge-query">? REVIEW</span>';

                    // Use unique identifier combining group and item index
                    const uniqueId = `${groupIndex}-${itemIndex}`;
                    const albumIndex = db.albums.indexOf(album);

                    html += `
                        <div class="duplicate-item ${action}" id="duplicate-${uniqueId}" data-confidence="${decision.confidence}">
                            <input type="checkbox" 
                                   class="duplicate-checkbox" 
                                   id="check-${uniqueId}" 
                                   data-album-index="${albumIndex}"
                                   data-album-id="${album.id}"
                                   data-confidence="${decision.confidence}"
                                   ${checked}
                                   onchange="toggleDuplicateSelection('${uniqueId}', ${albumIndex})">
                            <div class="duplicate-info">
                                <div><strong>ID:</strong> ${album.id} ${badge}</div>
                                <div><strong>Artist:</strong> ${album.artist}</div>
                                <div><strong>Year:</strong> ${album.year || 'N/A'}</div>
                                <div><strong>Score:</strong> ${album.score || 'Unrated'}</div>
                                <div><strong>Genre:</strong> ${album.genre || 'N/A'}</div>
                                ${album.discogsUrl ? `<div><strong>Discogs:</strong> <a href="${album.discogsUrl}" target="_blank">View</a></div>` : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
            });

            content.innerHTML = html;
            
            // Initialize duplicatesToDelete with auto-selected items
            duplicatesToDelete = [];
            duplicateGroups.forEach(group => {
                const decision = decideDuplicateAction(group);
                // Push album objects instead of IDs
                const albumsToDelete = group.filter(album => decision.delete.includes(album.id));
                duplicatesToDelete.push(...albumsToDelete);
            });

            document.getElementById('deleteDuplicatesBtn').style.display = 'block';
        }

        function decideDuplicateAction(group) {
            const decision = { keep: [], delete: [], confidence: 'low', reason: '' };

            // Rule 1: Semicolon vs Comma in artist names
            const semicolonVersions = group.filter(a => String(a.artist).includes(';'));
            const commaVersions = group.filter(a => String(a.artist).includes(',') && !String(a.artist).includes(';'));
            
            if (semicolonVersions.length > 0 && commaVersions.length > 0) {
                // Check if comma versions are rated
                const ratedCommaVersions = commaVersions.filter(a => a.score && a.score !== '');
                const ratedSemicolonVersions = semicolonVersions.filter(a => a.score && a.score !== '');
                
                // Exception: If comma version is rated and semicolon is not, keep comma version
                if (ratedCommaVersions.length > 0 && ratedSemicolonVersions.length === 0) {
                    decision.keep.push(ratedCommaVersions[0].id);
                    decision.delete.push(...commaVersions.filter(a => a.id !== ratedCommaVersions[0].id).map(a => a.id));
                    decision.delete.push(...semicolonVersions.map(a => a.id));
                    decision.confidence = 'high';
                    decision.reason = 'Rated comma version kept over unrated semicolon version';
                    return decision;
                }
                
                // Default: Keep semicolon version, delete comma versions
                decision.keep.push(semicolonVersions[0].id);
                decision.delete.push(...commaVersions.map(a => a.id));
                
                // If multiple semicolon versions, mark as medium confidence
                if (semicolonVersions.length > 1) {
                    decision.delete.push(...semicolonVersions.slice(1).map(a => a.id));
                    decision.confidence = 'medium';
                    decision.reason = 'Multiple semicolon versions - kept first one';
                } else {
                    decision.confidence = 'high';
                    decision.reason = 'Semicolon separator preferred over comma';
                }
                return decision;
            }

            // Rule 2: Rated vs Unrated
            const ratedAlbums = group.filter(a => a.score && a.score !== '');
            const unratedAlbums = group.filter(a => !a.score || a.score === '');
            
            if (ratedAlbums.length === 1 && unratedAlbums.length > 0) {
                decision.keep.push(ratedAlbums[0].id);
                decision.delete.push(...unratedAlbums.map(a => a.id));
                decision.confidence = 'high';
                decision.reason = 'Rated version kept over unrated';
                return decision;
            }
            
            if (ratedAlbums.length > 1) {
                // Multiple rated versions - need manual review
                decision.keep.push(ratedAlbums[0].id);
                decision.delete.push(...ratedAlbums.slice(1).map(a => a.id));
                decision.delete.push(...unratedAlbums.map(a => a.id));
                decision.confidence = 'low';
                decision.reason = 'Multiple rated versions - manual review needed';
                return decision;
            }

            // Rule 3: Same details except ID - keep lowest ID
            const allSame = group.every(a => 
                a.albumName === group[0].albumName &&
                a.artist === group[0].artist &&
                (a.year || '') === (group[0].year || '') &&
                (a.genre || '') === (group[0].genre || '') &&
                (a.score || '') === (group[0].score || '')
            );

            if (allSame) {
                const sorted = [...group].sort((a, b) => a.id - b.id);
                decision.keep.push(sorted[0].id);
                decision.delete.push(...sorted.slice(1).map(a => a.id));
                decision.confidence = 'high';
                decision.reason = 'Identical albums - kept lowest ID';
                return decision;
            }

            // Rule 4: Different years - likely different editions
            const years = [...new Set(group.map(a => a.year).filter(y => y))];
            if (years.length > 1) {
                decision.keep.push(group[0].id);
                decision.delete.push(...group.slice(1).map(a => a.id));
                decision.confidence = 'low';
                decision.reason = 'Different years - possibly different editions';
                return decision;
            }

            // Rule 5: Different genres - uncertain
            const genres = [...new Set(group.map(a => a.genre).filter(g => g))];
            if (genres.length > 1) {
                decision.keep.push(group[0].id);
                decision.delete.push(...group.slice(1).map(a => a.id));
                decision.confidence = 'low';
                decision.reason = 'Different genres - manual review needed';
                return decision;
            }

            // Default: Can't decide automatically
            decision.keep.push(group[0].id);
            decision.delete.push(...group.slice(1).map(a => a.id));
            decision.confidence = 'low';
            decision.reason = 'Unable to determine automatically';
            return decision;
        }

        function toggleDuplicateSelection(uniqueId, albumIndex) {
            const checkbox = document.getElementById(`check-${uniqueId}`);
            const item = document.getElementById(`duplicate-${uniqueId}`);
            const album = db.albums[albumIndex];
            
            if (checkbox.checked) {
                // Add to delete list if not already there
                if (!duplicatesToDelete.some(a => db.albums.indexOf(a) === albumIndex)) {
                    duplicatesToDelete.push(album);
                }
                item.classList.add('delete');
                item.classList.remove('keep');
            } else {
                // Remove from delete list
                duplicatesToDelete = duplicatesToDelete.filter(a => db.albums.indexOf(a) !== albumIndex);
                item.classList.add('keep');
                item.classList.remove('delete');
            }
        }

        function selectAllMarkedDelete() {
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            duplicatesToDelete = [];
            
            checkboxes.forEach(checkbox => {
                const uniqueId = checkbox.id.replace('check-', '');
                const item = document.getElementById(`duplicate-${uniqueId}`);
                const badge = item.querySelector('.duplicate-badge');
                const albumIndex = parseInt(checkbox.dataset.albumIndex);
                
                // Check if originally marked for deletion
                if (badge && badge.textContent.includes('DELETE')) {
                    checkbox.checked = true;
                    duplicatesToDelete.push(db.albums[albumIndex]);
                    item.classList.add('delete');
                    item.classList.remove('keep');
                }
            });
            
            alert(`Selected ${duplicatesToDelete.length} albums marked for deletion.`);
        }

        function selectHighConfidenceOnly() {
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            duplicatesToDelete = [];
            
            checkboxes.forEach(checkbox => {
                const uniqueId = checkbox.id.replace('check-', '');
                const item = document.getElementById(`duplicate-${uniqueId}`);
                const badge = item.querySelector('.duplicate-badge');
                const confidence = checkbox.dataset.confidence;
                const albumIndex = parseInt(checkbox.dataset.albumIndex);
                
                // Check if high confidence AND marked for deletion
                if (confidence === 'high' && badge && badge.textContent.includes('DELETE')) {
                    checkbox.checked = true;
                    duplicatesToDelete.push(db.albums[albumIndex]);
                    item.classList.add('delete');
                    item.classList.remove('keep');
                } else {
                    checkbox.checked = false;
                    item.classList.add('keep');
                    item.classList.remove('delete');
                }
            });
            
            alert(`Selected ${duplicatesToDelete.length} high-confidence albums for deletion.`);
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            duplicatesToDelete = [];
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const uniqueId = checkbox.id.replace('check-', '');
                const item = document.getElementById(`duplicate-${uniqueId}`);
                item.classList.add('keep');
                item.classList.remove('delete');
            });
            
            alert('All selections cleared.');
        }

        function deleteDuplicates() {
            if (duplicatesToDelete.length === 0) {
                alert('No albums selected for deletion.');
                return;
            }

            if (!confirm(`Are you sure you want to delete ${duplicatesToDelete.length} duplicate album(s)?\n\nThis action cannot be undone.`)) {
                return;
            }

            // Delete the selected albums by ID
            duplicatesToDelete.forEach(album => {
                db.deleteAlbum(album.id);
            });

            alert(`Successfully deleted ${duplicatesToDelete.length} duplicate album(s).`);
            closeDuplicateCleanup();
            loadBrowseSection();
        }

        // Clean Up IDs Function
        function cleanupIDs() {
            if (!confirm('This will renumber all album IDs starting from 1.\n\nExisting IDs will be replaced with sequential numbers.\n\nContinue?')) {
                return;
            }

            // Sort albums by current ID
            const sortedAlbums = [...db.albums].sort((a, b) => a.id - b.id);

            // Reassign IDs sequentially
            sortedAlbums.forEach((album, index) => {
                album.id = index + 1;
            });

            // Update the database
            db.albums = sortedAlbums;
            db.saveToStorage();

            alert(`Successfully renumbered ${sortedAlbums.length} albums.\n\nIDs now range from 1 to ${sortedAlbums.length}.`);
            loadBrowseSection();
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(event) {
            const settingsModal = document.getElementById('settingsModal');
            const instructionsModal = document.getElementById('instructionsModal');
            const discogsResultsModal = document.getElementById('discogsResultsModal');
            const duplicateCleanupModal = document.getElementById('duplicateCleanupModal');
            
            if (event.target === settingsModal) {
                closeSettings();
            }
            
            if (event.target === instructionsModal) {
                closeInstructions();
            }
            
            if (event.target === discogsResultsModal) {
                closeDiscogsResults();
            }
            
            if (event.target === duplicateCleanupModal) {
                closeDuplicateCleanup();
            }
        });

        // Navigation
        function showSection(sectionId, event) {
            console.log('showSection called with:', sectionId);
            
            // Update active button
            const navButtons = document.querySelectorAll('.nav button');
            console.log('Found nav buttons:', navButtons.length);
            navButtons.forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }

            // Show section
            const sections = document.querySelectorAll('.section');
            console.log('Found sections:', sections.length);
            sections.forEach(section => section.classList.remove('active'));
            
            const targetSection = document.getElementById(sectionId);
            console.log('Target section:', targetSection);
            if (targetSection) {
                targetSection.classList.add('active');
            }

            // Load section-specific content
            if (sectionId === 'browse') {
                loadBrowseSection();
            } else if (sectionId === 'stats') {
                loadStatsSection();
            }
        }

        // Show/Hide Add Album Form
        function showAddAlbumForm() {
            document.getElementById('addAlbumFormContainer').style.display = 'block';
            document.getElementById('albumNameInline').focus();
        }

        function hideAddAlbumForm() {
            document.getElementById('addAlbumFormContainer').style.display = 'none';
            document.getElementById('addAlbumFormInline').reset();
        }

        function addAlbumInline(event) {
            event.preventDefault();
            
            const albumData = {
                albumName: document.getElementById('albumNameInline').value,
                artist: document.getElementById('artistInline').value,
                year: document.getElementById('yearInline').value,
                artworkUrl: document.getElementById('artworkUrlInline').value,
                discogsUrl: document.getElementById('discogsUrlInline').value || '',
                genre: document.getElementById('genreInline').value || '',
                style: document.getElementById('styleInline').value || '',
                reason: document.getElementById('reasonInline').value || 'Manual',
                score: document.getElementById('scoreInline').value || null,
                dateListened: null,
                notes: ''
            };

            if (db.isDuplicate(albumData.albumName, albumData.artist)) {
                alert('This album already exists in your collection!');
                return;
            }

            db.addAlbum(albumData);
            alert('Album added successfully!');
            hideAddAlbumForm();
            loadBrowseSection();
        }

        // Download Import Template
        function downloadImportTemplate() {
            const headers = ['ID', 'Album Name', 'Artist', 'Year', 'Reason', 'Album Artwork URL', 'Discogs URL', 'Artist ID', 'Genre', 'Style', 'Score', 'Date Listened', 'Notes'];
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([headers]);
            
            // Set column widths
            ws['!cols'] = [
                { wch: 5 },   // ID
                { wch: 30 },  // Album Name
                { wch: 25 },  // Artist
                { wch: 6 },   // Year
                { wch: 20 },  // Reason
                { wch: 50 },  // Album Artwork URL
                { wch: 50 },  // Discogs URL
                { wch: 15 },  // Artist ID
                { wch: 20 },  // Genre
                { wch: 20 },  // Style
                { wch: 6 },   // Score
                { wch: 12 },  // Date Listened
                { wch: 30 }   // Notes
            ];
            
            XLSX.utils.book_append_sheet(wb, ws, 'Template');
            XLSX.writeFile(wb, 'album_import_template.xlsx');
        }

        // Pick Random Album (from vinyl button)
        function pickRandomAlbum() {
            // Navigate to random section and automatically select an album
            showSection('random');
            // Wait for section to be visible, then trigger album selection
            setTimeout(() => {
                selectRandomAlbum();
            }, 100);
        }

        // Random Album Selection
        // Helper function to create Wikipedia link
        function getWikipediaLink(searchTerm, type, artistName = null) {
            let searchQuery = searchTerm;
            if (type === 'album' && artistName) {
                // Include artist name for album searches to get more accurate results
                searchQuery = `${searchTerm} ${artistName}`;
            }
            const encodedSearch = encodeURIComponent(searchQuery + ' ' + type + ' wikipedia');
            return `https://www.google.com/search?q=${encodedSearch}&btnI=I%27m+Feeling+Lucky`;
        }

        // Helper function to create Wikipedia icon
        function getWikiIcon() {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>`;
        }

        // Helper function to create Spotify link
        function getSpotifyLink(albumName, artistName) {
            const searchQuery = `${albumName} ${artistName}`;
            const encodedSearch = encodeURIComponent(searchQuery);
            return `https://open.spotify.com/search/${encodedSearch}`;
        }

        // Helper function to create Spotify icon (green logo)
        function getSpotifyIcon() {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
            </svg>`;
        }

        function selectRandomAlbum() {
            const album = db.getRandomUnscoredAlbum();
            const display = document.getElementById('randomAlbumDisplay');

            if (!album) {
                display.innerHTML = `
                    <div class="empty-state" style="color: white;">
                        <h3>üéâ All albums have been rated!</h3>
                        <p>You've completed your collection. Add more albums or browse your ratings.</p>
                    </div>
                `;
                return;
            }

            const genres = db.parseMultiValue(album.genre, true);
            const styles = db.parseMultiValue(album.style);
            const sources = db.parseMultiValue(album.reason);

            display.innerHTML = `
                <div class="random-album-content">
                    <div>
                        <img src="${album.artworkUrl}" alt="${album.albumName}" class="album-artwork" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22300%22%3E%3Crect fill=%22%23ddd%22 width=%22300%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2220%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    </div>
                    <div class="album-details">
                        <h2>${album.albumName}<a href="${getWikipediaLink(album.albumName, 'album', album.artist)}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia">${getWikiIcon()}</a><a href="${getSpotifyLink(album.albumName, album.artist)}" target="_blank" rel="noopener noreferrer" class="spotify-link" title="Search on Spotify">${getSpotifyIcon()}</a></h2>
                        <p><strong>Artist:</strong> ${album.artist}<a href="${getWikipediaLink(album.artist, 'artist')}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia">${getWikiIcon()}</a></p>
                        <p><strong>Year:</strong> ${album.year}</p>
                        ${genres.length > 0 ? `<p><strong>Genre:</strong> ${genres.join(', ')}</p>` : ''}
                        ${styles.length > 0 ? `<p><strong>Style:</strong> ${styles.join(', ')}</p>` : ''}
                        ${sources.length > 0 ? `<p><strong>Source:</strong> ${sources.join(', ')}</p>` : ''}
                        
                        <div class="rating-form">
                            <h3 style="margin-bottom: 15px;">Rate This Album</h3>
                            <form onsubmit="rateAlbum(event, ${album.id})">
                                <div class="form-group">
                                    <label>Score (0-10) *</label>
                                    <input type="number" id="ratingScore" min="0" max="10" step="0.1" required>
                                </div>
                                <div class="form-group">
                                    <label>Date Listened</label>
                                    <input type="date" id="ratingDate" value="${new Date().toISOString().split('T')[0]}">
                                </div>
                                <div class="form-group">
                                    <label>Notes</label>
                                    <textarea id="ratingNotes" placeholder="Your thoughts..."></textarea>
                                </div>
                                <button type="submit" class="btn btn-success">Submit Rating</button>
                            </form>
                        </div>
                    </div>
                </div>
            `;
        }

        function rateAlbum(event, albumId) {
            event.preventDefault();
            
            const score = parseFloat(document.getElementById('ratingScore').value);
            const dateListened = document.getElementById('ratingDate').value;
            const notes = document.getElementById('ratingNotes').value;

            db.updateAlbum(albumId, {
                score,
                dateListened,
                notes
            });

            autoSyncToOneDrive();
            showAlert('success', 'Album rated successfully!');
            selectRandomAlbum();
        }

        // Generate Random List of 10 Albums
        function generateRandomList() {
            const albums = db.getAllAlbums();
            if (albums.length === 0) {
                showAlert('warning', 'No albums in your collection!');
                return;
            }

            // Filter to only unrated albums (no score or score is 0)
            const unratedAlbums = albums.filter(album => !album.score || album.score === 0 || album.score === '0');
            
            if (unratedAlbums.length === 0) {
                showAlert('info', 'All albums have been rated! Add more albums to generate a new list.');
                return;
            }

            // Get 10 random unrated albums
            const shuffled = [...unratedAlbums].sort(() => 0.5 - Math.random());
            const randomAlbums = shuffled.slice(0, Math.min(10, unratedAlbums.length));

            // Hide the single album display
            document.getElementById('randomAlbumDisplay').style.display = 'none';
            
            // Show the list display
            const listDisplay = document.getElementById('randomListDisplay');
            listDisplay.style.display = 'block';
            
            // Create the list HTML
            listDisplay.innerHTML = `
                <div style="text-align: center; margin: 30px 0;">
                    <div id="albumListCanvas" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; border-radius: 20px; max-width: 600px; margin: 0 auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                        <h2 style="color: white; margin-bottom: 30px; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">üéµ My Next 10 Albums</h2>
                        <div style="background: rgba(255,255,255,0.95); padding: 30px; border-radius: 15px; text-align: left;">
                            ${randomAlbums.map((album, index) => `
                                <div style="margin-bottom: 20px; padding-bottom: 20px; ${index < randomAlbums.length - 1 ? 'border-bottom: 2px solid #e0e0e0;' : ''}">
                                    <div style="font-size: 1.3em; font-weight: bold; color: #667eea; margin-bottom: 5px;">
                                        ${index + 1}. ${album.albumName}
                                    </div>
                                    <div style="font-size: 1.1em; color: #555; padding-left: 20px;">
                                        ${album.artist}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="margin-top: 20px; color: white; font-size: 0.9em; opacity: 0.8;">
                            Generated ${new Date().toLocaleDateString()}
                        </div>
                    </div>
                    <button class="btn btn-success" onclick="downloadListAsImage()" style="margin-top: 20px; font-size: 1.2em; padding: 15px 40px;">
                        üì• Download as Image
                    </button>
                    <button class="btn btn-secondary" onclick="backToRandomAlbum()" style="margin-top: 20px; margin-left: 10px; font-size: 1.2em; padding: 15px 40px;">
                        ‚Üê Back
                    </button>
                </div>
            `;
        }

        function backToRandomAlbum() {
            document.getElementById('randomListDisplay').style.display = 'none';
            document.getElementById('randomAlbumDisplay').style.display = 'block';
        }

        async function downloadListAsImage() {
            try {
                const element = document.getElementById('albumListCanvas');
                
                if (!element) {
                    showAlert('error', 'List element not found!');
                    return;
                }

                // Show loading message
                showAlert('info', 'Generating image... Please wait.');

                // Use modern approach with dom-to-image-more library (more reliable)
                // Or fallback to manual canvas approach
                await downloadUsingCanvas(element);
                
            } catch (err) {
                console.error('Error generating image:', err);
                showAlert('error', 'Failed to generate image. Please try again.');
            }
        }

        async function downloadUsingCanvas(element) {
            // Create a canvas manually for better browser compatibility
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Get element dimensions
            const rect = element.getBoundingClientRect();
            const scale = 2; // High resolution
            
            canvas.width = rect.width * scale;
            canvas.height = rect.height * scale;
            
            // Scale context for high resolution
            ctx.scale(scale, scale);
            
            // Draw gradient background
            const gradient = ctx.createLinearGradient(0, 0, rect.width, rect.height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            // Get all the text content
            const albums = db.getAllAlbums();
            const shuffled = [...albums].sort(() => 0.5 - Math.random());
            const randomAlbums = shuffled.slice(0, Math.min(10, albums.length));
            
            // Draw title
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillText('üéµ My Next 10 Albums', rect.width / 2, 60);
            ctx.shadowColor = 'transparent';
            
            // Draw white content box
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.fillRect(40, 100, rect.width - 80, rect.height - 180);
            
            // Draw albums
            let yPos = 140;
            ctx.textAlign = 'left';
            
            randomAlbums.forEach((album, index) => {
                // Album name
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 20px Arial, sans-serif';
                ctx.fillText(`${index + 1}. ${album.albumName}`, 70, yPos);
                
                // Artist name
                ctx.fillStyle = '#555';
                ctx.font = '18px Arial, sans-serif';
                ctx.fillText(album.artist, 90, yPos + 25);
                
                // Divider line (except for last item)
                if (index < randomAlbums.length - 1) {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(70, yPos + 40);
                    ctx.lineTo(rect.width - 70, yPos + 40);
                    ctx.stroke();
                }
                
                yPos += 60;
            });
            
            // Draw date
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial, sans-serif';
            ctx.textAlign = 'center';
            const dateStr = new Date().toLocaleDateString();
            ctx.fillText(`Generated ${dateStr}`, rect.width / 2, rect.height - 30);
            
            // Convert canvas to blob and download
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `album-list-${new Date().toISOString().split('T')[0]}.png`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                showAlert('success', 'List downloaded successfully!');
            }, 'image/png');
        }

        // Browse Section
        function loadBrowseSection() {
            // Populate filter dropdowns
            const genres = db.getAllGenres();
            const sources = db.getAllSources();

            const genreSelect = document.getElementById('filterGenre');
            genreSelect.innerHTML = '<option value="">All Genres</option>';
            genres.forEach(genre => {
                genreSelect.innerHTML += `<option value="${genre}">${genre}</option>`;
            });

            const sourceSelect = document.getElementById('filterSource');
            sourceSelect.innerHTML = '<option value="">All Sources</option>';
            sources.forEach(source => {
                sourceSelect.innerHTML += `<option value="${source}">${source}</option>`;
            });

            applyFilters();
            setupSearch();
        }

        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            if (!searchInput || !searchResults) {
                console.error('Search elements not found:', { searchInput, searchResults });
                return;
            }
            
            console.log('Search setup complete');

            let searchTimeout;

            // Handle input with debouncing
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();

                if (query.length === 0) {
                    searchResults.classList.remove('active');
                    searchResults.innerHTML = '';
                    return;
                }

                // Debounce search by 300ms
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 300);
            });

            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.classList.remove('active');
                }
            });

            // Show results when focusing on input with text
            searchInput.addEventListener('focus', (e) => {
                if (e.target.value.trim().length > 0) {
                    performSearch(e.target.value.trim());
                }
            });
        }

        function performSearch(query) {
            console.log('Performing search for:', query);
            const searchResults = document.getElementById('searchResults');
            const allAlbums = db.getAllAlbums();
            console.log('Total albums:', allAlbums.length);
            if (allAlbums.length > 0) {
                console.log('Sample album:', allAlbums[0]);
                console.log('albumName type:', typeof allAlbums[0].albumName);
                console.log('albumName value:', allAlbums[0].albumName);
            }
            
            // Search in album name and artist name (case insensitive)
            const lowerQuery = query.toLowerCase();
            const matches = allAlbums.filter(album => {
                const albumName = String(album.albumName || '').toLowerCase();
                const artistName = String(album.artist || '').toLowerCase();
                return albumName.includes(lowerQuery) || artistName.includes(lowerQuery);
            });
            console.log('Matches found:', matches.length);

            // Sort matches by relevance (exact matches first, then starts with, then contains)
            matches.sort((a, b) => {
                const aAlbum = String(a.albumName || '').toLowerCase();
                const bAlbum = String(b.albumName || '').toLowerCase();
                const aArtist = String(a.artist || '').toLowerCase();
                const bArtist = String(b.artist || '').toLowerCase();

                // Exact match
                if (aAlbum === lowerQuery || aArtist === lowerQuery) return -1;
                if (bAlbum === lowerQuery || bArtist === lowerQuery) return 1;

                // Starts with
                if (aAlbum.startsWith(lowerQuery) || aArtist.startsWith(lowerQuery)) return -1;
                if (bAlbum.startsWith(lowerQuery) || bArtist.startsWith(lowerQuery)) return 1;

                return 0;
            });

            // Limit to 10 results
            const limitedMatches = matches.slice(0, 10);

            if (limitedMatches.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No albums found</div>';
            } else {
                searchResults.innerHTML = limitedMatches.map(album => `
                    <div class="search-result-item" onclick="openAlbumFromSearch(${album.id})">
                        ${album.artworkUrl ? 
                            `<img src="${album.artworkUrl}" alt="${album.albumName}" class="search-result-artwork" onerror="this.style.display='none'">` :
                            '<div class="search-result-artwork"></div>'
                        }
                        <div class="search-result-info">
                            <div class="search-result-album">${album.albumName}</div>
                            <div class="search-result-artist">${album.artist}</div>
                        </div>
                    </div>
                `).join('');
            }

            searchResults.classList.add('active');
        }

        function openAlbumFromSearch(albumId) {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            // Clear search
            searchInput.value = '';
            searchResults.classList.remove('active');
            searchResults.innerHTML = '';
            
            // Open album modal
            showAlbumDetail(albumId);
        }

        function applyFilters() {
            const genreEl = document.getElementById('filterGenre');
            const sourceEl = document.getElementById('filterSource');
            const statusEl = document.getElementById('filterStatus');
            const sortByEl = document.getElementById('sortBy');

            // Check if elements exist
            if (!genreEl || !sourceEl || !statusEl || !sortByEl) {
                console.error('Filter elements not found');
                return;
            }

            const filters = {
                genre: genreEl.value,
                source: sourceEl.value,
                status: statusEl.value
            };

            const sortBy = sortByEl.value;

            let albums = db.filterAlbums(filters);
            albums = db.sortAlbums(albums, sortBy);

            displayAlbums(albums);
        }

        function clearFilters() {
            document.getElementById('filterGenre').value = '';
            document.getElementById('filterSource').value = '';
            document.getElementById('filterStatus').value = '';
            document.getElementById('sortBy').value = 'name-asc';
            applyFilters();
        }

        // Infinite scroll state
        let allFilteredAlbums = [];
        let displayedAlbumsCount = 0;
        const ALBUMS_PER_BATCH = 500;
        let isLoadingMore = false;
        let multiSelectMode = false;
        let selectedAlbumIds = new Set();

        function displayAlbums(albums) {
            const grid = document.getElementById('albumGrid');

            // Store all albums and reset display count
            allFilteredAlbums = albums;
            displayedAlbumsCount = 0;

            if (albums.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <h3>No albums found</h3>
                        <p>Try adjusting your filters or add some albums to get started.</p>
                    </div>
                `;
                return;
            }

            // Clear existing content
            grid.innerHTML = '';

            // Load first batch
            loadMoreAlbums();

            // Setup infinite scroll
            setupInfiniteScroll();
        }

        function loadMoreAlbums() {
            if (isLoadingMore) return;
            
            const grid = document.getElementById('albumGrid');
            if (!grid) return;

            isLoadingMore = true;

            // Get next batch
            const nextBatch = allFilteredAlbums.slice(
                displayedAlbumsCount, 
                displayedAlbumsCount + ALBUMS_PER_BATCH
            );

            if (nextBatch.length === 0) {
                isLoadingMore = false;
                return;
            }

            // Create document fragment for better performance
            const fragment = document.createDocumentFragment();

            nextBatch.forEach(album => {
                const scoreClass = album.score >= 8 ? 'score-high' : 
                                 album.score >= 5 ? 'score-medium' : 
                                 album.score ? 'score-low' : 'score-unrated';
                const scoreText = album.score !== null && album.score !== undefined && album.score !== '' 
                    ? `${album.score}/10` 
                    : 'Not Rated';

                const albumCard = document.createElement('div');
                albumCard.className = 'album-card';
                albumCard.dataset.albumId = album.id;
                
                if (multiSelectMode) {
                    albumCard.classList.add('multi-select-mode');
                    if (selectedAlbumIds.has(album.id)) {
                        albumCard.classList.add('selected');
                    }
                    albumCard.onclick = (e) => {
                        e.stopPropagation();
                        toggleAlbumSelection(album.id);
                    };
                } else {
                    albumCard.onclick = () => showAlbumDetail(album.id);
                }
                
                albumCard.innerHTML = `
                    ${multiSelectMode ? `<input type="checkbox" class="album-checkbox" ${selectedAlbumIds.has(album.id) ? 'checked' : ''} onclick="event.stopPropagation(); toggleAlbumSelection(${album.id})">` : ''}
                    <img src="${album.artworkUrl}" alt="${album.albumName}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    <div class="album-card-info">
                        <h3>${album.albumName}</h3>
                        <p>${album.artist}</p>
                        <p>${album.year}</p>
                        <span class="score-badge ${scoreClass}">${scoreText}</span>
                    </div>
                `;
                
                fragment.appendChild(albumCard);
            });

            grid.appendChild(fragment);
            displayedAlbumsCount += nextBatch.length;

            // Add loading indicator if there are more albums
            if (displayedAlbumsCount < allFilteredAlbums.length) {
                let loadingIndicator = document.getElementById('loadingIndicator');
                if (!loadingIndicator) {
                    loadingIndicator = document.createElement('div');
                    loadingIndicator.id = 'loadingIndicator';
                    loadingIndicator.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;';
                    loadingIndicator.innerHTML = '<p>Loading more albums...</p>';
                }
                if (!grid.contains(loadingIndicator)) {
                    grid.appendChild(loadingIndicator);
                }
            } else {
                // Remove loading indicator if we're done
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
            }

            isLoadingMore = false;
        }

        function setupInfiniteScroll() {
            // Remove existing scroll listener if any
            if (window.infiniteScrollHandler) {
                window.removeEventListener('scroll', window.infiniteScrollHandler);
            }

            // Create new scroll handler
            window.infiniteScrollHandler = () => {
                if (displayedAlbumsCount >= allFilteredAlbums.length) return;
                if (isLoadingMore) return;

                const scrollPosition = window.innerHeight + window.scrollY;
                const threshold = document.documentElement.scrollHeight - 1000; // Load 1000px before bottom

                if (scrollPosition >= threshold) {
                    loadMoreAlbums();
                }
            };

            window.addEventListener('scroll', window.infiniteScrollHandler);
        }

        function toggleMultiSelectMode() {
            multiSelectMode = !multiSelectMode;
            selectedAlbumIds.clear();
            
            const controlsDiv = document.getElementById('multiSelectControls');
            const modeBtn = document.getElementById('multiSelectModeBtn');
            
            if (multiSelectMode) {
                controlsDiv.style.display = 'block';
                modeBtn.textContent = '‚ùå Exit Multi-Select';
            } else {
                controlsDiv.style.display = 'none';
                modeBtn.textContent = 'üìã Multi-Select';
            }
            
            updateSelectedCount();
            applyFilters(); // Refresh display
        }

        function toggleAlbumSelection(albumId) {
            if (selectedAlbumIds.has(albumId)) {
                selectedAlbumIds.delete(albumId);
            } else {
                selectedAlbumIds.add(albumId);
            }
            
            // Update the card's visual state
            const card = document.querySelector(`[data-album-id="${albumId}"]`);
            if (card) {
                card.classList.toggle('selected');
                const checkbox = card.querySelector('.album-checkbox');
                if (checkbox) {
                    checkbox.checked = selectedAlbumIds.has(albumId);
                }
            }
            
            updateSelectedCount();
        }

        function toggleSelectAll() {
            const allCurrentIds = allFilteredAlbums.map(a => a.id);
            
            if (selectedAlbumIds.size === allCurrentIds.length) {
                // Deselect all
                selectedAlbumIds.clear();
                document.getElementById('selectAllText').textContent = 'Select All';
            } else {
                // Select all filtered albums
                allCurrentIds.forEach(id => selectedAlbumIds.add(id));
                document.getElementById('selectAllText').textContent = 'Deselect All';
            }
            
            updateSelectedCount();
            applyFilters(); // Refresh display
        }

        function updateSelectedCount() {
            const count = selectedAlbumIds.size;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('deleteSelectedBtn').disabled = count === 0;
            
            // Update Select All button text
            const allCurrentIds = allFilteredAlbums.map(a => a.id);
            if (selectedAlbumIds.size === allCurrentIds.length && allCurrentIds.length > 0) {
                document.getElementById('selectAllText').textContent = 'Deselect All';
            } else {
                document.getElementById('selectAllText').textContent = 'Select All';
            }
        }

        function deleteSelectedAlbums() {
            const count = selectedAlbumIds.size;
            if (count === 0) return;
            
            const confirmMsg = `Are you sure you want to delete ${count} album${count > 1 ? 's' : ''}? This action cannot be undone.`;
            
            if (confirm(confirmMsg)) {
                // Delete each selected album
                selectedAlbumIds.forEach(id => {
                    db.deleteAlbum(id);
                });
                
                autoSyncToOneDrive();
                showAlert('success', `Successfully deleted ${count} album${count > 1 ? 's' : ''}!`);
                
                // Clear selection and exit multi-select mode
                selectedAlbumIds.clear();
                multiSelectMode = false;
                document.getElementById('multiSelectControls').style.display = 'none';
                document.getElementById('multiSelectModeBtn').textContent = 'üìã Multi-Select';
                
                // Refresh the display
                applyFilters();
            }
        }

        function showAlbumDetail(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            const genres = db.parseMultiValue(album.genre, true);
            const styles = db.parseMultiValue(album.style);
            const sources = db.parseMultiValue(album.reason);

            const modalContent = document.getElementById('albumModalContent');
            modalContent.innerHTML = `
                <div style="display: grid; grid-template-columns: 300px 1fr; gap: 30px; margin-top: 40px;">
                    <div>
                        <img src="${album.artworkUrl}" alt="${album.albumName}" style="width: 100%; border-radius: 12px;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22300%22%3E%3Crect fill=%22%23ddd%22 width=%22300%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2220%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    </div>
                    <div>
                        <h2 style="margin-bottom: 20px;">${album.albumName}<a href="${getWikipediaLink(album.albumName, 'album', album.artist)}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia" style="color: #667eea;">${getWikiIcon()}</a><a href="${getSpotifyLink(album.albumName, album.artist)}" target="_blank" rel="noopener noreferrer" class="spotify-link" title="Search on Spotify">${getSpotifyIcon()}</a></h2>
                        <p style="margin-bottom: 10px;"><strong>Artist:</strong> ${album.artist}<a href="${getWikipediaLink(album.artist, 'artist')}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia" style="color: #667eea;">${getWikiIcon()}</a></p>
                        <p style="margin-bottom: 10px;"><strong>Year:</strong> ${album.year}</p>
                        ${album.artistId ? `<p style="margin-bottom: 10px;"><strong>Artist ID:</strong> ${album.artistId}</p>` : ''}
                        ${album.discogsUrl ? `<p style="margin-bottom: 10px;"><a href="${album.discogsUrl}" target="_blank" style="color: #667eea; text-decoration: none;">View on Discogs</a></p>` : ''}
                        
                        ${genres.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Genres:</strong>
                                <div class="tags-container">
                                    ${genres.map(g => `<span class="tag">${g}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${styles.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Styles:</strong>
                                <div class="tags-container">
                                    ${styles.map(s => `<span class="tag">${s}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${sources.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Source Lists:</strong>
                                <div class="tags-container">
                                    ${sources.map(s => `<span class="tag">${s}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${album.score !== null && album.score !== undefined && album.score !== '' ? `
                            <p style="margin: 15px 0;"><strong>Score:</strong> <span style="font-size: 1.5em; color: #667eea;">${album.score}/10</span></p>
                        ` : '<p style="margin: 15px 0; color: #6c757d;">Not yet rated</p>'}
                        
                        ${album.dateListened ? `<p style="margin-bottom: 10px;"><strong>Date Listened:</strong> ${new Date(album.dateListened).toLocaleDateString()}</p>` : ''}
                        
                        ${album.notes ? `
                            <div style="margin-top: 20px;">
                                <strong>Notes:</strong>
                                <p style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px;">${album.notes}</p>
                            </div>
                        ` : ''}
                        
                        <div style="margin-top: 30px;">
                            <button class="btn" onclick="editAlbum(${album.id})">Edit Album</button>
                            <button class="btn btn-danger" onclick="deleteAlbumConfirm(${album.id})" style="margin-left: 10px;">Delete</button>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('albumModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('albumModal').classList.remove('active');
        }

        let previousSection = 'browse'; // Track which section we were in before editing

        function editAlbum(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            // Remember which section we're currently in
            const sections = ['browse', 'stats', 'import', 'add'];
            for (const section of sections) {
                if (document.getElementById(section).classList.contains('active')) {
                    previousSection = section;
                    break;
                }
            }

            closeModal();
            showSection('add');
            
            // Populate form
            document.getElementById('albumName').value = album.albumName;
            document.getElementById('artist').value = album.artist;
            document.getElementById('artistId').value = album.artistId || '';
            document.getElementById('year').value = album.year;
            document.getElementById('artworkUrl').value = album.artworkUrl;
            document.getElementById('discogsUrl').value = album.discogsUrl || '';
            document.getElementById('genre').value = album.genre || '';
            document.getElementById('style').value = album.style || '';
            document.getElementById('reason').value = album.reason || '';
            document.getElementById('score').value = album.score || '';
            document.getElementById('dateListened').value = album.dateListened || '';
            document.getElementById('notes').value = album.notes || '';

            // Change form to edit mode
            const form = document.getElementById('addAlbumForm');
            form.onsubmit = (e) => updateAlbum(e, albumId);
            document.querySelector('#add h2').textContent = 'Edit Album';
            form.querySelector('button[type="submit"]').textContent = 'Update Album';
        }

        function updateAlbum(event, albumId) {
            event.preventDefault();

            const updates = {
                albumName: document.getElementById('albumName').value,
                artist: document.getElementById('artist').value,
                artistId: document.getElementById('artistId').value,
                year: parseInt(document.getElementById('year').value),
                artworkUrl: document.getElementById('artworkUrl').value,
                discogsUrl: document.getElementById('discogsUrl').value,
                genre: document.getElementById('genre').value,
                style: document.getElementById('style').value,
                reason: document.getElementById('reason').value || 'Manual',
                score: document.getElementById('score').value ? parseFloat(document.getElementById('score').value) : null,
                dateListened: document.getElementById('dateListened').value || null,
                notes: document.getElementById('notes').value
            };

            db.updateAlbum(albumId, updates);
            autoSyncToOneDrive();
            showAlert('success', 'Album updated successfully!');
            
            // Reset form
            document.getElementById('addAlbumForm').reset();
            document.getElementById('addAlbumForm').onsubmit = addAlbum;
            document.querySelector('#add h2').textContent = 'Add New Album';
            document.querySelector('#add button[type="submit"]').textContent = 'Add Album';
            document.getElementById('reason').value = 'Manual';
            
            // Return to the section we were in before editing
            showSection(previousSection);
            if (previousSection === 'browse') {
                loadBrowseSection();
            }
        }

        function deleteAlbumConfirm(albumId) {
            if (confirm('Are you sure you want to delete this album? This action cannot be undone.')) {
                db.deleteAlbum(albumId);
                autoSyncToOneDrive();
                closeModal();
                showAlert('success', 'Album deleted successfully!');
                if (document.getElementById('browse').classList.contains('active')) {
                    loadBrowseSection();
                }
            }
        }

        // Fetch album data from Discogs
        async function fetchFromDiscogs() {
            const discogsUrlInput = document.getElementById('discogsUrl');
            const statusEl = document.getElementById('discogsStatus');
            const url = discogsUrlInput.value.trim();

            if (!url) {
                statusEl.textContent = 'Please enter a Discogs URL first';
                statusEl.style.color = '#e74c3c';
                return;
            }

            // Extract master or release ID from URL
            const masterMatch = url.match(/discogs\.com\/master\/(\d+)/);
            const releaseMatch = url.match(/discogs\.com\/release\/(\d+)/);
            
            if (!masterMatch && !releaseMatch) {
                statusEl.textContent = 'Invalid Discogs URL format';
                statusEl.style.color = '#e74c3c';
                return;
            }

            const isMaster = !!masterMatch;
            const id = isMaster ? masterMatch[1] : releaseMatch[1];
            const apiUrl = isMaster 
                ? `https://api.discogs.com/masters/${id}`
                : `https://api.discogs.com/releases/${id}`;

            statusEl.textContent = 'Fetching data from Discogs...';
            statusEl.style.color = '#3498db';

            try {
                // Use CORS proxy to avoid CORS issues
                const proxyUrl = 'https://corsproxy.io/?';
                const response = await fetch(proxyUrl + encodeURIComponent(apiUrl));

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                let data = await response.json();
                
                // If it's a master release and images are empty, fetch the main release instead
                if (isMaster && data.main_release_url && (!data.images || !data.images[0]?.uri)) {
                    console.log('Master images empty, fetching main release...');
                    const mainReleaseResponse = await fetch(proxyUrl + encodeURIComponent(data.main_release_url));
                    if (mainReleaseResponse.ok) {
                        data = await mainReleaseResponse.json();
                        console.log('Main release data:', JSON.stringify(data, null, 2));
                    }
                } else {
                    console.log('Full Discogs response:', JSON.stringify(data, null, 2));
                }

                // Populate form fields
                document.getElementById('albumName').value = data.title || '';
                document.getElementById('artist').value = data.artists?.[0]?.name || '';
                document.getElementById('artistId').value = data.artists?.[0]?.id || '';
                document.getElementById('year').value = data.year || '';
                
                // Get the best quality image
                if (data.images && data.images.length > 0) {
                    // Try to get the highest resolution image
                    // Discogs provides: uri, uri150, resource_url
                    const image = data.images[0];
                    const artworkUrl = image.resource_url || image.uri || image.uri150 || '';
                    document.getElementById('artworkUrl').value = artworkUrl;
                    console.log('Image data:', image);
                    console.log('Using artwork URL:', artworkUrl);
                }

                // Join genres with semicolons
                if (data.genres && data.genres.length > 0) {
                    document.getElementById('genre').value = data.genres.join('; ');
                }

                // Join styles with semicolons
                if (data.styles && data.styles.length > 0) {
                    document.getElementById('style').value = data.styles.join('; ');
                }

                statusEl.textContent = '‚úì Successfully fetched album data!';
                statusEl.style.color = '#27ae60';

                // Clear status after 3 seconds
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);

            } catch (error) {
                console.error('Error fetching from Discogs:', error);
                statusEl.textContent = '‚úó Error fetching data. Please check the URL and try again.';
                statusEl.style.color = '#e74c3c';
            }
        }

        // Add Album
        function addAlbum(event) {
            event.preventDefault();

            const album = {
                albumName: document.getElementById('albumName').value,
                artist: document.getElementById('artist').value,
                artistId: document.getElementById('artistId').value,
                year: parseInt(document.getElementById('year').value),
                artworkUrl: document.getElementById('artworkUrl').value,
                discogsUrl: document.getElementById('discogsUrl').value,
                genre: document.getElementById('genre').value,
                style: document.getElementById('style').value,
                reason: document.getElementById('reason').value || 'Manual',
                score: document.getElementById('score').value ? parseFloat(document.getElementById('score').value) : null,
                dateListened: document.getElementById('dateListened').value || null,
                notes: document.getElementById('notes').value
            };

            if (db.isDuplicate(album.albumName, album.artist)) {
                showAlert('error', 'This album already exists in your collection!');
                return;
            }

            db.addAlbum(album);
            autoSyncToOneDrive();
            showAlert('success', 'Album added successfully!');
            document.getElementById('addAlbumForm').reset();
            document.getElementById('reason').value = 'Manual';
            
            // Return to Browse Albums section
            showSection('browse');
        }

        // Import Excel
        async function importExcel(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show loading indicator
            document.getElementById('importStatus').innerHTML = `
                <div class="alert alert-info" style="margin-top: 20px;">
                    <strong>Processing...</strong><br>
                    Reading file and preparing data...
                </div>
            `;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-info" style="margin-top: 20px;">
                            <strong>Processing...</strong><br>
                            Importing ${jsonData.length} albums...
                        </div>
                    `;

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const albums = jsonData.map(row => {
                        // Helper to get value, allowing falsy values like 0 but not null/undefined
                        const getValue = (primary, secondary, defaultVal = '') => {
                            const val = primary !== undefined && primary !== null ? primary : secondary;
                            return val !== undefined && val !== null ? val : defaultVal;
                        };

                        // Helper to parse Excel date (which can be a serial number or string)
                        const parseExcelDate = (dateValue) => {
                            if (!dateValue) return null;
                            
                            // If it's already a string in YYYY-MM-DD format, return it
                            if (typeof dateValue === 'string' && dateValue.match(/^\d{4}-\d{2}-\d{2}$/)) {
                                return dateValue;
                            }
                            
                            // If it's a string in other formats, try to parse it
                            if (typeof dateValue === 'string') {
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    return parsed.toISOString().split('T')[0];
                                }
                            }
                            
                            // If it's an Excel serial number (number of days since 1900-01-01)
                            if (typeof dateValue === 'number') {
                                // Excel date serial number conversion
                                const excelEpoch = new Date(1899, 11, 30); // Excel's epoch (Dec 30, 1899)
                                const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                                return date.toISOString().split('T')[0];
                            }
                            
                            return null;
                        };

                        return {
                            albumName: getValue(row['Album Name'], getValue(row['Album'], row['albumName'], ''), ''),
                            artist: getValue(row['Artist'], row['artist'], ''),
                            artistId: getValue(row['Artist ID'], row['artistId'], ''),
                            year: parseInt(row['Year'] || row['year']) || new Date().getFullYear(),
                            artworkUrl: getValue(row['Album Artwork URL'], getValue(row['Album Artwork'], row['artworkUrl'], ''), ''),
                            discogsUrl: getValue(row['Discogs URL'], getValue(row['Discogs'], row['discogsUrl'], ''), ''),
                            genre: getValue(row['Genre'], row['genre'], ''),
                            style: getValue(row['Style'], row['style'], ''),
                            reason: getValue(row['Reason'], row['reason'], 'Manual'),
                            score: row['Score'] || row['score'] ? parseFloat(row['Score'] || row['score']) : null,
                            dateListened: parseExcelDate(row['Date Listened'] || row['Listened on'] || row['dateListened']),
                            notes: getValue(row['Notes'], row['notes'], '')
                        };
                    });

                    const result = await db.importAlbumsAsync(albums, (progress) => {
                        document.getElementById('importStatus').innerHTML = `
                            <div class="alert alert-info" style="margin-top: 20px;">
                                <strong>Processing...</strong><br>
                                Progress: ${progress.processed} / ${progress.total} albums<br>
                                Added: ${progress.added}, Updated: ${progress.updated}, Skipped: ${progress.skipped}
                            </div>
                        `;
                    });
                    
                    autoSyncToOneDrive();
                    
                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-success" style="margin-top: 20px;">
                            <strong>Import Complete!</strong><br>
                            Added: ${result.added} albums<br>
                            Updated: ${result.updated} albums<br>
                            Skipped (no changes): ${result.skipped} albums
                        </div>
                    `;

                    // Reset file input
                    event.target.value = '';

                } catch (error) {
                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-error" style="margin-top: 20px;">
                            <strong>Import Failed!</strong><br>
                            ${error.message}
                        </div>
                    `;
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Export Data
        function exportData() {
            const albums = db.getAllAlbums();
            
            if (albums.length === 0) {
                showAlert('error', 'No albums to export!');
                return;
            }

            // Prepare data for export
            const exportData = albums.map(album => ({
                'ID': album.id,
                'Album Name': album.albumName,
                'Artist': album.artist,
                'Artist ID': album.artistId || '',
                'Year': album.year,
                'Album Artwork URL': album.artworkUrl,
                'Discogs URL': album.discogsUrl || '',
                'Genre': album.genre || '',
                'Style': album.style || '',
                'Reason': album.reason || '',
                'Score': album.score !== null && album.score !== undefined && album.score !== '' ? album.score : '',
                'Date Listened': album.dateListened || '',
                'Notes': album.notes || ''
            }));

            // Create worksheet
            const ws = XLSX.utils.json_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Albums');

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `album-tracker-${timestamp}.xlsx`;

            // Download
            XLSX.writeFile(wb, filename);
            showAlert('success', 'Data exported successfully!');
        }

        // Statistics
        function loadStatsSection() {
            const statsContent = document.getElementById('statsContent');
            
            const albums = db.getAllAlbums();
            if (albums.length === 0) {
                statsContent.innerHTML = `
                    <div class="empty-state">
                        <h3>No data available</h3>
                        <p>Add some albums to see statistics.</p>
                    </div>
                `;
                return;
            }

            const monthlyStats = db.getMonthlyStats();
            const artistAvg = db.getAverageScoreByArtist();
            const genreAvg = db.getAverageScoreByGenre();
            const genreCounts = db.getGenreCounts();
            const sourceStats = db.getSourceListStats();

            let html = '<div class="stats-grid">';

            // Overall Stats
            const totalAlbums = albums.length;
            const listenedAlbums = albums.filter(a => a.dateListened).length;
            const ratedAlbums = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '').length;
            const listenedPercentage = totalAlbums > 0 ? ((listenedAlbums / totalAlbums) * 100).toFixed(1) : '0';
            const avgScore = ratedAlbums > 0 
                ? (albums.filter(a => a.score).reduce((sum, a) => sum + parseFloat(a.score), 0) / ratedAlbums).toFixed(2)
                : 'N/A';

            html += `
                <div class="stat-card">
                    <h3>üìä Overall Statistics</h3>
                    <div class="stat-item">
                        <span>Total Albums</span>
                        <strong>${totalAlbums}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Albums Listened</span>
                        <strong>${listenedAlbums} (${listenedPercentage}%)</strong>
                    </div>
                    <div class="stat-item">
                        <span>Albums Rated</span>
                        <strong>${ratedAlbums}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Average Score</span>
                        <strong>${avgScore}</strong>
                    </div>
                </div>
            `;

            // Monthly Listening Stats
            const currentYear = new Date().getFullYear().toString();
            const availableYears = [...new Set(Object.keys(monthlyStats).map(m => m.split('-')[0]).filter(y => y))].sort().reverse();
            const selectedYear = window.monthlyStatsYear || (availableYears.includes(currentYear) ? currentYear : (availableYears.length > 0 ? availableYears[0] : currentYear));
            
            html += `
                <div class="stat-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">üìÖ Monthly Listening</h3>
                        ${availableYears.length > 0 ? `
                            <select id="monthlyYearSelector" onchange="filterMonthlyStatsByYear(this.value)" style="padding: 5px 10px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer;">
                                ${availableYears.map(year => `<option value="${year}" ${year === selectedYear ? 'selected' : ''}>${year}</option>`).join('')}
                            </select>
                        ` : ''}
                    </div>
                    ${Object.keys(monthlyStats).length > 0 ? 
                        Object.entries(monthlyStats)
                            .filter(([month]) => month.startsWith(selectedYear))
                            .sort((a, b) => b[0].localeCompare(a[0]))
                            .map(([month, data]) => {
                                const [year, monthNum] = month.split('-');
                                const date = new Date(year, parseInt(monthNum) - 1);
                                const displayMonth = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                const avgScore = data.scores.length > 0 
                                    ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2)
                                    : 'N/A';
                                return `
                                    <div class="stat-item" style="cursor: pointer;" onclick="showMonthDrilldown('${month}')">
                                        <span>${displayMonth}</span>
                                        <strong>${data.count} albums (Avg: ${avgScore})</strong>
                                    </div>
                                `;
                            }).join('')
                        : '<p style="color: #6c757d;">No listening data yet</p>'
                    }
                </div>
            `;
            
            // Yearly Stats
            const yearlyStats = db.getYearlyStats();
            if (Object.keys(yearlyStats).length > 0) {
                html += `
                    <div class="stat-card">
                        <h3>üìÜ Yearly Listening</h3>
                        ${Object.entries(yearlyStats)
                            .sort((a, b) => b[0].localeCompare(a[0]))
                            .map(([year, data]) => {
                                const avgScore = data.scores.length > 0 
                                    ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2)
                                    : 'N/A';
                                return `
                                    <div class="stat-item" style="cursor: pointer;" onclick="showYearDrilldown('${year}')">
                                        <span>${year}</span>
                                        <strong>${data.count} albums (Avg: ${avgScore})</strong>
                                    </div>
                                `;
                            }).join('')
                        }
                    </div>
                `;
            }

            html += '</div>';

            // Top Artists by Average Score
            if (Object.keys(artistAvg).length > 0) {
                html += `
                    <div class="chart">
                        <h3>üé§ Top Artists by Average Score</h3>
                        ${Object.entries(artistAvg).slice(0, 10).map(([artist, data]) => `
                            <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px;" onclick="showArtistDrilldown('${artist.replace(/'/g, "\\'")}')">
                                <div style="min-width: 150px; max-width: 150px; padding-right: 10px; color: #333; font-weight: 600; font-size: 13px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${artist}">${artist}</div>
                                <div style="flex: 1; display: flex; align-items: center;">
                                    <div class="chart-bar-fill" style="width: ${(data.average / 10) * 100}%; background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%); color: white; padding: 8px 12px; border-radius: 4px; font-weight: 600; min-width: 100px;">
                                        ${data.average.toFixed(2)} (${data.count} album${data.count !== 1 ? 's' : ''})
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Top Genres by Album Count
            if (Object.keys(genreCounts).length > 0) {
                const maxCount = Math.max(...Object.values(genreCounts));
                html += `
                    <div class="chart">
                        <h3>üé∏ Top Genres by Album Count</h3>
                        ${Object.entries(genreCounts).slice(0, 15).map(([genre, count]) => `
                            <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px;" onclick="showGenreDrilldown('${genre.replace(/'/g, "\\'")}')">
                                <div style="min-width: 150px; max-width: 150px; padding-right: 10px; color: #333; font-weight: 600; font-size: 13px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${genre}">${genre}</div>
                                <div style="flex: 1; display: flex; align-items: center; position: relative;">
                                    <div class="chart-bar-fill" style="width: ${(count / maxCount) * 100}%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); padding: 8px 12px; border-radius: 4px; min-height: 32px; min-width: 80px;"></div>
                                    <div style="position: absolute; left: ${(count / maxCount) * 100 < 20 ? ((count / maxCount) * 100) + 2 : 12}%; color: ${(count / maxCount) * 100 < 20 ? '#333' : 'white'}; font-weight: 600; font-size: 14px; white-space: nowrap;">
                                        ${count} album${count !== 1 ? 's' : ''}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Top Genres by Average Score
            if (Object.keys(genreAvg).length > 0) {
                html += `
                    <div class="chart">
                        <h3>üé∏ Top Genres by Average Score</h3>
                        ${Object.entries(genreAvg).slice(0, 10).map(([genre, score]) => `
                            <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px;" onclick="showGenreDrilldown('${genre.replace(/'/g, "\\'")}')">
                                <div style="min-width: 150px; max-width: 150px; padding-right: 10px; color: #333; font-weight: 600; font-size: 13px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${genre}">${genre}</div>
                                <div style="flex: 1; display: flex; align-items: center; position: relative;">
                                    <div class="chart-bar-fill" style="width: ${(score / 10) * 100}%; background: linear-gradient(90deg, #28a745 0%, #20c997 100%); padding: 8px 12px; border-radius: 4px; min-height: 32px;"></div>
                                    <div style="position: absolute; left: 12px; color: #333; font-weight: 600; font-size: 14px; text-shadow: 1px 1px 2px rgba(255,255,255,0.8);">
                                        ${score.toFixed(2)}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Highest and Lowest Scoring Albums (Side by Side with Filter)
            // Get available months and years for dropdowns
            const allMonths = [...new Set(albums.filter(a => a.dateListened).map(a => a.dateListened.substring(0, 7)))].sort().reverse();
            const allYears = [...new Set(albums.filter(a => a.dateListened).map(a => a.dateListened.substring(0, 4)))].sort().reverse();
            
            html += `
                <div style="margin-top: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; gap: 10px;">
                        <h3 style="margin: 0;">üèÜ Top & Bottom Albums</h3>
                        <select id="scoreFilterSelect" onchange="updateScoreFilter()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 14px;">
                            <option value="all-time">All Time</option>
                            <option value="this-month">This Month</option>
                            <option value="previous-month">Previous Month</option>
                            <option value="last-year">Last Year</option>
                            <optgroup label="Select Month">
                                ${allMonths.map(m => {
                                    const date = new Date(m + '-01');
                                    const label = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                    return `<option value="month:${m}">${label}</option>`;
                                }).join('')}
                            </optgroup>
                            <optgroup label="Select Year">
                                ${allYears.map(y => `<option value="year:${y}">${y}</option>`).join('')}
                            </optgroup>
                        </select>
                    </div>
                    <div id="scoreFilteredAlbums" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <!-- Will be populated by updateScoreFilter() -->
                    </div>
                </div>
            `;

            // Source List Statistics (Moved to bottom)
            if (Object.keys(sourceStats).length > 0) {
                html += `
                    <div class="chart" style="margin-top: 30px;">
                        <h3>üìö Source List Statistics</h3>
                        <div class="stats-grid">
                            ${Object.entries(sourceStats).map(([source, stats]) => `
                                <div class="stat-card" style="cursor: pointer;" onclick="showSourceDrilldown('${source.replace(/'/g, "\\'")}')">
                                    <h4 style="font-size: 1em; margin-bottom: 10px;">${source}</h4>
                                    <div class="stat-item">
                                        <span>Total Albums</span>
                                        <strong>${stats.total}</strong>
                                    </div>
                                    <div class="stat-item">
                                        <span>Listened</span>
                                        <strong>${stats.listened}</strong>
                                    </div>
                                    <div class="stat-item">
                                        <span>Average Score</span>
                                        <strong>${stats.avgScore ? stats.avgScore.toFixed(2) : 'N/A'}</strong>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            statsContent.innerHTML = html;
            
            // Initialize score filter
            updateScoreFilter();
        }

        // Update score filter for highest/lowest albums
        function updateScoreFilter() {
            const filterValue = document.getElementById('scoreFilterSelect')?.value || 'all-time';
            const albums = db.getAllAlbums();
            let filteredAlbums = albums;

            // Apply date filter
            const now = new Date();
            if (filterValue === 'this-month') {
                const thisMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(thisMonth));
            } else if (filterValue === 'previous-month') {
                const prevDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const prevMonth = `${prevDate.getFullYear()}-${String(prevDate.getMonth() + 1).padStart(2, '0')}`;
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(prevMonth));
            } else if (filterValue === 'last-year') {
                const lastYear = (now.getFullYear() - 1).toString();
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(lastYear));
            } else if (filterValue.startsWith('month:')) {
                const month = filterValue.substring(6);
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(month));
            } else if (filterValue.startsWith('year:')) {
                const year = filterValue.substring(5);
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(year));
            }

            const highScoring = filteredAlbums
                .filter(a => a.score >= 8)
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);

            const lowScoring = filteredAlbums
                .filter(a => a.score && a.score <= 4)
                .sort((a, b) => a.score - b.score)
                .slice(0, 10);

            const container = document.getElementById('scoreFilteredAlbums');
            if (!container) return;

            container.innerHTML = `
                <div class="chart" style="margin: 0;">
                    <h4 style="color: #28a745;">‚≠ê Highest Scoring Albums (‚â•8)</h4>
                    ${highScoring.length > 0 ? highScoring.map(album => `
                        <div class="stat-item" style="cursor: pointer;" onclick="showAlbumDetail(${album.id})">
                            <span>${album.albumName} - ${album.artist}</span>
                            <strong style="color: #28a745;">${album.score}/10</strong>
                        </div>
                    `).join('') : '<p style="color: #999; padding: 20px; text-align: center;">No albums found</p>'}
                </div>
                <div class="chart" style="margin: 0;">
                    <h4 style="color: #dc3545;">üìâ Lowest Scoring Albums (‚â§4)</h4>
                    ${lowScoring.length > 0 ? lowScoring.map(album => `
                        <div class="stat-item" style="cursor: pointer;" onclick="showAlbumDetail(${album.id})">
                            <span>${album.albumName} - ${album.artist}</span>
                            <strong style="color: #dc3545;">${album.score}/10</strong>
                        </div>
                    `).join('') : '<p style="color: #999; padding: 20px; text-align: center;">No albums found</p>'}
                </div>
            `;
        }

        // Drilldown functions
        function showArtistDrilldown(artist) {
            const albums = db.getAllAlbums().filter(a => a.artist === artist);
            showDrilldownModal(`Albums by ${artist}`, albums);
        }

        function showGenreDrilldown(genre) {
            const albums = db.getAllAlbums().filter(a => {
                const genres = db.parseMultiValue(a.genre, true);
                return genres.includes(genre);
            });
            showDrilldownModal(`Albums in ${genre}`, albums);
        }

        function showSourceDrilldown(source) {
            const albums = db.getAllAlbums().filter(a => {
                const sources = db.parseMultiValue(a.reason);
                return sources.includes(source);
            });
            showDrilldownModal(`Albums from ${source}`, albums);
        }

        function filterMonthlyStatsByYear(year) {
            window.monthlyStatsYear = year;
            loadStatsSection();
        }

        function showMonthDrilldown(month) {
            const albums = db.getAllAlbums().filter(a => {
                if (!a.dateListened) return false;
                const date = new Date(a.dateListened);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                return key === month;
            });
            showDrilldownModal(`Albums listened in ${month}`, albums);
        }

        function showYearDrilldown(year) {
            const albums = db.getAllAlbums().filter(a => {
                if (!a.dateListened) return false;
                const date = new Date(a.dateListened);
                return String(date.getFullYear()) === year;
            });
            showDrilldownModal(`Albums listened in ${year}`, albums);
        }

        function showDrilldownModal(title, albums) {
            const modalContent = document.getElementById('albumModalContent');
            
            // Store albums for re-sorting
            window.drilldownAlbums = albums;
            window.drilldownTitle = title;
            
            // Default sort by score
            renderDrilldownAlbums('score');
        }

        function renderDrilldownAlbums(sortBy) {
            const modalContent = document.getElementById('albumModalContent');
            const albums = [...window.drilldownAlbums]; // Clone array
            const title = window.drilldownTitle;
            
            // Sort albums based on selection
            if (sortBy === 'score') {
                albums.sort((a, b) => {
                    if (a.score && b.score) return b.score - a.score;
                    if (a.score) return -1;
                    if (b.score) return 1;
                    return String(a.albumName).localeCompare(String(b.albumName));
                });
            } else if (sortBy === 'date') {
                albums.sort((a, b) => {
                    if (!a.dateListened && !b.dateListened) return 0;
                    if (!a.dateListened) return 1;
                    if (!b.dateListened) return -1;
                    return new Date(b.dateListened) - new Date(a.dateListened);
                });
            }

            modalContent.innerHTML = `
                <div style="margin-top: 40px;">
                    <h2 style="margin-bottom: 20px;">${title}</h2>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <p style="color: #6c757d;">Total: ${albums.length} albums</p>
                        <div>
                            <label style="font-size: 0.9em; color: #666; margin-right: 8px;">Sort by:</label>
                            <select id="drilldownSort" onchange="renderDrilldownAlbums(this.value)" style="padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer;">
                                <option value="score" ${sortBy === 'score' ? 'selected' : ''}>Score (Highest First)</option>
                                <option value="date" ${sortBy === 'date' ? 'selected' : ''}>Date Listened (Newest First)</option>
                            </select>
                        </div>
                    </div>
                    <div class="album-grid">
                        ${albums.map(album => `
                            <div class="album-card" onclick="showAlbumDetail(${album.id})">
                                <img src="${album.artworkUrl}" alt="${album.albumName}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                                <div class="album-card-info">
                                    <h3>${album.albumName}</h3>
                                    <p>${album.artist}</p>
                                    <p>${album.year}</p>
                                    ${album.score !== null && album.score !== undefined && album.score !== '' ? 
                                        `<span class="score-badge ${
                                            album.score >= 8 ? 'score-high' : 
                                            album.score >= 6 ? 'score-medium' : 
                                            album.score >= 4 ? 'score-low' : 'score-low'
                                        }">${album.score}/10</span>` : 
                                        '<span class="score-badge score-unrated">Not Rated</span>'
                                    }
                                    ${album.dateListened ? `<p style="font-size: 0.8em; margin-top: 5px;">Listened: ${new Date(album.dateListened).toLocaleDateString()}</p>` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            document.getElementById('albumModal').classList.add('active');
        }

        // Sync Menu Toggle
        function toggleSyncMenu() {
            const menu = document.getElementById('syncMenu');
            menu.classList.toggle('active');
        }

        // Close sync menu when clicking outside
        document.addEventListener('click', function(e) {
            const syncStatus = document.getElementById('syncStatus');
            const syncMenu = document.getElementById('syncMenu');
            
            if (syncStatus && syncMenu && 
                !syncStatus.contains(e.target) && 
                !syncMenu.contains(e.target)) {
                syncMenu.classList.remove('active');
            }
        });

        // Auto-sync to OneDrive after data changes
        function autoSyncToOneDrive() {
            if (syncManager && syncManager.isConnected()) {
                // Debounce sync to avoid too many requests
                clearTimeout(window.autoSyncTimeout);
                window.autoSyncTimeout = setTimeout(() => {
                    syncManager.syncToOneDrive().catch(err => {
                        console.error('Auto-sync failed:', err);
                    });
                }, 2000); // Wait 2 seconds after last change
            }
        }

        // Alert System
        function showAlert(type, message) {
            const alertClass = type === 'success' ? 'alert-success' : 
                             type === 'error' ? 'alert-error' : 'alert-info';
            
            const alert = document.createElement('div');
            alert.className = `alert ${alertClass}`;
            alert.textContent = message;
            alert.style.position = 'fixed';
            alert.style.top = '20px';
            alert.style.right = '20px';
            alert.style.zIndex = '10000';
            alert.style.minWidth = '300px';
            alert.style.animation = 'slideIn 0.3s';

            document.body.appendChild(alert);

            setTimeout(() => {
                alert.style.animation = 'slideOut 0.3s';
                setTimeout(() => alert.remove(), 300);
            }, 3000);
        }

        // Initialize
        // Auto-sync on activity
        let autoSyncTimeout = null;
        
        function scheduleAutoSync() {
            // Clear any existing timeout
            if (autoSyncTimeout) {
                clearTimeout(autoSyncTimeout);
            }
            
            // Schedule sync for 30 seconds from now
            autoSyncTimeout = setTimeout(() => {
                if (syncManager && syncManager.isConnected()) {
                    console.log('Auto-syncing to OneDrive...');
                    syncManager.syncToOneDrive();
                }
            }, 30000); // 30 seconds
        }
        
        // Trigger auto-sync on any user activity
        function setupAutoSync() {
            const activityEvents = ['click', 'keydown', 'scroll', 'touchstart'];
            
            activityEvents.forEach(eventType => {
                document.addEventListener(eventType, scheduleAutoSync, { passive: true });
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Restore view mode preference
            const savedViewMode = localStorage.getItem('viewMode');
            const viewportMeta = document.getElementById('viewport-meta');
            const toggleBtn = document.getElementById('viewToggleBtn');
            
            if (savedViewMode === 'mobile') {
                viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0');
                toggleBtn.innerHTML = 'üñ•Ô∏è Desktop View';
            } else {
                // Default to desktop view on mobile devices
                viewportMeta.setAttribute('content', 'width=1400, user-scalable=yes');
                toggleBtn.innerHTML = 'üì± Mobile View';
            }
            
            // Setup auto-sync
            setupAutoSync();
            
            // Load initial section
            loadBrowseSection();
            
            // Close modal on outside click
            document.getElementById('albumModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeModal();
                }
            });
        });
    </script>

    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</body>
</html>