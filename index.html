<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1400, user-scalable=yes" id="viewport-meta">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:;">
    <title>Album Tracker</title>
    
    <!-- Favicon - Simple Black Record Icon -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><circle cx='50' cy='50' r='48' fill='%23000'/><circle cx='50' cy='50' r='38' fill='%23000' stroke='%23fff' stroke-width='1'/><circle cx='50' cy='50' r='28' fill='%23000' stroke='%23fff' stroke-width='0.5'/><circle cx='50' cy='50' r='18' fill='%23000' stroke='%23fff' stroke-width='0.5'/><circle cx='50' cy='50' r='6' fill='%23fff'/></svg>">
    
    <!-- Chart.js for graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --gradient-start: #667eea;
            --gradient-end: #764ba2;
            --content-bg: #ffffff;
            --card-bg: #ffffff;
            --modal-bg: #ffffff;
            --chart-bg: #ffffff;
            --content-text: #333333;
            --card-text: #333333;
            --modal-text: #333333;
            --chart-text: #333333;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --button-bg: #667eea;
            --button-hover: #764ba2;
        }

        /* Theme color schemes */
        body[data-theme="purple"] {
            --gradient-start: #667eea;
            --gradient-end: #764ba2;
            --header-bg: #667eea;
            --content-bg: #ffffff;
            --card-bg: #f8f9ff;
            --modal-bg: #ffffff;
            --chart-bg: #fafbff;
            --content-text: #333333;
            --card-text: #333333;
            --modal-text: #333333;
            --chart-text: #333333;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --button-bg: #667eea;
            --button-hover: #764ba2;
            --border-color: #667eea;
            --border-hover: #764ba2;
        }

        body[data-theme="ocean"] {
            --gradient-start: #2E3192;
            --gradient-end: #1BFFFF;
            --header-bg: #2E3192;
            --content-bg: #f0f8ff;
            --card-bg: #e6f4ff;
            --modal-bg: #f0f8ff;
            --chart-bg: #f5faff;
            --content-text: #1a3a52;
            --card-text: #1a3a52;
            --modal-text: #1a3a52;
            --chart-text: #1a3a52;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --button-bg: #2E3192;
            --button-hover: #1BFFFF;
            --border-color: #2E3192;
            --border-hover: #1BFFFF;
        }

        body[data-theme="sunset"] {
            --gradient-start: #FF512F;
            --gradient-end: #F09819;
            --header-bg: #FF512F;
            --content-bg: #fff8f0;
            --card-bg: #fff0e6;
            --modal-bg: #fff8f0;
            --chart-bg: #fffaf5;
            --content-text: #8b4513;
            --card-text: #8b4513;
            --modal-text: #8b4513;
            --chart-text: #8b4513;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --button-bg: #FF512F;
            --button-hover: #F09819;
            --border-color: #FF512F;
            --border-hover: #F09819;
        }

        body[data-theme="forest"] {
            --gradient-start: #134E5E;
            --gradient-end: #71B280;
            --header-bg: #134E5E;
            --content-bg: #1a4d3e;
            --card-bg: #164436;
            --modal-bg: #1a4d3e;
            --chart-bg: #0f3a2e;
            --content-text: #f0f8f4;
            --card-text: #e6f4ed;
            --modal-text: #f0f8f4;
            --chart-text: #f5faf8;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --button-bg: #134E5E;
            --button-text: #ffffff;
            --button-hover: #71B280;
            --button-hover-bg: #71B280;
            --button-hover-text: #ffffff;
            --border-color: #134E5E;
            --border-hover: #71B280;
        }

        body[data-theme="rose"] {
            --gradient-start: #C94B4B;
            --gradient-end: #4B134F;
            --header-bg: #C94B4B;
            --content-bg: #fff0f5;
            --card-bg: #ffe6f0;
            --modal-bg: #fff0f5;
            --chart-bg: #fff5f8;
            --content-text: #6b1a3d;
            --card-text: #6b1a3d;
            --modal-text: #6b1a3d;
            --chart-text: #6b1a3d;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --button-bg: #C94B4B;
            --button-hover: #4B134F;
            --border-color: #C94B4B;
            --border-hover: #4B134F;
        }

        body[data-theme="midnight"] {
            --gradient-start: #232526;
            --gradient-end: #414345;
            --header-bg: #232526;
            --content-bg: #2a2a2a;
            --card-bg: #333333;
            --modal-bg: #2a2a2a;
            --chart-bg: #2e2e2e;
            --content-text: #ffffff;
            --card-text: #ffffff;
            --modal-text: #ffffff;
            --chart-text: #ffffff;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --border-color: #414345;
            --border-hover: #667eea;
            --button-bg: #414345;
            --button-hover: #667eea;
        }

        body[data-theme="cherry"] {
            --gradient-start: #EB3349;
            --gradient-end: #F45C43;
            --header-bg: #EB3349;
            --content-bg: #fff5f5;
            --card-bg: #ffebeb;
            --modal-bg: #fff5f5;
            --chart-bg: #fff8f8;
            --content-text: #8b1a1a;
            --card-text: #8b1a1a;
            --modal-text: #8b1a1a;
            --chart-text: #8b1a1a;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --border-color: #EB3349;
            --border-hover: #F45C43;
            --button-bg: #EB3349;
            --button-hover: #F45C43;
        }

        body[data-theme="lavender"] {
            --gradient-start: #868F96;
            --gradient-end: #596164;
            --header-bg: #868F96;
            --content-bg: #f5f5f5;
            --card-bg: #ebebeb;
            --modal-bg: #f5f5f5;
            --chart-bg: #f8f8f8;
            --content-text: #3a3a3a;
            --card-text: #3a3a3a;
            --modal-text: #3a3a3a;
            --chart-text: #3a3a3a;
            --header-text: #ffffff;
            --subheader-text: #ffffff;
            --border-color: #868F96;
            --border-hover: #596164;
            --button-bg: #868F96;
            --button-hover: #596164;
        }

        body[data-theme="minimal"] {
            --gradient-start: #f5f5f5;
            --gradient-end: #e0e0e0;
            --header-bg: #f5f5f5;
            --content-bg: #fafafa;
            --card-bg: #f0f0f0;
            --modal-bg: #fafafa;
            --chart-bg: #f5f5f5;
            --content-text: #2a2a2a;
            --card-text: #2a2a2a;
            --modal-text: #2a2a2a;
            --chart-text: #2a2a2a;
            --header-text: #333333;
            --subheader-text: #555555;
            --border-color: #868F96;
            --border-hover: #596164;
            --button-bg: #868F96;
            --button-hover: #596164;
        }

        body[data-theme="contrast"] {
            --gradient-start: #ffffff;
            --gradient-end: #f0f0f0;
            --header-bg: #ffffff;
            --content-bg: #ffffff;
            --card-bg: #f8f8f8;
            --modal-bg: #ffffff;
            --chart-bg: #fafafa;
            --content-text: #000000;
            --card-text: #000000;
            --modal-text: #000000;
            --chart-text: #000000;
            --header-text: #000000;
            --subheader-text: #333333;
            --border-color: #667eea;
            --border-hover: #764ba2;
            --button-bg: #667eea;
            --button-hover: #764ba2;
        }

        body[data-theme="retro"] {
            --gradient-start: #f4e4c1;
            --gradient-end: #d4a574;
            --header-bg: #f4e4c1;
            --content-bg: #faf8f3;
            --card-bg: #f5f0e6;
            --modal-bg: #faf8f3;
            --chart-bg: #fcfaf7;
            --content-text: #5a4a2a;
            --card-text: #5a4a2a;
            --modal-text: #5a4a2a;
            --chart-text: #5a4a2a;
            --header-text: #5a4a2a;
            --subheader-text: #6a5a3a;
            --border-color: #a67c52;
            --border-hover: #c49564;
            --button-bg: #d4a574;
            --button-hover: #c49564;
        }

        body[data-theme="neon"] {
            --gradient-start: #1a0033;
            --gradient-end: #330066;
            --header-bg: #1a0033;
            --content-bg: #1a0033;
            --card-bg: #2a0044;
            --modal-bg: #1a0033;
            --chart-bg: #220038;
            --content-text: #ffffff;
            --card-text: #ffffff;
            --modal-text: #ffffff;
            --chart-text: #ffffff;
            --header-text: #e0b3ff;
            --subheader-text: #e0b3ff;
            --border-color: #667eea;
            --border-hover: #667eea;
            --button-bg: #330066;
            --button-hover: #667eea;
        }

        body[data-theme="custom"] {
            --gradient-start: var(--custom-gradient-start, #134E5E);
            --gradient-end: var(--custom-gradient-end, #71B280);
            --content-bg: var(--custom-content-bg, #ffffff);
            --card-bg: var(--custom-card-bg, #f8f9ff);
            --modal-bg: var(--custom-modal-bg, #ffffff);
            --chart-bg: var(--custom-chart-bg, #fafbff);
            --content-text: var(--custom-content-text, #333333);
            --card-text: var(--custom-card-text, #333333);
            --modal-text: var(--custom-modal-text, #333333);
            --chart-text: var(--custom-chart-text, #333333);
            --header-text: var(--custom-header-text, #ffffff);
            --subheader-text: var(--custom-subheader-text, #ffffff);
            --button-bg: var(--custom-button-bg, #667eea);
            --button-hover: var(--custom-button-hover, #764ba2);
            --border-color: var(--custom-border-color, #667eea);
            --border-hover: var(--custom-border-hover, #764ba2);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: var(--content-bg);
            min-height: 100vh;
            padding: 0;
            margin: 0;
            transition: background 0.5s ease;
        }

        .container {
            max-width: 100%;
            width: 100%;
            margin: 0;
            background: var(--content-bg);
            color: var(--content-text);
            border-radius: 0;
            box-shadow: none;
            overflow: hidden;
            transition: background 0.5s ease, color 0.5s ease;
        }

        .header-nav-wrapper {
            background: linear-gradient(90deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            transition: background 0.5s ease;
            margin: 0;
            margin-bottom: -5px;
            padding: 0;
            display: block;
        }

        .header {
            background: transparent;
            color: var(--header-text);
            padding: 20px 30px 0 30px;
            text-align: center;
            transition: background 0.5s ease, color 0.5s ease;
            box-shadow: none;
            border-bottom: none;
            margin-bottom: 0;
            margin-top: 0;
            min-height: 280px;
            position: relative;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            margin-top: 0;
            color: var(--header-text);
        }
        
        .header p {
            color: var(--subheader-text);
            margin-bottom: 20px;
            margin-top: 0;
        }

        .nav {
            background: transparent;
            padding: 0 30px 20px 30px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            transition: background 0.5s ease;
            box-shadow: none;
            border-bottom: none;
            border-top: none;
            margin-top: 0;
        }

        .sync-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
        }

        .sync-status.compact {
            padding: 8px 12px;
            border-radius: 12px;
            min-width: 100px;
            width: auto;
            max-width: 120px;
        }

        .sync-status.compact .sync-details {
            max-width: 0;
            opacity: 0;
            transition: all 0.3s;
        }

        .sync-status.compact:hover {
            padding: 10px 20px;
        }

        .sync-status.compact:hover .sync-details {
            max-width: 200px;
            opacity: 1;
            margin-left: 10px;
        }

        .sync-status:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }

        .sync-details {
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
        }

        .sync-main-text {
            font-weight: 600;
        }

        .sync-sub-text {
            font-size: 0.75em;
            color: #666;
        }

        .sync-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .sync-indicator.connected {
            background: #28a745;
        }

        .sync-indicator.syncing {
            background: #ffc107;
        }

        .sync-indicator.offline {
            background: #6c757d;
        }

        .sync-indicator.error {
            background: #dc3545;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sync-menu {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 15px;
            min-width: 250px;
            z-index: 999;
            display: none;
        }

        .sync-menu.active {
            display: block;
            animation: fadeIn 0.2s;
        }

        .sync-menu-item {
            padding: 10px;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-menu-item:hover {
            background: #f8f9fa;
        }

        .sync-menu-divider {
            height: 1px;
            background: #e9ecef;
            margin: 10px 0;
        }

        .nav {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .nav {
            background: transparent;
            transition: background 0.5s ease;
        }
        
        .nav button {
            padding: 12px 24px;
            border: none;
            background: var(--button-bg);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .nav button:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .nav button.active {
            background: var(--button-hover);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Record Player Container */
        .record-player-container {
            position: absolute;
            left: 40px;
            top: 60px;
            z-index: 10;
        }

        .turntable-deck {
            position: relative;
            width: 200px;
            height: 200px;
            background: linear-gradient(135deg, #3a3a3a 0%, #1a1a1a 100%);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.6), inset 0 2px 4px rgba(255,255,255,0.05);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Vinyl Record Button */
        .vinyl-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            transition: transform 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-weight: 600;
            position: relative;
            z-index: 2;
        }

        .vinyl-button:hover {
            transform: scale(1.05);
        }

        .vinyl-record {
            width: 130px;
            height: 130px;
            background: radial-gradient(circle at 30% 30%, #2a2a2a 0%, #0a0a0a 100%);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.6), inset 0 1px 3px rgba(255,255,255,0.05);
            animation: spin 4s linear infinite;
        }

        .vinyl-record.rpm-45 {
            animation: spin 2.96s linear infinite; /* 45/33.3 = 1.35x faster */
        }

        .vinyl-record.rpm-78 {
            animation: spin 1.69s linear infinite; /* 78/33.3 = 2.34x faster */
        }

        .vinyl-button:hover .vinyl-record {
            animation-duration: 2s;
        }

        .vinyl-button:hover .vinyl-record.rpm-45 {
            animation-duration: 1.48s;
        }

        .vinyl-button:hover .vinyl-record.rpm-78 {
            animation-duration: 0.85s;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Tonearm */
        .tonearm {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 70px;
            height: 3px;
            background: linear-gradient(90deg, #666 0%, #999 50%, #666 100%);
            border-radius: 2px;
            transform-origin: right center;
            transform: rotate(-90deg);
            transition: transform 0.8s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
            z-index: 5;
        }

        .tonearm::before {
            content: '';
            position: absolute;
            right: -8px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            background: #444;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.6);
        }

        .tonearm::after {
            content: '';
            position: absolute;
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 8px;
            background: #888;
            border-radius: 50%;
            box-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }

        .tonearm.playing {
            transform: rotate(-35deg);
        }

        /* Power Switch (Top Left - Remove Album) */
        .power-switch {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 20px;
            cursor: pointer;
            z-index: 6;
        }

        .switch-track {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 2px solid #444;
            border-radius: 10px;
            position: relative;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.6);
        }

        .switch-indicator {
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            background: linear-gradient(135deg, #666 0%, #444 100%);
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.4);
        }

        .switch-indicator.on {
            left: calc(100% - 14px);
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            box-shadow: 0 0 8px rgba(74, 222, 128, 0.6), 0 2px 4px rgba(0,0,0,0.4);
        }

        .power-switch:hover .switch-track {
            border-color: #666;
        }

        /* Volume Control (Bottom Left - Pick New) */
        .volume-control {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 31.5px;
            height: 31.5px;
            cursor: pointer;
            z-index: 6;
        }

        .volume-knob {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #4a4a4a 0%, #2a2a2a 100%);
            border: 2px solid #555;
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 8px rgba(0,0,0,0.6), inset 0 2px 4px rgba(255,255,255,0.05);
            transition: all 0.2s;
        }

        .knob-indicator {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
            background: #fff;
            border-radius: 2px;
            box-shadow: 0 0 4px rgba(255,255,255,0.6);
        }

        .volume-label {
            display: none;
        }

        .volume-control:hover .volume-knob {
            border-color: #777;
            transform: scale(1.05);
            box-shadow: 0 6px 12px rgba(0,0,0,0.8), inset 0 2px 4px rgba(255,255,255,0.05);
        }

        .volume-control:active .volume-knob {
            transform: scale(0.95);
        }

        /* Speed Slider (Bottom Right) */
        .speed-slider {
            position: absolute;
            bottom: 0px;
            right: 0px;
            width: 70px;
            height: 50px;
            cursor: pointer;
            z-index: 6;
        }

        .slider-track {
            position: absolute;
            top: 15px;
            left: 10px;
            right: 10px;
            height: 4px;
            background: linear-gradient(90deg, #2a2a2a 0%, #1a1a1a 100%);
            border: 1px solid #444;
            border-radius: 2px;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.6);
        }

        .slider-notch {
            position: absolute;
            top: -2px;
            width: 2px;
            height: 8px;
            background: #666;
            border-radius: 1px;
        }

        .slider-notch[data-speed="33"] {
            left: 0;
        }

        .slider-notch[data-speed="45"] {
            left: 50%;
            transform: translateX(-50%);
        }

        .slider-notch[data-speed="78"] {
            right: 0;
        }

        .slider-handle {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 12px;
            height: 14px;
            background: linear-gradient(135deg, #5a5a5a 0%, #3a3a3a 100%);
            border: 2px solid #666;
            border-radius: 3px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.6);
        }

        .slider-handle.speed-45 {
            left: 50%;
            transform: translateX(-50%);
        }

        .slider-handle.speed-78 {
            left: calc(100% - 22px);
        }

        .speed-labels {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 8px;
        }

        .speed-labels span {
            font-size: 8px;
            font-weight: 700;
            color: #999;
        }

        .speed-slider:hover .slider-handle {
            border-color: #888;
            box-shadow: 0 3px 6px rgba(0,0,0,0.8);
        }

        /* Tooltip for all controls */
        .volume-control::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            margin-bottom: 8px;
            z-index: 100;
        }

        .volume-control:hover::before {
            opacity: 1;
        }
        
        /* Hide tooltips for power switch and speed slider */
        .power-switch::before,
        .speed-slider::before {
            display: none !important;
        }

        /* Now Playing Display */
        .now-playing-display {
            position: absolute;
            top: -40px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 11px;
            font-weight: 600;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.6);
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            z-index: 10;
        }
        
        .now-playing-display.visible.scrolling {
            overflow: hidden;
            white-space: nowrap;
        }
        
        .now-playing-display.visible.scrolling::before {
            content: attr(data-text);
            display: inline-block;
            padding-right: 50px;
            animation: scroll-text 15s linear infinite;
        }
        
        @keyframes scroll-text {
            0% {
                transform: translateX(100%);
            }
            100% {
                transform: translateX(-100%);
            }
        }

        .now-playing-display.visible {
            opacity: 1;
        }

        /* Album Art in Label */
        .vinyl-label img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
            display: none;
            position: absolute;
            top: 0;
            left: 0;
        }

        .vinyl-label img.visible {
            display: block;
        }

        .vinyl-label .label-center-text.hidden {
            display: none;
        }
        
        #albumArtwork {
            z-index: 1;
        }

        /* Custom radio button styling */
        input[type="radio"] {
            appearance: none !important;
            -webkit-appearance: none !important;
            width: 18px;
            height: 18px;
            border: 2px solid var(--button-hover-text) !important;
            border-radius: 50%;
            outline: none;
            cursor: pointer;
            position: relative;
            background: transparent !important;
            flex-shrink: 0;
            margin-right: 8px;
        }

        input[type="radio"]:checked {
            background: var(--button-hover-text) !important;
            border-color: var(--button-hover-text) !important;
        }

        input[type="radio"]:checked::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--chart-bg) !important;
        }

        input[type="radio"]:hover {
            opacity: 0.8;
        }

        /* Vinyl grooves - concentric circles for realistic texture */
        .vinyl-groove {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.03);
            pointer-events: none;
        }

        .vinyl-groove-1 {
            width: 95%;
            height: 95%;
        }

        .vinyl-groove-2 {
            width: 85%;
            height: 85%;
            border-color: rgba(255, 255, 255, 0.04);
        }

        .vinyl-groove-3 {
            width: 75%;
            height: 75%;
            border-color: rgba(255, 255, 255, 0.03);
        }

        .vinyl-groove-4 {
            width: 65%;
            height: 65%;
            border-color: rgba(255, 255, 255, 0.04);
        }

        .vinyl-groove-5 {
            width: 55%;
            height: 55%;
            border-color: rgba(255, 255, 255, 0.03);
        }

        /* Record label (center sticker) */
        .vinyl-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0,0,0,0.4);
            transition: background 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .label-center-text {
            font-size: 20px;
            z-index: 2;
            position: relative;
        }

        /* Center hole */
        .vinyl-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: #000;
            border-radius: 50%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8), 0 0 0 1px rgba(255,255,255,0.1);
            z-index: 3;
        }

        .vinyl-text {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .vinyl-text text {
            fill: white;
            font-size: 8px;
            font-weight: 600;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            opacity: 0.9;
        }

        /* Mobile optimization for header */
        @media (max-width: 768px) {
            .record-player-container {
                left: 10px;
            }
            
            .turntable-deck {
                width: 170px;
                height: 170px;
                padding: 15px;
            }
            
            .tonearm {
                width: 60px;
                height: 2.5px;
                top: 15px;
                right: 15px;
            }
            
            .power-switch {
                width: 35px;
                height: 18px;
                top: 8px;
                left: 8px;
            }
            
            .switch-indicator {
                width: 10px;
                height: 10px;
            }
            
            .volume-control {
                width: 26.6px;
                height: 26.6px;
                bottom: 12px;
                left: 12px;
            }
            
            .volume-knob {
                border-width: 2px;
            }
            
            .knob-indicator {
                top: 4px;
                height: 7px;
                width: 1.5px;
            }
            
            .volume-label {
                display: none;
            }
            
            .speed-slider {
                width: 60px;
                height: 45px;
                bottom: 0px;
                right: 0px;
            }
            
            .slider-handle {
                width: 10px;
                height: 12px;
            }
            
            .speed-labels span {
                font-size: 7px;
            }
            
            .now-playing-display {
                font-size: 10px;
                padding: 5px 10px;
                max-width: 170px;
            }
            
            .header h1 {
                font-size: 1.5em;
                margin-left: 90px;
                margin-right: 10px;
            }

            .header p {
                font-size: 0.85em;
                margin-left: 90px;
                margin-right: 10px;
            }

            .vinyl-record {
                width: 109px;
                height: 109px;
            }

            .vinyl-label {
                width: 42px;
                height: 42px;
            }

            .label-center-text {
                font-size: 17px;
            }

            .vinyl-center {
                width: 10px;
                height: 10px;
            }

            .vinyl-text text {
                font-size: 6.5px;
                letter-spacing: 1.2px;
            }
        }

        @media (max-width: 480px) {
            .record-player-container {
                left: 5px;
            }
            
            .turntable-deck {
                width: 150px;
                height: 150px;
                padding: 12px;
            }
            
            .tonearm {
                width: 50px;
                height: 2px;
                top: 12px;
                right: 12px;
            }
            
            .power-switch {
                width: 32px;
                height: 16px;
                top: 6px;
                left: 6px;
            }
            
            .switch-indicator {
                width: 9px;
                height: 9px;
            }
            
            .volume-control {
                width: 24.5px;
                height: 24.5px;
                bottom: 10px;
                left: 10px;
            }
            
            .volume-knob {
                border-width: 1.5px;
            }
            
            .knob-indicator {
                top: 3px;
                height: 6px;
                width: 1.5px;
            }
            
            .volume-label {
                display: none;
            }
            
            .speed-slider {
                width: 55px;
                height: 42px;
                bottom: 0px;
                right: 0px;
            }
            
            .slider-handle {
                width: 9px;
                height: 11px;
            }
            
            .speed-labels span {
                font-size: 6px;
            }
            
            .now-playing-display {
                font-size: 9px;
                padding: 4px 8px;
                max-width: 150px;
            }
            
            .header h1 {
                font-size: 1.3em;
                margin-left: 75px;
            }

            .header p {
                font-size: 0.75em;
                margin-left: 75px;
            }

            .vinyl-record {
                width: 94px;
                height: 94px;
            }

            .vinyl-label {
                width: 36px;
                height: 36px;
            }

            .label-center-text {
                font-size: 14px;
            }

            .vinyl-center {
                width: 8px;
                height: 8px;
            }

            .vinyl-text text {
                font-size: 5.5px;
                letter-spacing: 1px;
            }
        }

        .vinyl-groove {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 45px;
            height: 45px;
            border: 2px solid rgba(255,255,255,0.05);
            border-radius: 50%;
        }

        .vinyl-groove::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
        }

        /* Settings Button */
        .settings-button {
            position: absolute;
            right: 60px;
            top: 50%;
            transform: translateY(-10%);
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            transition: transform 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            width: 80px;
            height: 80px;
        }

        .settings-button:hover {
            transform: translateY(-10%) scale(1.1);
        }

        .settings-cog {
            width: 80px;
            height: 80px;
            position: relative;
            animation: spin 8s linear infinite;
            background: transparent;
        }

        .settings-button:hover .settings-cog {
            animation: spin 2s linear infinite;
        }

        /* Cog background with vinyl record styling */
        .settings-cog-bg {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .settings-cog-bg circle {
            fill: url(#cogGradient);
            filter: drop-shadow(0 4px 15px rgba(0,0,0,0.6));
        }

        /* Cog teeth with vinyl styling */
        .settings-cog-teeth {
            position: absolute;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
        }

        .settings-cog-teeth path {
            fill: radial-gradient(circle at 30% 30%, #2a2a2a 0%, #0a0a0a 100%);
            stroke: rgba(255, 255, 255, 0.1);
            stroke-width: 0.5;
        }

        /* Cog grooves - concentric circles for vinyl texture */
        .cog-groove {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.03);
            pointer-events: none;
        }

        .cog-groove-1 {
            width: 90%;
            height: 90%;
        }

        .cog-groove-2 {
            width: 75%;
            height: 75%;
            border-color: rgba(255, 255, 255, 0.04);
        }

        .cog-groove-3 {
            width: 60%;
            height: 60%;
            border-color: rgba(255, 255, 255, 0.03);
        }

        /* Cog center label (like vinyl record center) */
        .cog-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            border-radius: 50%;
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.3), 0 2px 8px rgba(0,0,0,0.4);
            transition: background 0.5s ease;
        }

        /* Cog center hole */
        .cog-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #000;
            border-radius: 50%;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.8), 0 0 0 1px rgba(255,255,255,0.1);
            z-index: 3;
        }

        .view-toggle-button {
            position: absolute;
            right: 75px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            z-index: 10;
            display: none; /* Hidden by default, shown on mobile */
        }

        .view-toggle-button:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        @media (max-width: 768px) {
            .view-toggle-button {
                display: block; /* Show on mobile/tablet */
            }
        }

        @media (max-width: 768px) {
            .settings-button {
                right: 10px;
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }

        @media (max-width: 480px) {
            .settings-button {
                right: 5px;
                width: 35px;
                height: 35px;
                font-size: 16px;
            }
        }

        /* Settings Modal */
        .settings-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10000;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .settings-modal.active {
            display: flex;
        }

        .settings-content {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            animation: slideUp 0.3s;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .settings-header {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.5s ease;
        }

        .settings-header h2 {
            font-size: 1.8em;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-close {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .settings-close:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: rotate(90deg);
        }

        .settings-body {
            padding: 30px;
            background: #fafafa; /* Light background to verify padding */
        }

        .settings-section {
            margin-bottom: 35px;
            padding-bottom: 35px;
            border-bottom: 2px solid #f0f0f0;
        }

        .settings-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .settings-section h3 {
            font-size: 1.3em;
            margin-bottom: 10px;
            color: #667eea;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .settings-section p {
            color: #666;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .collapsible-header:hover {
            opacity: 0.8;
        }
        
        .collapse-icon {
            transition: transform 0.3s ease;
            font-size: 0.8em;
        }
        
        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }
        
        .collapsible-content {
            max-height: 5000px;
            overflow: hidden;
            transition: max-height 0.3s ease, opacity 0.3s ease;
            opacity: 1;
        }
        
        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .settings-input-group {
            margin-bottom: 15px;
        }

        .settings-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .settings-input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
            font-family: monospace;
        }

        .settings-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .settings-button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .settings-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .settings-btn-primary {
            background: linear-gradient(135deg, var(--button-bg) 0%, var(--button-hover) 100%);
            color: white;
        }

        .settings-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .settings-btn-secondary {
            background: #f8f9fa;
            color: #666;
            border: 2px solid #e9ecef;
        }

        .settings-btn-secondary:hover {
            background: #e9ecef;
        }

        .settings-btn-link {
            background: transparent;
            color: #667eea;
            text-decoration: underline;
            padding: 10px 0;
        }

        .settings-btn-link:hover {
            color: #764ba2;
        }

        .settings-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .settings-status.connected {
            background: #d4edda;
            color: #155724;
        }

        .settings-status.disconnected {
            background: #fff3cd;
            color: #856404;
        }

        .settings-status.error {
            background: #f8d7da;
            color: #721c24;
        }

        /* Theme Customization */
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .theme-option {
            position: relative;
            cursor: pointer;
            border: 3px solid transparent;
            border-radius: 12px;
            padding: 12px;
            transition: all 0.3s;
            background: #f8f9fa;
        }

        .theme-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .theme-option.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .theme-preview {
            width: 100%;
            height: 80px;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .theme-color {
            width: 100%;
            height: 100%;
        }

        .theme-name {
            text-align: center;
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        .theme-check {
            position: absolute;
            top: 8px;
            right: 8px;
            background: var(--button-bg);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .theme-option.selected .theme-check {
            display: flex;
        }

        /* Instructions Modal */
        .instructions-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10001;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.3s;
        }

        .instructions-modal.active {
            display: flex;
        }

        .instructions-content {
            background: white;
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .instructions-header {
            background: linear-gradient(135deg, var(--button-bg) 0%, var(--button-hover) 100%);
            color: white;
            padding: 25px 30px;
            border-radius: 20px 20px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .instructions-header h2 {
            font-size: 1.5em;
        }

        .instructions-body {
            padding: 30px;
        }

        .instruction-step {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            align-items: flex-start;
        }

        .instruction-number {
            background: linear-gradient(135deg, var(--button-bg) 0%, var(--button-hover) 100%);
            color: white;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
        }

        .instruction-text {
            flex: 1;
            padding-top: 5px;
        }

        .instruction-text p {
            margin-bottom: 10px;
            line-height: 1.6;
        }

        .instruction-link {
            display: inline-block;
            margin-top: 10px;
            padding: 10px 20px;
            background: linear-gradient(135deg, var(--button-bg) 0%, var(--button-hover) 100%);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .instruction-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .instruction-note {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 15px;
            margin-top: 20px;
            border-radius: 8px;
        }

        .instruction-note strong {
            color: #667eea;
            display: block;
            margin-bottom: 5px;
        }

        /* Discogs Results Styles */
        .discogs-result-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            gap: 15px;
        }

        .discogs-result-card:hover {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }

        .discogs-result-card.selected {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .discogs-result-image {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 8px;
            background: #f0f0f0;
            flex-shrink: 0;
        }

        .discogs-result-info {
            flex: 1;
        }

        .discogs-result-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .discogs-result-details {
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .discogs-result-details strong {
            color: #333;
        }

        .discogs-result-button {
            align-self: center;
            padding: 8px 16px;
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
        }

        .discogs-result-button:hover {
            background: var(--button-hover);
            transform: scale(1.05);
        }

        .vinyl-groove::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
        }

        .content {
            padding: 30px;
            min-height: 500px;
            margin-top: -5px;
            background: var(--content-bg);
        }

        .section {
            display: none;
            background: var(--content-bg);
            padding: 30px;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            background: var(--button-bg);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .random-album-card {
            background: linear-gradient(135deg, var(--button-bg) 0%, var(--button-hover) 100%);
            border-radius: 16px;
            padding: 30px;
            color: white;
            margin-bottom: 30px;
        }

        .random-album-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .album-artwork {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .album-details {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .album-details h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .album-details p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .wiki-link {
            display: inline-block;
            margin-left: 8px;
            color: #fff;
            opacity: 0.7;
            transition: opacity 0.2s;
            text-decoration: none;
            font-size: 0.85em;
            vertical-align: middle;
        }

        .wiki-link:hover {
            opacity: 1;
        }

        .wiki-link svg {
            width: 16px;
            height: 16px;
            vertical-align: middle;
        }

        .spotify-link {
            display: inline-block;
            margin-left: 8px;
            color: #1DB954;
            opacity: 0.9;
            transition: all 0.2s;
            text-decoration: none;
            font-size: 0.85em;
            vertical-align: middle;
        }

        .spotify-link:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .spotify-link svg {
            width: 18px;
            height: 18px;
            vertical-align: middle;
        }

        .rating-form {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .filters {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
            cursor: pointer;
            pointer-events: auto;
            transition: color 0.2s;
        }

        .search-icon:hover {
            color: #667eea;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            margin-top: 4px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #e9ecef;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-artwork {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            background: #e9ecef;
        }

        .search-result-info {
            flex: 1;
        }

        .search-result-album {
            font-weight: 600;
            color: #212529;
            margin-bottom: 2px;
        }

        .search-result-artist {
            font-size: 14px;
            color: #6c757d;
        }

        .search-no-results {
            padding: 20px;
            text-align: center;
            color: #6c757d;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .album-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .album-card {
            background: var(--card-bg);
            color: var(--card-text);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s;
            cursor: pointer;
        }

        .album-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-color: var(--border-hover);
        }

        .album-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .album-card-info {
            padding: 15px;
        }

        .album-card-info h3 {
            font-size: 1em;
            margin-bottom: 5px;
            color: var(--card-text);
        }

        .album-card-info p {
            font-size: 0.9em;
            color: var(--card-text);
            margin-bottom: 3px;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-top: 8px;
        }

        .score-high {
            background: #28a745;
            color: white;
        }

        .score-medium {
            background: #ffc107;
            color: #333;
        }

        .score-low {
            background: #dc3545;
            color: white;
        }

        .score-unrated {
            background: #e9ecef;
            color: #6c757d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: var(--chart-bg);
            color: var(--chart-text);
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border-color);
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .chart {
            background: var(--chart-bg);
            color: var(--chart-text);
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid var(--border-color);
        }

        .score-albums-section {
            background: var(--chart-bg);
            color: var(--chart-text);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .chart-label {
            width: 150px;
            font-size: 0.9em;
            color: #333;
        }

        .chart-bar-fill {
            height: 30px;
            background: linear-gradient(135deg, var(--button-bg) 0%, var(--button-hover) 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            min-width: 40px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--modal-bg);
            color: var(--modal-text);
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 2em;
            cursor: pointer;
            color: #6c757d;
            line-height: 1;
        }

        .modal-close:hover {
            color: #333;
        }

        .file-upload {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload:hover {
            background: #f8f9fa;
            border-color: #764ba2;
        }

        .file-upload input {
            display: none;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        /* Lists Section Styles */
        .list-card {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .list-card:hover {
            box-shadow: 0 4px 16px rgba(0,0,0,0.15);
            border-color: var(--gradient-start);
        }

        .list-card-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .list-card-title {
            flex: 1;
            margin-right: 15px;
        }

        .list-card-title h3 {
            margin: 0 0 5px 0;
            color: var(--card-text);
            font-size: 1.3em;
        }

        .list-card-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }

        .list-card-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .badge-category {
            background: linear-gradient(135deg, var(--gradient-start) 0%, var(--gradient-end) 100%);
            color: white;
        }

        .badge-source {
            background: #e9ecef;
            color: #495057;
        }

        .badge-genre {
            background: #fff3cd;
            color: #856404;
        }

        .badge-count {
            background: #d1ecf1;
            color: #0c5460;
        }

        .list-status-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 600;
            white-space: nowrap;
        }

        .status-added {
            background: #d4edda;
            color: #155724;
        }

        .status-partial {
            background: #fff3cd;
            color: #856404;
        }

        .list-card-content {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #e9ecef;
            display: none;
        }

        .list-card-content.expanded {
            display: block;
        }

        .list-description {
            color: #666;
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .list-albums-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .list-album-item {
            background: var(--chart-bg);
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.3s;
            border: 2px solid transparent;
        }

        .list-album-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: var(--gradient-start);
        }

        .list-album-item.in-library {
            border-color: #28a745;
            background: #f0fff4;
        }

        .list-album-item.missing {
            opacity: 0.6;
        }

        .list-album-artwork {
            width: 100%;
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 6px;
            margin-bottom: 8px;
        }

        .list-album-title {
            font-size: 0.85em;
            font-weight: 600;
            margin-bottom: 3px;
            color: var(--card-text);
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .list-album-artist {
            font-size: 0.75em;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .list-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .expand-icon {
            transition: transform 0.3s;
            font-size: 1.5em;
            color: var(--gradient-start);
        }

        .expand-icon.expanded {
            transform: rotate(180deg);
        }

        /* Duplicate Cleanup Styles */
        .duplicate-group {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .duplicate-group.query {
            border-color: #ffc107;
            background: #fff3cd;
        }

        .duplicate-item {
            background: white;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .duplicate-item.keep {
            border-color: #28a745;
            background: #d4edda;
        }

        .duplicate-item.delete {
            border-color: #dc3545;
            background: #f8d7da;
        }

        .duplicate-checkbox {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .duplicate-info {
            flex: 1;
        }

        .duplicate-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: 600;
            margin-left: 8px;
        }

        .badge-keep {
            background: #28a745;
            color: white;
        }

        .badge-delete {
            background: #dc3545;
            color: white;
        }

        .badge-query {
            background: #ffc107;
            color: #333;
        }

        .badge-master {
            background: var(--button-hover);
            color: white;
        }

        @media (max-width: 768px) {
            .random-album-content {
                grid-template-columns: 1fr;
            }

            .album-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .nav {
                flex-direction: column;
            }

            .nav button {
                width: 100%;
            }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .tag {
            display: inline-block;
            padding: 4px 10px;
            background: #e9ecef;
            border-radius: 12px;
            font-size: 0.85em;
            margin: 2px;
            color: #495057;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .album-checkbox {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 10;
            accent-color: #9b59b6;
        }

        .album-card.multi-select-mode {
            cursor: pointer;
        }

        .album-card.selected {
            outline: 3px solid #9b59b6;
            outline-offset: -3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header wrapper with gradient -->
        <div class="header-nav-wrapper">
        <div class="header" style="position: relative;">
            <!-- Record Player Interface -->
            <div class="record-player-container">
                <!-- Turntable Deck Background -->
                <div class="turntable-deck">
                    <!-- Random Album Button (Vinyl Record Style) -->
                    <button onclick="handleVinylClick()" class="vinyl-button" title="Pick an Album">
                        <div class="vinyl-record" id="vinylRecord">
                            <!-- Vinyl grooves (multiple circles for realistic look) -->
                            <div class="vinyl-groove vinyl-groove-1"></div>
                            <div class="vinyl-groove vinyl-groove-2"></div>
                            <div class="vinyl-groove vinyl-groove-3"></div>
                            <div class="vinyl-groove vinyl-groove-4"></div>
                            <div class="vinyl-groove vinyl-groove-5"></div>
                            
                            <!-- Text on vinyl body -->
                            <svg class="vinyl-text" id="vinylText" viewBox="0 0 100 100">
                                <defs>
                                    <path id="circlePath" d="M 50, 50 m -40, 0 a 40,40 0 1,1 80,0 a 40,40 0 1,1 -80,0"/>
                                </defs>
                                <!-- First text at top -->
                                <text>
                                    <textPath href="#circlePath" startOffset="0%">
                                        PICK AN ALBUM
                                    </textPath>
                                </text>
                                <!-- Second text at bottom (opposite side) -->
                                <text>
                                    <textPath href="#circlePath" startOffset="50%">
                                        PICK AN ALBUM
                                    </textPath>
                                </text>
                            </svg>
                            
                            <!-- Record label (center sticker) -->
                            <div class="vinyl-label" id="vinylLabel">
                                <div class="label-center-text" id="labelCenterText"></div>
                                <img id="albumArtwork" src="" alt="Album Art" style="display: none;">
                            </div>
                            
                            <!-- Center hole -->
                            <div class="vinyl-center"></div>
                        </div>
                    </button>
                    
                    <!-- Tonearm -->
                    <div class="tonearm" id="tonearm"></div>
                    
                    <!-- Power Switch (Top Left - Remove Album) -->
                    <div class="power-switch" id="powerSwitch" data-tooltip="Power Off" onclick="removeAlbum()">
                        <div class="switch-track">
                            <div class="switch-indicator" id="switchIndicator"></div>
                        </div>
                    </div>
                    
                    <!-- Volume Control (Bottom Left - Pick New) -->
                    <div class="volume-control" data-tooltip="Pick New Album" onclick="pickRandomAlbum()">
                        <div class="volume-knob">
                            <div class="knob-indicator"></div>
                        </div>
                        <div class="volume-label">VOL</div>
                    </div>
                    
                    <!-- Speed Slider (Bottom Right) -->
                    <div class="speed-slider" data-tooltip="Speed: 33 RPM" id="speedSlider" onclick="cycleRPM()">
                        <div class="slider-track">
                            <div class="slider-notch" data-speed="33"></div>
                            <div class="slider-notch" data-speed="45"></div>
                            <div class="slider-notch" data-speed="78"></div>
                        </div>
                        <div class="slider-handle" id="sliderHandle"></div>
                        <div class="speed-labels">
                            <span>33</span>
                            <span>45</span>
                            <span>78</span>
                        </div>
                    </div>
                    
                    <!-- Now Playing Display -->
                    <div class="now-playing-display" id="nowPlayingDisplay"></div>
                </div>
            </div>
            
            <h1> Album Tracker</h1>
            <p>Track, Rate, and Discover Your Music Journey</p>
            
            <!-- View Toggle Button (Mobile Only) -->
            <button onclick="toggleViewMode()" class="view-toggle-button" id="viewToggleBtn" title="Toggle View Mode">
                 Mobile View
            </button>
            
            <!-- Settings Button -->
            <button onclick="openSettings()" class="settings-button" title="Settings">
                <svg class="settings-cog" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <radialGradient id="cogLabelGradient" cx="50%" cy="50%">
                            <stop offset="0%" style="stop-color:var(--gradient-start);stop-opacity:1" />
                            <stop offset="100%" style="stop-color:var(--gradient-end);stop-opacity:1" />
                        </radialGradient>
                    </defs>
                    
                    <!-- Gear teeth: 12 trapezoid teeth evenly rotated -->
                    <g class="gear-teeth">
                        <!-- Each tooth is a trapezoid (squared-off triangle) pointing outward from center -->
                        <!-- Trapezoid: flat top at y=5, wider base at y=32 (inner circle edge) -->
                        <!-- Tooth 1: 0 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(0 50 50)" />
                        <!-- Tooth 2: 30 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(30 50 50)" />
                        <!-- Tooth 3: 60 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(60 50 50)" />
                        <!-- Tooth 4: 90 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(90 50 50)" />
                        <!-- Tooth 5: 120 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(120 50 50)" />
                        <!-- Tooth 6: 150 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(150 50 50)" />
                        <!-- Tooth 7: 180 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(180 50 50)" />
                        <!-- Tooth 8: 210 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(210 50 50)" />
                        <!-- Tooth 9: 240 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(240 50 50)" />
                        <!-- Tooth 10: 270 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(270 50 50)" />
                        <!-- Tooth 11: 300 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(300 50 50)" />
                        <!-- Tooth 12: 330 rotation -->
                        <polygon points="47,5 53,5 58,32 42,32" fill="#000000" transform="rotate(330 50 50)" />
                    </g>
                    
                    <!-- Inner gear circle (main body) - black - larger for more black space -->
                    <circle cx="50" cy="50" r="38" fill="#000000" />
                    
                    <!-- Center label (colored circle - record label) -->
                    <circle cx="50" cy="50" r="18" fill="url(#cogLabelGradient)" />
                    
                    <!-- Rotating "Settings" text around the label circle -->
                    <defs>
                        <path id="textCircle" d="M 50,50 m -28,0 a 28,28 0 1,1 56,0 a 28,28 0 1,1 -56,0" fill="none" />
                    </defs>
                    <text font-size="9" font-weight="600" fill="#ffffff" letter-spacing="2">
                        <textPath href="#textCircle" startOffset="22%">
                            SETTINGS
                        </textPath>
                    </text>
                    
                    <!-- Center hole -->
                    <circle cx="50" cy="50" r="6" fill="#1a1a1a" />
                </svg>
            </button>
        </div>

        <div class="nav">
            <button onclick="showSection('browse', event)" class="active">Browse Albums</button>
            <button onclick="showSection('lists', event)">Lists</button>
            <button onclick="showSection('import', event)">Import/Export Data</button>
            <button onclick="showSection('stats', event)">Statistics</button>
        </div>
        </div> <!-- End header-nav-wrapper -->

        <div class="content">
            <!-- Random Album Section -->
            <div id="random" class="section">
                <div class="random-album-card">
                    <h2 style="text-align: center;">Discover Your Next Album</h2>
                    <div style="text-align: center; margin: 20px 0; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                        <button class="btn btn-success" onclick="selectRandomAlbum()" style="font-size: 1.2em; padding: 15px 40px;">
                             Pick Again
                        </button>
                        <button class="btn btn-primary" onclick="generateRandomList()" style="font-size: 1.2em; padding: 15px 40px;">
                             Generate List of 10
                        </button>
                        <button id="randomNowPlayingBtn" class="btn btn-primary" onclick="playRandomAlbum()" style="font-size: 0.9em; padding: 10px 20px; display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                             Play This Record
                        </button>
                    </div>
                    <div id="randomAlbumDisplay"></div>
                    <div id="randomListDisplay" style="display: none;"></div>
                </div>
            </div>

            <!-- Browse Albums Section -->
            <div id="browse" class="section active">
                <h2>Browse Albums</h2>
                
                <!-- Multi-select Controls -->
                <div id="multiSelectControls" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; display: none;">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="toggleSelectAll()">
                            <span id="selectAllText">Select All</span>
                        </button>
                        <button class="btn btn-danger" onclick="deleteSelectedAlbums()" id="deleteSelectedBtn" disabled>
                             Delete Selected (<span id="selectedCount">0</span>)
                        </button>
                        <button class="btn btn-secondary" onclick="toggleMultiSelectMode()">
                            Cancel
                        </button>
                        <span style="color: #666; margin-left: auto;">Multi-select mode active</span>
                    </div>
                </div>
                
                <!-- Search Box -->
                <div class="search-container">
                    <input 
                        type="text" 
                        id="browseSearchInput" 
                        class="search-input" 
                        placeholder="Search by album name or artist..."
                        autocomplete="off"
                    >
                    <span class="search-icon" id="browseSearchIcon" title="Click to search"></span>
                    <div id="browseSearchResults" class="search-results"></div>
                </div>
                
                <div class="filters">
                    <h3 style="margin-bottom: 15px;">Filters</h3>
                    <div class="filters-grid">
                        <div class="form-group">
                            <label>Genre</label>
                            <select id="filterGenre" onchange="applyFilters()">
                                <option value="">All Genres</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Source List</label>
                            <select id="filterSource" onchange="applyFilters()">
                                <option value="">All Sources</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="filterStatus" onchange="applyFilters()">
                                <option value="">All</option>
                                <option value="listened">Listened</option>
                                <option value="unlistened">Unlistened</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Sort By</label>
                            <select id="sortBy" onchange="applyFilters()">
                                <option value="name-asc">Album Name (A-Z)</option>
                                <option value="name-desc">Album Name (Z-A)</option>
                                <option value="artist-asc">Artist (A-Z)</option>
                                <option value="artist-desc">Artist (Z-A)</option>
                                <option value="score-desc">Score (High-Low)</option>
                                <option value="score-asc">Score (Low-High)</option>
                                <option value="date-desc">Date Listened (Newest)</option>
                                <option value="date-asc">Date Listened (Oldest)</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>
                        <button class="btn" onclick="toggleMultiSelectMode()">
                            <span id="multiSelectModeBtn"> Multi-Select</span>
                        </button>
                        <button class="btn btn-success" onclick="showAddAlbumForm()" style="margin-left: auto;">
                             Add Album
                        </button>
                    </div>
                </div>

                <!-- Add Album Form (Initially Hidden) -->
                <div id="addAlbumFormContainer" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 12px; border: 2px solid #667eea;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Add New Album</h3>
                        <button class="btn btn-secondary" onclick="hideAddAlbumForm()"> Cancel</button>
                    </div>
                    
                    <!-- Quick Search Section -->
                    <div id="discogsQuickSearch" style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 1px solid #ddd;">
                        <h4 style="margin: 0 0 10px 0; color: #667eea;"> Quick Search</h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end;">
                            <div class="form-group" style="margin: 0;">
                                <label>Artist Name</label>
                                <input type="text" id="quickSearchArtist" placeholder="e.g., Pink Floyd">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label>Album Name</label>
                                <input type="text" id="quickSearchAlbum" placeholder="e.g., Dark Side of the Moon">
                            </div>
                            <button type="button" class="btn" onclick="searchDiscogs()" style="background: #667eea; margin: 0;">
                                 Find on Discogs
                            </button>
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #eee;">
                            <div class="form-group" style="margin: 0;">
                                <label>Or paste Discogs URL</label>
                                <div style="display: flex; gap: 10px;">
                                    <input type="url" id="discogsUrl" placeholder="https://www.discogs.com/release/..." style="flex: 1;">
                                    <button type="button" class="btn" onclick="fetchFromDiscogsUrl()" style="background: #667eea;">
                                         Import from URL
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <button type="button" class="btn btn-secondary" onclick="clearQuickSearch()" style="font-size: 0.9em;">
                                Clear
                            </button>
                            <button type="button" class="btn btn-secondary" onclick="openDiscogsManually()" style="font-size: 0.9em;">
                                 Search on Discogs
                            </button>
                        </div>
                        <div id="discogsSearchStatus" style="margin-top: 10px; padding: 8px; border-radius: 4px; display: none;"></div>
                    </div>
                    
                    <form id="addAlbumFormInline" onsubmit="addAlbumInline(event)">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div class="form-group">
                                <label>Album Name *</label>
                                <input type="text" id="albumNameInline" required>
                            </div>
                            <div class="form-group">
                                <label>Artist *</label>
                                <input type="text" id="artistInline" required>
                            </div>
                            <div class="form-group">
                                <label>Year *</label>
                                <input type="number" id="yearInline" min="1900" max="2100" required>
                            </div>
                            <div class="form-group">
                                <label>Album Artwork URL *</label>
                                <input type="url" id="artworkUrlInline" required placeholder="https://...">
                            </div>
                            <div class="form-group">
                                <label>Genre</label>
                                <input type="text" id="genreInline" placeholder="Rock; Alternative">
                            </div>
                            <div class="form-group">
                                <label>Style</label>
                                <input type="text" id="styleInline" placeholder="Indie Rock; Post-Punk">
                            </div>
                            <div class="form-group">
                                <label>Source / Reason</label>
                                <input type="text" id="reasonInline" placeholder="Manual or source lists">
                            </div>
                            <div class="form-group">
                                <label>Discogs URL</label>
                                <input type="url" id="discogsUrlInline" placeholder="https://www.discogs.com/...">
                            </div>
                            <div class="form-group">
                                <label>Score (0-10)</label>
                                <input type="number" id="scoreInline" min="0" max="10" step="0.1">
                            </div>
                        </div>
                        <button type="submit" class="btn" style="margin-top: 15px;">Add Album</button>
                    </form>
                </div>

                <div id="albumGrid" class="album-grid"></div>
            </div>

            <!-- Add Album Section (Hidden - replaced by inline form) -->
            <div id="add" class="section">
                <h2>Add New Album</h2>
                <form id="addAlbumForm" onsubmit="addAlbum(event)">
                    <div class="form-group">
                        <label>Album Name *</label>
                        <input type="text" id="albumName" required>
                    </div>
                    <div class="form-group">
                        <label>Artist *</label>
                        <input type="text" id="artist" required>
                    </div>
                    <div class="form-group">
                        <label>Artist ID</label>
                        <input type="text" id="artistId">
                    </div>
                    <div class="form-group">
                        <label>Year *</label>
                        <input type="number" id="year" min="1900" max="2100" required>
                    </div>
                    <div class="form-group">
                        <label>Album Artwork URL *</label>
                        <input type="url" id="artworkUrl" required placeholder="https://...">
                    </div>
                    <div class="form-group">
                        <label>Discogs URL</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="url" id="discogsUrl" placeholder="https://www.discogs.com/..." style="flex: 1;">
                            <button type="button" class="btn" onclick="fetchFromDiscogs()" style="white-space: nowrap;">Fetch from Discogs</button>
                        </div>
                        <small id="discogsStatus" style="color: #888; margin-top: 5px; display: block;"></small>
                    </div>
                    <div class="form-group">
                        <label>Genre (semicolon-separated for multiple)</label>
                        <input type="text" id="genre" placeholder="Rock; Alternative">
                    </div>
                    <div class="form-group">
                        <label>Style (semicolon-separated for multiple)</label>
                        <input type="text" id="style" placeholder="Indie Rock; Post-Punk">
                    </div>
                    <div class="form-group">
                        <label>Reason</label>
                        <input type="text" id="reason" value="Manual" placeholder="Manual or source lists separated by semicolons">
                    </div>
                    <div class="form-group">
                        <label>Score (0-10, leave empty if not rated)</label>
                        <input type="number" id="score" min="0" max="10" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Date Listened</label>
                        <input type="date" id="dateListened">
                    </div>
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="notes" placeholder="Your thoughts about this album..."></textarea>
                    </div>
                    <button type="submit" class="btn">Add Album</button>
                </form>
            </div>

            <!-- Import/Export Data Section -->
            <div id="import" class="section">
                <h2>Import/Export Album Data</h2>
                
                <!-- Export Section -->
                <div style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <h3 style="margin-bottom: 15px;"> Export Data</h3>
                    <p style="color: #666; margin-bottom: 15px;">Download your album collection as an Excel file</p>
                    <button class="btn btn-success" onclick="exportData()" style="font-size: 1.1em; padding: 12px 30px;">
                         Export to Excel
                    </button>
                </div>

                <!-- Import Section -->
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px;"> Import Data</h3>
                    <div class="alert alert-info">
                        <strong>Supported Format:</strong> Excel files (.xlsx, .xls) with columns: ID, Album Name, Artist, Year, Reason, Album Artwork URL, Discogs URL, Artist ID, Genre, Style, Score, Date Listened, Notes
                    </div>
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="importExcel(event)">
                        <p style="font-size: 3em; margin-bottom: 10px;"></p>
                        <p style="font-size: 1.2em; color: #667eea; font-weight: 600;">Click to upload Excel file</p>
                        <p style="color: #6c757d; margin-top: 10px;">Existing albums will be updated with new data</p>
                    </div>
                    <div id="importStatus"></div>
                </div>

                <!-- Template Download -->
                <div style="padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <h3 style="margin-bottom: 15px;"> Import Template</h3>
                    <p style="color: #666; margin-bottom: 15px;">Download a template with the correct column headers to get started</p>
                    <button class="btn btn-secondary" onclick="downloadImportTemplate()" style="font-size: 1.1em; padding: 12px 30px;">
                         Download Import Template
                    </button>
                </div>
            </div>

            <!-- Lists Section -->
            <div id="lists" class="section">
                <h2> Curated Album Lists</h2>
                <p style="color: #666; margin-bottom: 20px;">Discover and import notable album lists from critics, publications, and awards</p>
                
                <!-- Filters -->
                <div style="margin-bottom: 30px; padding: 20px; background: var(--card-bg); border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <h3 style="margin-bottom: 15px;"> Filter Lists</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <div class="form-group">
                            <label for="categoryFilter">Category</label>
                            <select id="categoryFilter" onchange="filterLists()" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                                <option value="">All Categories</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="sourceFilter">Source/Organization</label>
                            <select id="sourceFilter" onchange="filterLists()" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                                <option value="">All Sources</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="listSizeFilter">List Size</label>
                            <select id="listSizeFilter" onchange="filterLists()" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                                <option value="">All Sizes</option>
                                <option value="<50">< 50 albums</option>
                                <option value="50-100">50-100 albums</option>
                                <option value="100-500">100-500 albums</option>
                                <option value=">500">> 500 albums</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="genreFilter">Primary Genre(s)</label>
                            <input type="text" id="genreFilter" placeholder="e.g., Rock, Jazz, Hip-Hop" oninput="filterLists()" style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #ddd;">
                        </div>
                    </div>
                </div>

                <!-- Lists Display -->
                <div id="listsContainer" style="display: grid; gap: 20px;">
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <p style="font-size: 1.2em;">Loading curated lists...</p>
                    </div>
                </div>
            </div>

            <!-- Statistics Section -->
            <div id="stats" class="section">
                <h2>Statistics & Analytics</h2>
                <div id="statsContent"></div>
            </div>
        </div>
    </div>

    <!-- Album Detail Modal -->
    <div id="albumModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div id="albumModalContent"></div>
        </div>
    </div>

    <!-- Score Album Modal -->
    <div id="scoreModal" class="modal">
        <div class="modal-content" style="max-width: 500px;">
            <button class="modal-close" onclick="closeScoreModal()">&times;</button>
            <div id="scoreModalContent">
                <h2 style="margin-bottom: 20px;">Score Album</h2>
                <form id="scoreAlbumForm" onsubmit="submitScore(event)">
                    <div id="scoreAlbumInfo" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <!-- Album info will be inserted here -->
                    </div>
                    
                    <div class="form-group">
                        <label for="scoreInput">Score (0-10) *</label>
                        <input type="number" id="scoreInput" step="0.1" min="0" max="10" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="dateListenedInput">Date Listened</label>
                        <input type="date" id="dateListenedInput">
                    </div>
                    
                    <div class="form-group">
                        <label for="notesInput">Notes</label>
                        <textarea id="notesInput" rows="4" placeholder="Your thoughts about this album..."></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 20px;">
                        <button type="submit" class="btn" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">Save Score</button>
                        <button type="button" class="btn" onclick="closeScoreModal()" style="background: #6c757d;">Cancel</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- OneDrive Sync Status -->
    <!-- Settings Modal -->
    <div class="settings-modal" id="settingsModal">
        <div class="settings-content">
            <div class="settings-header">
                <h2> Settings</h2>
                <button onclick="closeSettings()" class="settings-close"></button>
            </div>
            <div class="settings-body">
                <!-- Discogs Integration Section -->
                <div class="settings-section">
                    <h3> Discogs Integration</h3>
                    <p>Enable auto-fill album details from Discogs when adding new albums.</p>
                    
                    <div class="settings-input-group">
                        <label for="discogsToken">API Token:</label>
                        <input 
                            type="text" 
                            id="discogsToken" 
                            placeholder="Paste your Discogs API token here"
                            autocomplete="off"
                        >
                    </div>
                    
                    <div class="settings-button-group">
                        <button onclick="saveDiscogsToken()" class="settings-btn settings-btn-primary">
                             Save Token
                        </button>
                        <button onclick="clearDiscogsToken()" class="settings-btn settings-btn-secondary">
                             Clear Token
                        </button>
                    </div>
                    
                    <div id="discogsStatus"></div>
                    
                    <button onclick="showDiscogsInstructions()" class="settings-btn settings-btn-link">
                         How to get your Discogs API token
                    </button>
                </div>
                
                <!-- Theme Customization Section -->
                <div class="settings-section">
                    <h3 class="collapsible-header" onclick="toggleCollapse('themeCustomization')">
                        <span class="collapse-icon collapsed" id="themeCustomizationIcon"></span>
                         Theme Customization
                    </h3>
                    
                    <div id="themeCustomization" class="collapsible-content collapsed">
                        <p>Choose your preferred color scheme for the app.</p>
                        
                        <div class="theme-grid">
                        <div class="theme-option" data-theme="purple" onclick="selectTheme('purple')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);"></div>
                            </div>
                            <div class="theme-name">Purple Haze</div>
                            <div class="theme-check" id="check-purple"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="ocean" onclick="selectTheme('ocean')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #2E3192 0%, #1BFFFF 100%);"></div>
                            </div>
                            <div class="theme-name">Ocean Blue</div>
                            <div class="theme-check" id="check-ocean"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="sunset" onclick="selectTheme('sunset')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #FF512F 0%, #F09819 100%);"></div>
                            </div>
                            <div class="theme-name">Sunset Orange</div>
                            <div class="theme-check" id="check-sunset"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="forest" onclick="selectTheme('forest')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #134E5E 0%, #71B280 100%);"></div>
                            </div>
                            <div class="theme-name">Forest Green</div>
                            <div class="theme-check" id="check-forest"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="rose" onclick="selectTheme('rose')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #C94B4B 0%, #4B134F 100%);"></div>
                            </div>
                            <div class="theme-name">Rose Garden</div>
                            <div class="theme-check" id="check-rose"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="midnight" onclick="selectTheme('midnight')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #232526 0%, #414345 100%);"></div>
                            </div>
                            <div class="theme-name">Midnight</div>
                            <div class="theme-check" id="check-midnight"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="cherry" onclick="selectTheme('cherry')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #EB3349 0%, #F45C43 100%);"></div>
                            </div>
                            <div class="theme-name">Cherry Red</div>
                            <div class="theme-check" id="check-cherry"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="lavender" onclick="selectTheme('lavender')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #868F96 0%, #596164 100%);"></div>
                            </div>
                            <div class="theme-name">Lavender Gray</div>
                            <div class="theme-check" id="check-lavender"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="minimal" onclick="selectTheme('minimal')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #f5f5f5 0%, #e0e0e0 100%);"></div>
                            </div>
                            <div class="theme-name">Minimalist White</div>
                            <div class="theme-check" id="check-minimal"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="contrast" onclick="selectTheme('contrast')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #ffffff 0%, #f0f0f0 100%);"></div>
                            </div>
                            <div class="theme-name">High Contrast</div>
                            <div class="theme-check" id="check-contrast"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="retro" onclick="selectTheme('retro')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #f4e4c1 0%, #d4a574 100%);"></div>
                            </div>
                            <div class="theme-name">Retro Vinyl</div>
                            <div class="theme-check" id="check-retro"></div>
                        </div>
                        
                        <div class="theme-option" data-theme="neon" onclick="selectTheme('neon')">
                            <div class="theme-preview">
                                <div class="theme-color" style="background: linear-gradient(135deg, #1a0033 0%, #330066 100%);"></div>
                            </div>
                            <div class="theme-name">Neon Nights</div>
                            <div class="theme-check" id="check-neon"></div>
                        </div>
                    </div>
                    
                    <!-- Custom Theme Creator -->
                    <div class="custom-theme-creator" style="margin-top: 30px; padding: 20px; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <h4 style="margin-bottom: 10px; color: #212529;"> Create Custom Theme</h4>
                        <p style="color: #6c757d; margin-bottom: 20px; font-size: 14px;">
                            Choose your own colors to create a unique theme.
                        </p>
                        
                        <!-- Header Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Header Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Gradient Start (Left)</label>
                                <input type="color" id="customGradientStart" value="#134E5E"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Gradient End (Right)</label>
                                <input type="color" id="customGradientEnd" value="#71B280"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Header Text</label>
                                <input type="color" id="customHeaderText" value="#ffffff"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Subheader Text</label>
                                <input type="color" id="customSubheaderText" value="#e0e0e0"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        <!-- Content Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Content Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Background</label>
                                <input type="color" id="customContentBg" value="#ffffff"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Text</label>
                                <input type="color" id="customContentText" value="#333333"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        <!-- Card Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Card Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Background</label>
                                <input type="color" id="customCardBg" value="#f8f9ff"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Text</label>
                                <input type="color" id="customCardText" value="#333333"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        <!-- Modal Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Modal Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Background</label>
                                <input type="color" id="customModalBg" value="#ffffff"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Text</label>
                                <input type="color" id="customModalText" value="#333333"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        <!-- Chart Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Chart Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Background</label>
                                <input type="color" id="customChartBg" value="#fafbff"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Text</label>
                                <input type="color" id="customChartText" value="#333333"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        <!-- Button Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Button Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Background</label>
                                <input type="color" id="customButtonBg" value="#667eea"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Hover</label>
                                <input type="color" id="customButtonHover" value="#764ba2"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        <!-- Border Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <h5 style="color: #495057; margin-bottom: 15px; font-size: 14px; font-weight: 600;"> Border Colors</h5>
                            
                            <div style="margin-bottom: 15px;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Normal</label>
                                <input type="color" id="customBorderColor" value="#e0e0e0"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                            
                            <div style="margin-bottom: 0;">
                                <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #212529;">Hover</label>
                                <input type="color" id="customBorderHover" value="#667eea"
                                       style="width: 100%; height: 50px; border: 2px solid #e0e0e0; border-radius: 8px; cursor: pointer;">
                            </div>
                        </div>
                        
                        </div>
                        
                        <!-- Button Section -->
                        <div style="display: flex; gap: 10px; margin-top: 20px;">
                            <button onclick="applyCustomTheme()" class="settings-btn settings-btn-primary" style="flex: 1;">
                                 Apply Custom Theme
                            </button>
                            <button onclick="resetToDefault()" class="settings-btn settings-btn-secondary">
                                 Reset
                            </button>
                        </div>
                        
                        <!-- Save Custom Theme Section -->
                        <div style="margin-top: 30px; padding-top: 30px; border-top: 2px solid #e0e0e0;">
                            <h4 style="margin-bottom: 10px; color: #212529;"> Save Custom Theme</h4>
                            <p style="color: #6c757d; margin-bottom: 15px; font-size: 14px;">
                                Save your custom theme with a name (up to 3 saved themes)
                            </p>
                            
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <input type="text" id="customThemeName" placeholder="Enter theme name..." 
                                       maxlength="20"
                                       style="flex: 1; padding: 10px; border: 2px solid #e0e0e0; border-radius: 8px; font-size: 14px;">
                                <button onclick="saveNamedCustomTheme()" class="settings-btn settings-btn-primary">
                                     Save
                                </button>
                            </div>
                            
                            <div id="savedThemesList" style="display: grid; gap: 10px;">
                                <!-- Saved themes will appear here -->
                            </div>
                        </div>
                    </div> <!-- End custom-theme-creator -->
                    
                    <!-- OneDrive Sync Section -->
                    <div class="settings-section">
                        <h3> OneDrive Sync</h3>
                        <p>Sync your album collection across devices using Microsoft OneDrive.</p>
                        
                        <div id="oneDriveSettingsStatus"></div>
                        
                        <div class="settings-button-group" id="oneDriveSettingsButtons">
                            <!-- Buttons will be populated by JavaScript -->
                        </div>
                    </div>
                    
                    <!-- Data Management Section -->
                    <div class="settings-section">
                        <h3> Data Management</h3>
                        <p>Manage your local album data and backups.</p>
                        
                        <div class="settings-button-group">
                            <button onclick="exportBackup()" class="settings-btn settings-btn-secondary">
                                 Export Backup
                            </button>
                            <button onclick="confirmClearData()" class="settings-btn settings-btn-secondary">
                                 Clear All Data
                            </button>
                        </div>
                        
                        <div class="settings-button-group" style="margin-top: 15px;">
                            <button onclick="openDuplicateCleanup()" class="settings-btn settings-btn-secondary">
                                 Clean Up Duplicate Albums
                            </button>
                            <button onclick="cleanupIDs()" class="settings-btn settings-btn-secondary">
                                 Clean Up IDs
                            </button>
                        </div>
                    </div>
                    
                    </div> <!-- End collapsible-content -->
                </div> <!-- End Theme Customization settings-section -->
            </div> <!-- End settings-body -->
        </div> <!-- End settings-content -->
    </div> <!-- End settings-modal -->
    
    <!-- Instructions Modal -->
    <div class="instructions-modal" id="instructionsModal">
        <div class="instructions-content">
            <div class="instructions-header">
                <h2>How to Get Your Discogs API Token</h2>
                <button onclick="closeInstructions()" class="settings-close"></button>
            </div>
            <div class="instructions-body">
                <div class="instruction-step">
                    <div class="instruction-number">1</div>
                    <div class="instruction-text">
                        <p><strong>Go to Discogs Settings</strong></p>
                        <p>Click the button below to open Discogs Developer Settings in a new tab.</p>
                        <a href="https://www.discogs.com/settings/developers" target="_blank" class="instruction-link">
                            Open Discogs Settings 
                        </a>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-number">2</div>
                    <div class="instruction-text">
                        <p><strong>Generate a New Token</strong></p>
                        <p>On the Developers page, click "Generate new token" button.</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-number">3</div>
                    <div class="instruction-text">
                        <p><strong>Copy the Token</strong></p>
                        <p>Discogs will display your new token. Copy it to your clipboard.</p>
                    </div>
                </div>
                
                <div class="instruction-step">
                    <div class="instruction-number">4</div>
                    <div class="instruction-text">
                        <p><strong>Paste in Settings</strong></p>
                        <p>Return to this app, paste the token in the Settings, and click "Save Token".</p>
                    </div>
                </div>
                
                <div class="instruction-note">
                    <strong> Privacy & Security</strong>
                    <p>Your API token is stored locally on your device only. It's never sent to anyone except Discogs when you use the "Find on Discogs" feature.</p>
                    <p> Keep your token private! Don't share it with others. You can revoke and regenerate it anytime on Discogs.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Discogs Results Modal -->
    <div class="modal" id="discogsResultsModal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>Select the Correct Album</h2>
                <button onclick="closeDiscogsResults()" class="modal-close"></button>
            </div>
            <div class="modal-body">
                <p style="color: #666; margin-bottom: 20px;">Found multiple versions. Select the one that matches your album:</p>
                <div id="discogsResultsList" style="max-height: 500px; overflow-y: auto;"></div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: flex-end;">
                <button class="btn btn-secondary" onclick="openDiscogsManually()"> Search on Discogs</button>
                <button class="btn btn-secondary" onclick="closeDiscogsResults()">Manual Entry</button>
            </div>
        </div>
    </div>

    <!-- Duplicate Cleanup Modal -->
    <div class="modal" id="duplicateCleanupModal">
        <div class="modal-content" style="max-width: 1000px;">
            <div class="modal-header">
                <h2> Clean Up Duplicate Albums</h2>
                <button onclick="closeDuplicateCleanup()" class="modal-close"></button>
            </div>
            <div class="modal-body">
                <div id="duplicateCleanupContent">
                    <p style="color: #666; margin-bottom: 20px;">Scanning for duplicate albums...</p>
                </div>
            </div>
            <div class="modal-footer" style="display: flex; gap: 10px; justify-content: space-between;">
                <button class="btn btn-secondary" onclick="closeDuplicateCleanup()">Cancel</button>
                <button class="btn btn-danger" id="deleteDuplicatesBtn" onclick="deleteDuplicates()" style="display: none;">
                     Delete Selected Duplicates
                </button>
            </div>
        </div>
    </div>

    <div class="sync-status" id="syncStatus" onclick="toggleSyncMenu()">
        <div class="sync-indicator offline" id="syncIndicator"></div>
        <div id="syncText">
            <span class="sync-main-text">Offline Mode</span>
        </div>
    </div>

    <!-- Sync Menu -->
    <div class="sync-menu" id="syncMenu">
        <div id="syncMenuContent"></div>
    </div>

    <!-- Include SheetJS library for Excel parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // Database Management
        class AlbumDatabase {
            constructor() {
                this.albums = this.loadFromStorage();
            }

            loadFromStorage() {
                const data = localStorage.getItem('albumTrackerData');
                return data ? JSON.parse(data) : [];
            }

            saveToStorage() {
                localStorage.setItem('albumTrackerData', JSON.stringify(this.albums));
            }

            addAlbum(album) {
                // If album has an ID, check if it already exists
                if (album.id) {
                    const existingIndex = this.albums.findIndex(a => a.id === album.id);
                    if (existingIndex !== -1) {
                        // Overwrite existing album with same ID
                        this.albums[existingIndex] = album;
                        this.saveToStorage();
                        return album;
                    }
                }
                
                // Generate new ID if not provided or doesn't exist
                const id = this.albums.length > 0 ? Math.max(...this.albums.map(a => a.id)) + 1 : 1;
                album.id = id;
                this.albums.push(album);
                this.saveToStorage();
                return album;
            }

            updateAlbum(id, updates) {
                const index = this.albums.findIndex(a => a.id === id);
                if (index !== -1) {
                    this.albums[index] = { ...this.albums[index], ...updates };
                    this.saveToStorage();
                    return this.albums[index];
                }
                return null;
            }

            deleteAlbum(id) {
                this.albums = this.albums.filter(a => a.id !== id);
                this.saveToStorage();
            }

            getAlbum(id) {
                return this.albums.find(a => a.id === id);
            }

            getAllAlbums() {
                return this.albums;
            }

            isDuplicate(albumName, artist) {
                return this.albums.some(a => 
                    String(a.albumName).toLowerCase() === String(albumName).toLowerCase() && 
                    String(a.artist).toLowerCase() === String(artist).toLowerCase()
                );
            }

            importAlbums(newAlbums) {
                let added = 0;
                let updated = 0;
                let skipped = 0;

                // Create a lookup map for faster duplicate checking
                const albumMap = new Map();
                this.albums.forEach(album => {
                    const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                    albumMap.set(key, album);
                });

                // Process in batches to avoid memory issues
                const BATCH_SIZE = 100;
                for (let i = 0; i < newAlbums.length; i += BATCH_SIZE) {
                    const batch = newAlbums.slice(i, i + BATCH_SIZE);
                    
                    batch.forEach(album => {
                        // Skip albums with truly empty names (but allow "0" or other falsy values that are valid)
                        if (album.albumName === '' || album.albumName === null || album.albumName === undefined) {
                            skipped++;
                            return;
                        }

                        // Check if album already exists using the map
                        const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                        const existingAlbum = albumMap.get(key);

                        if (existingAlbum) {
                            // Update existing album with new data (only if new data is provided)
                            const updates = {};
                            if (album.score !== null && album.score !== undefined && album.score !== '') updates.score = album.score;
                            if (album.dateListened) updates.dateListened = album.dateListened;
                            if (album.notes) updates.notes = album.notes;
                            if (album.artworkUrl) updates.artworkUrl = album.artworkUrl;
                            if (album.discogsUrl) updates.discogsUrl = album.discogsUrl;
                            if (album.genre) updates.genre = album.genre;
                            if (album.style) updates.style = album.style;
                            if (album.year) updates.year = album.year;
                            if (album.artistId) updates.artistId = album.artistId;
                            
                            // Merge reasons (source lists) if new ones are provided
                            if (album.reason && album.reason !== 'Manual') {
                                const existingReasons = this.parseMultiValue(existingAlbum.reason);
                                const newReasons = this.parseMultiValue(album.reason);
                                const mergedReasons = [...new Set([...existingReasons, ...newReasons])];
                                updates.reason = mergedReasons.join('; ');
                            }

                            if (Object.keys(updates).length > 0) {
                                this.updateAlbum(existingAlbum.id, updates);
                                updated++;
                            } else {
                                skipped++;
                            }
                        } else {
                            const newAlbum = this.addAlbum(album);
                            // Add to map for subsequent batches
                            albumMap.set(key, newAlbum);
                            added++;
                        }
                    });
                    
                    // Save after each batch to prevent memory buildup
                    this.saveToStorage();
                }

                return { added, updated, skipped };
            }

            // Async version of importAlbums with progress callback
            async importAlbumsAsync(newAlbums, progressCallback) {
                let added = 0;
                let updated = 0;
                let skipped = 0;

                // Create a map of existing albums for faster lookup
                const albumMap = new Map();
                this.albums.forEach(album => {
                    const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                    albumMap.set(key, album);
                });

                // Process in smaller batches with async breaks to prevent timeout
                const BATCH_SIZE = 50; // Smaller batches for better UI responsiveness
                const PROGRESS_UPDATE_INTERVAL = 100; // Update progress every 100 albums
                
                for (let i = 0; i < newAlbums.length; i += BATCH_SIZE) {
                    const batch = newAlbums.slice(i, i + BATCH_SIZE);
                    
                    batch.forEach(album => {
                        // Skip albums with truly empty names
                        if (album.albumName === '' || album.albumName === null || album.albumName === undefined) {
                            skipped++;
                            return;
                        }

                        // Check if album already exists using the map
                        const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                        const existingAlbum = albumMap.get(key);

                        if (existingAlbum) {
                            // Update existing album with new data - only if values are different
                            const updates = {};
                            
                            // Update score if new value exists and is different
                            if (album.score !== null && album.score !== undefined && album.score !== '' && album.score !== existingAlbum.score) {
                                updates.score = album.score;
                            }
                            
                            // Update dateListened if new value exists and is different
                            if (album.dateListened && album.dateListened !== existingAlbum.dateListened) {
                                updates.dateListened = album.dateListened;
                            }
                            
                            // Update notes if new value exists and is different
                            if (album.notes && album.notes !== existingAlbum.notes) {
                                updates.notes = album.notes;
                            }
                            
                            // Update artworkUrl if new value exists and is different
                            if (album.artworkUrl && album.artworkUrl !== existingAlbum.artworkUrl) {
                                updates.artworkUrl = album.artworkUrl;
                            }
                            
                            // Update discogsUrl if new value exists and is different
                            if (album.discogsUrl && album.discogsUrl !== existingAlbum.discogsUrl) {
                                updates.discogsUrl = album.discogsUrl;
                            }
                            
                            // Update genre if new value exists and is different
                            if (album.genre && album.genre !== existingAlbum.genre) {
                                updates.genre = album.genre;
                            }
                            
                            // Update style if new value exists and is different
                            if (album.style && album.style !== existingAlbum.style) {
                                updates.style = album.style;
                            }
                            
                            // Update year if new value exists and is different
                            if (album.year && album.year !== existingAlbum.year) {
                                updates.year = album.year;
                            }
                            
                            // Update artistId if new value exists and is different
                            if (album.artistId && album.artistId !== existingAlbum.artistId) {
                                updates.artistId = album.artistId;
                            }
                            
                            // Merge reasons (source lists)
                            if (album.reason && album.reason !== 'Manual') {
                                const existingReasons = this.parseMultiValue(existingAlbum.reason);
                                const newReasons = this.parseMultiValue(album.reason);
                                const mergedReasons = [...new Set([...existingReasons, ...newReasons])];
                                const mergedReason = mergedReasons.join('; ');
                                if (mergedReason !== existingAlbum.reason) {
                                    updates.reason = mergedReason;
                                }
                            }

                            if (Object.keys(updates).length > 0) {
                                this.updateAlbum(existingAlbum.id, updates);
                                updated++;
                            } else {
                                skipped++;
                            }
                        } else {
                            const newAlbum = this.addAlbum(album);
                            albumMap.set(key, newAlbum);
                            added++;
                        }
                    });
                    
                    // Save after each batch
                    this.saveToStorage();
                    
                    // Update progress callback
                    if (progressCallback && (i % PROGRESS_UPDATE_INTERVAL === 0 || i + BATCH_SIZE >= newAlbums.length)) {
                        progressCallback({
                            processed: Math.min(i + BATCH_SIZE, newAlbums.length),
                            total: newAlbums.length,
                            added,
                            updated,
                            skipped
                        });
                    }
                    
                    // Yield to browser to prevent freezing (every batch)
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                return { added, updated, skipped };
            }

            // Parse semicolon-separated fields
            parseMultiValue(value, isGenre = false) {
                if (!value) return [];
                
                // For genres, handle both semicolons and commas, but preserve "Folk, World, & Country"
                if (isGenre) {
                    // First, protect "Folk, World, & Country" by temporarily replacing it
                    const protectedValue = value.replace(/Folk,\s*World,\s*&\s*Country/gi, '___FOLK_WORLD_COUNTRY___');
                    
                    // Split by both semicolons and commas
                    const parts = protectedValue.split(/[;,]/).map(v => v.trim()).filter(v => v);
                    
                    // Restore the protected genre
                    return parts.map(part => part.replace(/___FOLK_WORLD_COUNTRY___/g, 'Folk, World, & Country'));
                }
                
                // For non-genres (sources, styles), use semicolon only
                return value.split(';').map(v => v.trim()).filter(v => v);
            }

            // Parse artist names - handles multiple artists intelligently
            // Artists can contain commas (e.g., "Earth, Wind & Fire")
            // So we only split on " & ", " and ", or semicolons
            parseArtists(value) {
                if (!value) return [value]; // Return original if empty
                
                // Split by semicolons first (explicit separator)
                const parts = value.split(';').map(v => v.trim()).filter(v => v);
                
                // Then split each part by " & " or " and " (but not commas)
                const artists = [];
                parts.forEach(part => {
                    // Split by " & " or " and " (case insensitive)
                    const subParts = part.split(/\s+(?:&|and)\s+/i).map(v => v.trim()).filter(v => v);
                    artists.push(...subParts);
                });
                
                return artists.length > 0 ? artists : [value];
            }

            // Get all unique genres
            getAllGenres() {
                const genres = new Set();
                this.albums.forEach(album => {
                    this.parseMultiValue(album.genre, true).forEach(g => genres.add(g));
                });
                return Array.from(genres).sort();
            }

            // Get all unique source lists
            getAllSources() {
                const sources = new Set();
                this.albums.forEach(album => {
                    if (album.reason && album.reason !== 'Manual') {
                        this.parseMultiValue(album.reason).forEach(s => sources.add(s));
                    }
                });
                return Array.from(sources).sort();
            }

            // Get all unique styles
            getAllStyles() {
                const styles = new Set();
                this.albums.forEach(album => {
                    this.parseMultiValue(album.style).forEach(s => styles.add(s));
                });
                return Array.from(styles).sort();
            }

            // Filter albums
            filterAlbums(filters) {
                return this.albums.filter(album => {
                    // Text search filter
                    if (filters.searchText) {
                        const searchLower = filters.searchText.toLowerCase();
                        
                        // Helper function to safely convert to string
                        const toString = (value) => {
                            if (value === null || value === undefined) return '';
                            if (typeof value === 'string') return value;
                            return String(value);
                        };
                        
                        const albumName = toString(album.albumName).toLowerCase();
                        const artist = toString(album.artist).toLowerCase();
                        const genre = toString(album.genre).toLowerCase();
                        const reason = toString(album.reason).toLowerCase();
                        
                        // Check if search text is found in any of these fields
                        const matchFound = albumName.includes(searchLower) || 
                                         artist.includes(searchLower) || 
                                         genre.includes(searchLower) || 
                                         reason.includes(searchLower);
                        
                        if (!matchFound) return false;
                    }

                    // Genre filter
                    if (filters.genre) {
                        const genres = this.parseMultiValue(album.genre, true);
                        if (!genres.includes(filters.genre)) return false;
                    }

                    // Source filter
                    if (filters.source) {
                        const sources = this.parseMultiValue(album.reason);
                        if (!sources.includes(filters.source)) return false;
                    }

                    // Status filter
                    if (filters.status === 'listened' && !album.dateListened) return false;
                    if (filters.status === 'unlistened' && album.dateListened) return false;

                    // Score range filter
                    if (filters.minScore !== undefined && (album.score === null || album.score < filters.minScore)) return false;
                    if (filters.maxScore !== undefined && (album.score === null || album.score > filters.maxScore)) return false;

                    return true;
                });
            }

            // Sort albums
            sortAlbums(albums, sortBy) {
                const sorted = [...albums];
                switch (sortBy) {
                    case 'name-asc':
                        return sorted.sort((a, b) => String(a.albumName).localeCompare(String(b.albumName)));
                    case 'name-desc':
                        return sorted.sort((a, b) => String(b.albumName).localeCompare(String(a.albumName)));
                    case 'artist-asc':
                        return sorted.sort((a, b) => String(a.artist).localeCompare(String(b.artist)));
                    case 'artist-desc':
                        return sorted.sort((a, b) => String(b.artist).localeCompare(String(a.artist)));
                    case 'score-desc':
                        return sorted.sort((a, b) => (b.score || 0) - (a.score || 0));
                    case 'score-asc':
                        return sorted.sort((a, b) => (a.score || 0) - (b.score || 0));
                    case 'date-desc':
                        return sorted.sort((a, b) => {
                            if (!a.dateListened) return 1;
                            if (!b.dateListened) return -1;
                            return new Date(b.dateListened) - new Date(a.dateListened);
                        });
                    case 'date-asc':
                        return sorted.sort((a, b) => {
                            if (!a.dateListened) return 1;
                            if (!b.dateListened) return -1;
                            return new Date(a.dateListened) - new Date(b.dateListened);
                        });
                    default:
                        return sorted;
                }
            }

            // Get random unscored album
            getRandomUnscoredAlbum() {
                const unscored = this.albums.filter(a => a.score === null || a.score === undefined || a.score === '');
                if (unscored.length === 0) return null;
                return unscored[Math.floor(Math.random() * unscored.length)];
            }

            // Statistics methods
            getMonthlyStats() {
                const stats = {};
                this.albums.forEach(album => {
                    if (album.dateListened) {
                        const date = new Date(album.dateListened);
                        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        if (!stats[key]) {
                            stats[key] = { count: 0, scores: [] };
                        }
                        stats[key].count++;
                        if (album.score !== null && album.score !== undefined && album.score !== '') {
                            stats[key].scores.push(parseFloat(album.score));
                        }
                    }
                });
                return stats;
            }

            getYearlyStats() {
                const stats = {};
                this.albums.forEach(album => {
                    if (album.dateListened) {
                        const date = new Date(album.dateListened);
                        const key = String(date.getFullYear());
                        if (!stats[key]) {
                            stats[key] = { count: 0, scores: [] };
                        }
                        stats[key].count++;
                        if (album.score !== null && album.score !== undefined && album.score !== '') {
                            stats[key].scores.push(parseFloat(album.score));
                        }
                    }
                });
                return stats;
            }

            getAverageScoreByArtist() {
                const artistScores = {};
                this.albums.forEach(album => {
                    if (album.score !== null && album.score !== undefined && album.score !== '') {
                        if (!artistScores[album.artist]) {
                            artistScores[album.artist] = [];
                        }
                        artistScores[album.artist].push(parseFloat(album.score));
                    }
                });

                const averages = {};
                Object.keys(artistScores).forEach(artist => {
                    const scores = artistScores[artist];
                    averages[artist] = {
                        average: scores.reduce((a, b) => a + b, 0) / scores.length,
                        count: scores.length
                    };
                });

                return Object.entries(averages)
                    .sort((a, b) => b[1].average - a[1].average)
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }

            getAverageScoreByGenre() {
                const genreScores = {};
                this.albums.forEach(album => {
                    if (album.score !== null && album.score !== undefined && album.score !== '') {
                        const genres = this.parseMultiValue(album.genre, true);
                        genres.forEach(genre => {
                            if (!genreScores[genre]) {
                                genreScores[genre] = [];
                            }
                            genreScores[genre].push(parseFloat(album.score));
                        });
                    }
                });

                const averages = {};
                Object.keys(genreScores).forEach(genre => {
                    const scores = genreScores[genre];
                    averages[genre] = scores.reduce((a, b) => a + b, 0) / scores.length;
                });

                return Object.entries(averages)
                    .sort((a, b) => b[1] - a[1])
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }

            getSourceListStats() {
                const sources = this.getAllSources();
                const stats = {};

                sources.forEach(source => {
                    const albums = this.albums.filter(album => {
                        const albumSources = this.parseMultiValue(album.reason);
                        return albumSources.includes(source);
                    });

                    const listened = albums.filter(a => a.dateListened).length;
                    const scored = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '');
                    const avgScore = scored.length > 0 
                        ? scored.reduce((sum, a) => sum + parseFloat(a.score), 0) / scored.length 
                        : null;

                    stats[source] = {
                        total: albums.length,
                        listened,
                        avgScore
                    };
                });

                return stats;
            }

            getGenreCounts() {
                const genreCounts = {};
                this.albums.forEach(album => {
                    const genres = this.parseMultiValue(album.genre, true);
                    genres.forEach(genre => {
                        if (!genreCounts[genre]) {
                            genreCounts[genre] = 0;
                        }
                        genreCounts[genre]++;
                    });
                });

                return Object.entries(genreCounts)
                    .sort((a, b) => b[1] - a[1])
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }
        }

        // OneDrive Sync Manager
        class OneDriveSyncManager {
            constructor() {
                // IMPORTANT: Replace this with your own Azure App Registration Client ID
                // Instructions: https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app
                
                // Your Azure App Registration Client ID
                this.clientId = 'b19c334e-f1e3-432d-9d79-c50a88eeef0f';
                
                // Redirect URI - automatically detect the current URL
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scopes = ['Files.ReadWrite', 'offline_access'];
                this.fileName = 'album-tracker-data.json';
                this.folderName = 'AlbumTracker';
                
                // Log setup instructions with the actual redirect URI
                console.log('');
                console.log('');
                console.log('                    AZURE SETUP REQUIRED                  ');
                console.log('');
                console.log('');
                console.log(' STEP 1: COPY THIS REDIRECT URI (select and copy):');
                console.log('');
                console.log('   http://localhost');
                console.log('');
                console.log(' STEP 2: ADD TO AZURE PORTAL:');
                console.log('');
                console.log('   1. Go to: https://portal.azure.com');
                console.log('   2. Find app: b19c334e-f1e3-432d-9d79-c50a88eeef0f');
                console.log('   3. Click: Authentication (left sidebar)');
                console.log('   4. Scroll to: "Single-page application"');
                console.log('   5. Click: "Add URI"');
                console.log('   6. Paste: http://localhost');
                console.log('   7. Scroll to: "Implicit grant and hybrid flows"');
                console.log('   8. Check:  Access tokens');
                console.log('   9. Check:  ID tokens');
                console.log('   10. Click: Save');
                console.log('');
                console.log('');
                console.log('  After setup, click the sync indicator to connect OneDrive   ');
                console.log('');
                console.log('');
                
                this.accessToken = localStorage.getItem('onedrive_access_token');
                this.refreshToken = localStorage.getItem('onedrive_refresh_token');
                this.tokenExpiry = localStorage.getItem('onedrive_token_expiry');
                
                this.syncInProgress = false;
                this.lastSyncTime = localStorage.getItem('last_sync_time');
                
                this.updateUI();
                
                // Check if we're returning from OAuth
                this.handleOAuthCallback();
                
                // Auto-sync on load if connected
                if (this.isConnected()) {
                    this.syncFromOneDrive();
                }
            }

            isConnected() {
                return !!this.accessToken && new Date().getTime() < parseInt(this.tokenExpiry || '0');
            }

            async ensureValidToken() {
                if (!this.accessToken) {
                    throw new Error('Not authenticated');
                }

                // Check if token is expired or will expire in next 5 minutes
                const now = new Date().getTime();
                const expiry = parseInt(this.tokenExpiry || '0');
                
                if (now >= expiry - 300000) { // 5 minutes before expiry
                    await this.refreshAccessToken();
                }
            }

            async refreshAccessToken() {
                if (!this.refreshToken) {
                    throw new Error('No refresh token available');
                }

                try {
                    const response = await fetch('https://login.microsoftonline.com/consumers/oauth2/v2.0/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: this.scopes.join(' '),
                            refresh_token: this.refreshToken,
                            grant_type: 'refresh_token'
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to refresh token');
                    }

                    const data = await response.json();
                    this.saveTokens(data);
                } catch (error) {
                    console.error('Token refresh failed:', error);
                    this.disconnect();
                    throw error;
                }
            }

            connectToOneDrive() {
                // Check if client ID is configured
                if (this.clientId === 'YOUR_CLIENT_ID_HERE') {
                    alert('OneDrive integration requires setup!\n\nPlease follow these steps:\n\n1. Go to Azure Portal (portal.azure.com)\n2. Register a new app\n3. Get your Client ID\n4. Replace YOUR_CLIENT_ID_HERE in the code\n\nSee the console for more details.');
                    console.log('%cOneDrive Setup Instructions:', 'font-size: 16px; font-weight: bold; color: #0078d4;');
                    console.log('1. Go to https://portal.azure.com');
                    console.log('2. Navigate to "Azure Active Directory" > "App registrations" > "New registration"');
                    console.log('3. Name: "Album Tracker"');
                    console.log('4. Supported account types: "Personal Microsoft accounts only"');
                    console.log('5. Redirect URI: "Single-page application (SPA)" - http://localhost');
                    console.log('6. After registration, copy the "Application (client) ID"');
                    console.log('7. Go to "API permissions" > "Add a permission" > "Microsoft Graph" > "Delegated permissions"');
                    console.log('8. Add: Files.ReadWrite and offline_access');
                    console.log('9. Replace YOUR_CLIENT_ID_HERE in the code with your Client ID');
                    console.log('10. Under "Authentication", enable "Access tokens" and "ID tokens" in Implicit grant section');
                    return;
                }

                console.log('Redirect URI: http://localhost');
                console.log('Please add this exact URI to your Azure app registration under Authentication > Single-page application');

                // Show helpful instructions
                const proceed = confirm(
                    'Important:\n\n' +
                    '1. You\'ll be redirected to Microsoft login\n' +
                    '2. After login, you\'ll be sent to http://localhost\n' +
                    '3. IMPORTANT: After redirect, manually open this site again\n' +
                    '4. The app will detect your login and connect automatically\n\n' +
                    ' Make sure you\'ve added "http://localhost" to your Azure app\'s redirect URIs!\n\n' +
                    'Click OK to continue to Microsoft login.'
                );

                if (!proceed) {
                    return;
                }

                // Use implicit flow with token response (works for local files)
                // Use 'consumers' to force personal Microsoft accounts only
                const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                    `client_id=${this.clientId}` +
                    `&response_type=token` +
                    `&redirect_uri=${encodeURIComponent(this.redirectUri)}` +
                    `&response_mode=fragment` +
                    `&scope=${encodeURIComponent(this.scopes.join(' '))}` +
                    `&state=${Date.now()}` +
                    `&prompt=select_account`;

                // Redirect in the same window (works better for local files)
                window.location.href = authUrl;
            }

            async handleOAuthCallback() {
                // Check for implicit flow token in URL fragment (hash)
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const accessToken = params.get('access_token');
                const expiresIn = params.get('expires_in');

                if (accessToken) {
                    try {
                        this.updateUI('syncing', 'Connecting to OneDrive...');
                        
                        // Save the token (implicit flow doesn't provide refresh token)
                        const tokenData = {
                            access_token: accessToken,
                            expires_in: parseInt(expiresIn) || 3600,
                            refresh_token: null // Implicit flow doesn't provide refresh tokens
                        };
                        
                        this.saveTokens(tokenData);

                        // Clean URL (remove hash)
                        window.history.replaceState({}, document.title, window.location.pathname);

                        // Sync data
                        await this.syncFromOneDrive();
                        
                        showAlert('success', 'Connected to OneDrive successfully!');
                    } catch (error) {
                        console.error('OAuth callback error:', error);
                        showAlert('error', 'Failed to connect to OneDrive');
                        this.updateUI('offline', 'Offline Mode');
                    }
                }
            }

            saveTokens(data) {
                this.accessToken = data.access_token;
                this.refreshToken = data.refresh_token;
                const expiresIn = data.expires_in || 3600;
                this.tokenExpiry = (new Date().getTime() + (expiresIn * 1000)).toString();

                localStorage.setItem('onedrive_access_token', this.accessToken);
                localStorage.setItem('onedrive_refresh_token', this.refreshToken);
                localStorage.setItem('onedrive_token_expiry', this.tokenExpiry);

                this.updateUI('connected', 'Connected to OneDrive');
            }

            disconnect() {
                this.accessToken = null;
                this.refreshToken = null;
                this.tokenExpiry = null;

                localStorage.removeItem('onedrive_access_token');
                localStorage.removeItem('onedrive_refresh_token');
                localStorage.removeItem('onedrive_token_expiry');
                localStorage.removeItem('last_sync_time');

                this.updateUI('offline', 'Offline Mode');
                showAlert('info', 'Disconnected from OneDrive');
            }

            async syncToOneDrive() {
                if (!this.isConnected()) {
                    throw new Error('Not connected to OneDrive');
                }

                if (this.syncInProgress) {
                    return;
                }

                try {
                    this.syncInProgress = true;
                    this.updateUI('syncing', 'Syncing to OneDrive...');

                    await this.ensureValidToken();

                    // Get current data
                    const data = db.getAllAlbums();
                    const jsonData = JSON.stringify(data, null, 2);

                    // Get or create folder
                    const folderId = await this.ensureFolder();

                    // Check if file exists
                    const fileId = await this.getFileId(folderId);

                    if (fileId) {
                        // Update existing file
                        await this.updateFile(fileId, jsonData);
                    } else {
                        // Create new file
                        await this.createFile(folderId, jsonData);
                    }

                    this.lastSyncTime = new Date().toISOString();
                    localStorage.setItem('last_sync_time', this.lastSyncTime);

                    this.updateUI('connected', 'Synced to OneDrive');
                    setTimeout(() => this.updateUI(), 2000);

                } catch (error) {
                    console.error('Sync to OneDrive failed:', error);
                    this.updateUI('error', 'Sync failed');
                    setTimeout(() => this.updateUI(), 3000);
                    throw error;
                } finally {
                    this.syncInProgress = false;
                }
            }

            async syncFromOneDrive() {
                if (!this.isConnected()) {
                    throw new Error('Not connected to OneDrive');
                }

                if (this.syncInProgress) {
                    return;
                }

                try {
                    this.syncInProgress = true;
                    this.updateUI('syncing', 'Loading from OneDrive...');

                    await this.ensureValidToken();

                    // Get or create folder
                    const folderId = await this.ensureFolder();

                    // Check if file exists
                    const fileId = await this.getFileId(folderId);

                    if (fileId) {
                        // Download and merge data
                        const data = await this.downloadFile(fileId);
                        
                        if (data && Array.isArray(data)) {
                            // Merge with local data
                            const localAlbums = db.getAllAlbums();
                            const mergedData = this.mergeAlbumData(localAlbums, data);
                            
                            // Update database
                            db.albums = mergedData;
                            db.saveToStorage();

                            this.lastSyncTime = new Date().toISOString();
                            localStorage.setItem('last_sync_time', this.lastSyncTime);

                            this.updateUI('connected', 'Loaded from OneDrive');
                            
                            // Refresh UI if on browse section
                            if (document.getElementById('browse').classList.contains('active')) {
                                loadBrowseSection();
                            }
                        }
                    } else {
                        // No file exists, upload current data
                        await this.syncToOneDrive();
                    }

                    setTimeout(() => this.updateUI(), 2000);

                } catch (error) {
                    console.error('Sync from OneDrive failed:', error);
                    this.updateUI('error', 'Sync failed');
                    setTimeout(() => this.updateUI(), 3000);
                    throw error;
                } finally {
                    this.syncInProgress = false;
                }
            }

            mergeAlbumData(localAlbums, remoteAlbums) {
                const merged = new Map();

                // Add all local albums
                localAlbums.forEach(album => {
                    const key = `${album.albumName}|${album.artist}`;
                    merged.set(key, album);
                });

                // Merge remote albums
                remoteAlbums.forEach(album => {
                    const key = `${album.albumName}|${album.artist}`;
                    const existing = merged.get(key);

                    if (existing) {
                        // Merge: prefer newer data
                        const mergedAlbum = { ...existing };
                        
                        // Use remote score if local doesn't have one
                        if (album.score && !existing.score) {
                            mergedAlbum.score = album.score;
                        }
                        
                        // Use newer date listened
                        if (album.dateListened && (!existing.dateListened || 
                            new Date(album.dateListened) > new Date(existing.dateListened))) {
                            mergedAlbum.dateListened = album.dateListened;
                        }
                        
                        // Merge notes
                        if (album.notes && album.notes !== existing.notes) {
                            mergedAlbum.notes = existing.notes 
                                ? `${existing.notes}\n\n[From OneDrive]: ${album.notes}`
                                : album.notes;
                        }

                        merged.set(key, mergedAlbum);
                    } else {
                        // Add new album from remote
                        merged.set(key, album);
                    }
                });

                return Array.from(merged.values());
            }

            async ensureFolder() {
                try {
                    // Try to get existing folder
                    const response = await fetch(
                        `https://graph.microsoft.com/v1.0/me/drive/root:/${this.folderName}`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );

                    if (response.ok) {
                        const folder = await response.json();
                        return folder.id;
                    }

                    // Create folder if it doesn't exist
                    const createResponse = await fetch(
                        'https://graph.microsoft.com/v1.0/me/drive/root/children',
                        {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                name: this.folderName,
                                folder: {},
                                '@microsoft.graph.conflictBehavior': 'fail'
                            })
                        }
                    );

                    if (!createResponse.ok) {
                        throw new Error('Failed to create folder');
                    }

                    const folder = await createResponse.json();
                    return folder.id;

                } catch (error) {
                    console.error('Error ensuring folder:', error);
                    throw error;
                }
            }

            async getFileId(folderId) {
                try {
                    const response = await fetch(
                        `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}/children?$filter=name eq '${this.fileName}'`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );

                    if (!response.ok) {
                        return null;
                    }

                    const data = await response.json();
                    return data.value && data.value.length > 0 ? data.value[0].id : null;

                } catch (error) {
                    console.error('Error getting file ID:', error);
                    return null;
                }
            }

            async createFile(folderId, content) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}:/${this.fileName}:/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to create file');
                }

                return await response.json();
            }

            async updateFile(fileId, content) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to update file');
                }

                return await response.json();
            }

            async downloadFile(fileId) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,
                    {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to download file');
                }

                return await response.json();
            }

            updateUI(status, text) {
                const indicator = document.getElementById('syncIndicator');
                const statusText = document.getElementById('syncText');
                const syncStatus = document.getElementById('syncStatus');

                if (!indicator || !statusText || !syncStatus) return;

                // Remove all status classes
                indicator.classList.remove('connected', 'syncing', 'offline', 'error');
                syncStatus.classList.remove('compact');

                if (status) {
                    indicator.classList.add(status);
                    if (status === 'connected') {
                        // Use compact mode for connected status
                        syncStatus.classList.add('compact');
                        const lastSync = this.lastSyncTime 
                            ? new Date(this.lastSyncTime).toLocaleString()
                            : 'Never';
                        statusText.innerHTML = `
                            <span class="sync-main-text">Synced</span>
                            <span class="sync-details">
                                <span class="sync-sub-text">Last: ${lastSync}</span>
                            </span>
                        `;
                    } else {
                        statusText.textContent = text;
                    }
                } else {
                    // Default status based on connection
                    if (this.isConnected()) {
                        indicator.classList.add('connected');
                        syncStatus.classList.add('compact');
                        const lastSync = this.lastSyncTime 
                            ? new Date(this.lastSyncTime).toLocaleString()
                            : 'Never';
                        statusText.innerHTML = `
                            <span class="sync-main-text">Synced</span>
                            <span class="sync-details">
                                <span class="sync-sub-text">Last: ${lastSync}</span>
                            </span>
                        `;
                    } else {
                        indicator.classList.add('offline');
                        statusText.textContent = 'Offline Mode';
                    }
                }

                this.updateSyncMenu();
            }

            updateSyncMenu() {
                const menuContent = document.getElementById('syncMenuContent');
                if (!menuContent) return;

                if (this.isConnected()) {
                    const lastSync = this.lastSyncTime 
                        ? new Date(this.lastSyncTime).toLocaleString()
                        : 'Never';

                    menuContent.innerHTML = `
                        <div style="padding: 10px; color: #666; font-size: 0.9em;">
                            <strong>OneDrive Connected</strong><br>
                            Last sync: ${lastSync}
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.syncFromOneDrive()">
                            <span></span>
                            <span>Load from OneDrive</span>
                        </div>
                        <div class="sync-menu-item" onclick="syncManager.syncToOneDrive()">
                            <span></span>
                            <span>Save to OneDrive</span>
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.disconnect()">
                            <span></span>
                            <span>Disconnect</span>
                        </div>
                    `;
                } else {
                    menuContent.innerHTML = `
                        <div style="padding: 10px; color: #666; font-size: 0.9em;">
                            <strong>Offline Mode</strong><br>
                            Data stored locally only
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.connectToOneDrive()">
                            <span></span>
                            <span>Connect to OneDrive</span>
                        </div>
                    `;
                }
            }
        }

        // Initialize database
        const db = new AlbumDatabase();
        
        // Initialize OneDrive sync
        const syncManager = new OneDriveSyncManager();

        // Lists Management
        let allCuratedLists = [];
        let filteredLists = [];
        let listsData = {}; // Store album data for each list

        // Selected curated lists (10 most suitable)


        async function loadCuratedLists() {
            try {
                // Try multiple paths for different hosting scenarios
                let response;
                const paths = [
                    'public/album_lists.csv',           // GitHub Pages with repo name in URL
                    './public/album_lists.csv',         // Relative path
                    '/public/album_lists.csv',          // Absolute from root
                    'album_lists.csv'                   // Same directory as index.html
                ];
                
                let csvText = '';
                let loadedSuccessfully = false;
                
                for (const path of paths) {
                    try {
                        response = await fetch(path);
                        if (response.ok) {
                            csvText = await response.text();
                            console.log(` Successfully loaded CSV from: ${path}`);
                            loadedSuccessfully = true;
                            break;
                        }
                    } catch (e) {
                        console.log(` Failed to load from ${path}:`, e.message);
                    }
                }
                
                if (!loadedSuccessfully) {
                    throw new Error('Could not load CSV from any path');
                }
                
                // Parse CSV - format: list_name,album_name,artist_name
                const lines = csvText.split('\n');
                const headers = lines[0].split(','); // list_name, album_name, artist_name
                
                // Group albums by list
                const listAlbumsMap = new Map();
                
                for (let i = 1; i < lines.length; i++) {
                    if (!lines[i].trim()) continue;
                    
                    const values = parseCSVLine(lines[i]);
                    if (values.length < 3) continue;
                    
                    const listName = values[0].trim();
                    const albumName = values[1].trim();
                    const artistName = values[2].trim();
                    
                    if (!listAlbumsMap.has(listName)) {
                        listAlbumsMap.set(listName, []);
                    }
                    
                    listAlbumsMap.get(listName).push({
                        name: albumName,      // Use 'name' to match getListStatus expectations
                        artist: artistName
                    });
                }
                
                // Create list metadata
                allCuratedLists = [];
                listsData = {};
                
                // Define metadata for each list
                const listMetadata = {
                    "Rolling Stone's 500 Greatest Albums": {
                        category: "Critical Acclaim Lists",
                        source: "Rolling Stone Magazine",
                        genres: "All Genres"
                    },
                    "NME's 500 Greatest Albums": {
                        category: "Critical Acclaim Lists",
                        source: "NME Magazine",
                        genres: "Rock, Alternative, Indie"
                    },
                    "Pitchfork's Top 200 Albums of the 2000s": {
                        category: "Critical Acclaim Lists",
                        source: "Pitchfork",
                        genres: "Indie, Alternative, Electronic"
                    },
                    "Grammy Album of the Year Winners": {
                        category: "Major Music Awards",
                        source: "The Recording Academy",
                        genres: "All Genres"
                    },
                    "Mercury Prize Winners": {
                        category: "Major Music Awards",
                        source: "Mercury Prize",
                        genres: "All Genres (UK Focus)"
                    },
                    "Pitchfork's Top 200 Albums of the 1990s": {
                        category: "Critical Acclaim Lists",
                        source: "Pitchfork",
                        genres: "Alternative, Indie, Hip-Hop"
                    },
                    "Acclaimed Music's Top 3000 Albums": {
                        category: "Critical Acclaim Lists",
                        source: "Acclaimed Music",
                        genres: "All Genres"
                    },
                    "Rolling Stone's 200 Greatest Hip-Hop Albums": {
                        category: "Genre-Specific Lists",
                        source: "Rolling Stone Magazine",
                        genres: "Hip-Hop, Rap"
                    },
                    "Mojo's 100 Greatest Albums of Soul and R&B": {
                        category: "Genre-Specific Lists",
                        source: "Mojo Magazine",
                        genres: "Soul, R&B"
                    },
                    "Rolling Stone's 100 Greatest Metal Albums": {
                        category: "Genre-Specific Lists",
                        source: "Rolling Stone Magazine",
                        genres: "Metal, Hard Rock"
                    }
                };
                
                // Create list objects
                for (const [listName, albums] of listAlbumsMap.entries()) {
                    const metadata = listMetadata[listName] || {
                        category: "Music Lists",
                        source: "Various",
                        genres: "All Genres"
                    };
                    
                    allCuratedLists.push({
                        name: listName,
                        category: metadata.category,
                        source: metadata.source,
                        genres: metadata.genres,
                        albumCount: albums.length.toString()
                    });
                    
                    // Store album data
                    listsData[listName] = albums.map((album, index) => ({
                        id: `${listName}-${index}`,
                        albumName: album.name || 'Unknown Album',
                        artist: album.artist || 'Unknown Artist',
                        year: null, // Will be fetched from Discogs API later
                        artworkUrl: `https://via.placeholder.com/150/667eea/ffffff?text=${encodeURIComponent((album.name || 'Unknown').substring(0, 20))}`,
                        sourceLists: [listName]
                    }));
                }
                
                // Populate filters
                populateFilters();
                
                // Display lists
                filteredLists = [...allCuratedLists];
                displayLists();
                
            } catch (error) {
                console.error('Error loading curated lists:', error);
                document.getElementById('listsContainer').innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #dc3545;">
                        <p style="font-size: 1.2em;"> Error loading lists</p>
                        <p style="color: #666;">Could not find album_lists.csv. Tried the following paths:</p>
                        <ul style="text-align: left; display: inline-block; color: #666; font-size: 0.9em;">
                            <li>public/album_lists.csv</li>
                            <li>./public/album_lists.csv</li>
                            <li>/public/album_lists.csv</li>
                            <li>album_lists.csv</li>
                        </ul>
                        <p style="color: #666; margin-top: 20px;">Please ensure the CSV file exists in one of these locations.</p>
                        <p style="color: #999; font-size: 0.85em;">Error: ${error.message}</p>
                    </div>
                `;
            }
        }

        function parseCSVLine(line) {
            const values = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    values.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            values.push(current.trim());
            
            return values;
        }



        function populateFilters() {
            const categories = [...new Set(allCuratedLists.map(l => l.category))];
            const sources = [...new Set(allCuratedLists.map(l => l.source))];
            
            const categoryFilter = document.getElementById('categoryFilter');
            const sourceFilter = document.getElementById('sourceFilter');
            
            categories.forEach(cat => {
                const option = document.createElement('option');
                option.value = cat;
                option.textContent = cat;
                categoryFilter.appendChild(option);
            });
            
            sources.forEach(src => {
                const option = document.createElement('option');
                option.value = src;
                option.textContent = src;
                sourceFilter.appendChild(option);
            });
        }

        function filterLists() {
            const categoryFilter = document.getElementById('categoryFilter').value;
            const sourceFilter = document.getElementById('sourceFilter').value;
            const listSizeFilter = document.getElementById('listSizeFilter').value;
            const genreFilter = document.getElementById('genreFilter').value.toLowerCase().trim();
            
            filteredLists = allCuratedLists.filter(list => {
                // Category filter
                if (categoryFilter && list.category !== categoryFilter) return false;
                
                // Source filter
                if (sourceFilter && list.source !== sourceFilter) return false;
                
                // List size filter
                if (listSizeFilter) {
                    const albumCount = list.albumCount;
                    if (listSizeFilter === '<50' && albumCount >= 50) return false;
                    if (listSizeFilter === '50-100' && (albumCount < 50 || albumCount > 100)) return false;
                    if (listSizeFilter === '100-500' && (albumCount < 100 || albumCount > 500)) return false;
                    if (listSizeFilter === '>500' && albumCount <= 500) return false;
                }
                
                // Genre filter - "All Genres" lists always show up
                if (genreFilter) {
                    const listGenres = list.genres.toLowerCase();
                    // If list has "All Genres", it always matches
                    if (listGenres.includes('all genres')) return true;
                    // Otherwise, check if the filter matches
                    if (!listGenres.includes(genreFilter)) return false;
                }
                
                return true;
            });
            
            displayLists();
        }

        function displayLists() {
            const container = document.getElementById('listsContainer');
            
            if (filteredLists.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #999;">
                        <p style="font-size: 1.2em;">No lists match your filters</p>
                        <p style="color: #666;">Try adjusting your filter criteria</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = filteredLists.map((list, index) => {
                const status = getListStatus(list.name);
                const statusBadge = status.type === 'added' ? 
                    `<span class="list-status-badge status-added"> Added</span>` :
                    status.type === 'partial' ?
                    `<span class="list-status-badge status-partial"> Partial (${status.count}/${status.total})</span>` :
                    '';
                
                return `
                    <div class="list-card" data-list-index="${index}">
                        <div class="list-card-header" onclick="toggleListExpand(${index})">
                            <div class="list-card-title">
                                <h3>${list.name}</h3>
                                <div class="list-card-meta">
                                    <span class="list-card-badge badge-category">${list.category}</span>
                                    <span class="list-card-badge badge-source">${list.source}</span>
                                    <span class="list-card-badge badge-genre">${list.genres}</span>
                                    <span class="list-card-badge badge-count">${list.albumCount} albums</span>
                                </div>
                            </div>
                            <div style="display: flex; align-items: center; gap: 15px;">
                                ${statusBadge}
                                <span class="expand-icon" id="expand-icon-${index}"></span>
                            </div>
                        </div>
                        <div class="list-card-content" id="list-content-${index}">
                            <div class="list-description">
                                <strong>Time Period:</strong> ${list.timePeriod}<br>
                                <strong>Geographic Focus:</strong> ${list.geographicFocus}<br>
                                ${list.notes ? `<strong>Notes:</strong> ${list.notes}` : ''}
                            </div>
                            <div class="list-actions">
                                ${status.type !== 'added' ? `
                                    <button class="btn btn-primary" onclick="addListToLibrary('${list.name.replace(/'/g, "\\'")}', event)">
                                         ${status.type === 'partial' ? 'Add Missing Albums' : 'Add List to Library'}
                                    </button>
                                ` : ''}
                                <button class="btn btn-secondary" onclick="viewListAlbums('${list.name.replace(/'/g, "\\'")}', event)">
                                     View Albums
                                </button>
                            </div>
                            <div id="list-albums-${index}" style="display: none;"></div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleListExpand(index) {
            const content = document.getElementById(`list-content-${index}`);
            const icon = document.getElementById(`expand-icon-${index}`);
            
            content.classList.toggle('expanded');
            icon.classList.toggle('expanded');
        }

        function getListStatus(listName) {
            const listAlbums = listsData[listName] || [];
            const userAlbums = db.getAllAlbums();
            
            let addedCount = 0;
            listAlbums.forEach(listAlbum => {
                // Skip if album data is incomplete
                const albumName = listAlbum.albumName || listAlbum.name;
                if (!listAlbum || !albumName || !listAlbum.artist) {
                    return;
                }
                
                const inLibrary = userAlbums.some(userAlbum => {
                    if (!userAlbum || !userAlbum.albumName || !userAlbum.artist) {
                        return false;
                    }
                    const nameMatch = (userAlbum.albumName || '').toString().toLowerCase() === (albumName || '').toString().toLowerCase();
                    const artistMatch = (userAlbum.artist || '').toString().toLowerCase() === (listAlbum.artist || '').toString().toLowerCase();
                    const hasSourceList = Array.isArray(userAlbum.sourceLists) && userAlbum.sourceLists.includes(listName);
                    return nameMatch && artistMatch && hasSourceList;
                });
                if (inLibrary) addedCount++;
            });
            
            if (addedCount === listAlbums.length && listAlbums.length > 0) {
                return { type: 'added', count: addedCount, total: listAlbums.length };
            } else if (addedCount > 0) {
                return { type: 'partial', count: addedCount, total: listAlbums.length };
            }
            return { type: 'none', count: 0, total: listAlbums.length };
        }

        async function addListToLibrary(listName, event) {
            event.stopPropagation();
            
            const listAlbums = listsData[listName] || [];
            const userAlbums = db.getAllAlbums();
            
            let added = 0;
            let updated = 0;
            
            for (const listAlbum of listAlbums) {
                const existing = userAlbums.find(a => {
                    const aAlbumName = (a.albumName || '').toString().toLowerCase();
                    const aArtist = (a.artist || '').toString().toLowerCase();
                    const listAlbumName = (listAlbum.albumName || listAlbum.name || '').toString().toLowerCase();
                    const listAlbumArtist = (listAlbum.artist || '').toString().toLowerCase();
                    
                    return aAlbumName === listAlbumName && aArtist === listAlbumArtist;
                });
                
                if (existing) {
                    // Update source lists
                    const sourceLists = existing.sourceLists || [];
                    if (!sourceLists.includes(listName)) {
                        sourceLists.push(listName);
                        db.updateAlbum(existing.id, { sourceLists });
                        updated++;
                    }
                } else {
                    // Add new album
                    db.addAlbum({
                        albumName: listAlbum.albumName || listAlbum.name || 'Unknown Album',
                        artist: listAlbum.artist || 'Unknown Artist',
                        year: listAlbum.year || null,
                        artworkUrl: listAlbum.artworkUrl || listAlbum.artwork || `https://via.placeholder.com/150/667eea/ffffff?text=${encodeURIComponent((listAlbum.albumName || listAlbum.name || 'Unknown').substring(0, 20))}`,
                        sourceLists: [listName],
                        reason: `From ${listName}`
                    });
                    added++;
                }
            }
            
            alert(` Import complete!\n\nAdded: ${added} albums\nUpdated: ${updated} albums`);
            displayLists();
            displayAlbums();
        }

        function viewListAlbums(listName, event) {
            event.stopPropagation();
            
            console.log('viewListAlbums called for:', listName);
            
            const index = filteredLists.findIndex(l => l.name === listName);
            console.log('List index:', index);
            
            const container = document.getElementById(`list-albums-${index}`);
            console.log('Container found:', container);
            
            if (!container) {
                console.error('Container not found for list-albums-' + index);
                return;
            }
            
            const listAlbums = listsData[listName] || [];
            console.log('Number of albums in list:', listAlbums.length);
            console.log('First album:', listAlbums[0]);
            
            if (container.style.display === 'none' || container.style.display === '') {
                const userAlbums = db.getAllAlbums();
                
                if (listAlbums.length === 0) {
                    container.innerHTML = '<p style="text-align: center; padding: 20px; color: #666;">No albums found in this list.</p>';
                    container.style.display = 'block';
                    return;
                }
                
                container.innerHTML = `
                    <div class="list-albums-grid">
                        ${listAlbums.slice(0, 20).map(album => {
                            const inLibrary = userAlbums.some(a => {
                                const aAlbumName = (a.albumName || '').toString().toLowerCase();
                                const aArtist = (a.artist || '').toString().toLowerCase();
                                const albumName = (album.albumName || '').toString().toLowerCase();
                                const albumArtist = (album.artist || '').toString().toLowerCase();
                                const hasSourceList = Array.isArray(a.sourceLists) && a.sourceLists.includes(listName);
                                
                                return aAlbumName === albumName && aArtist === albumArtist && hasSourceList;
                            });
                            
                            return `
                                <div class="list-album-item ${inLibrary ? 'in-library' : 'missing'}">
                                    <img src="${album.artworkUrl}" alt="${album.albumName}" class="list-album-artwork" onerror="this.src='https://via.placeholder.com/150?text=No+Image'">
                                    <div class="list-album-title">${album.albumName}</div>
                                    <div class="list-album-artist">${album.artist}</div>
                                    ${inLibrary ? '<div style="color: #28a745; font-size: 0.8em; margin-top: 5px;"> In Library</div>' : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    ${listAlbums.length > 20 ? `<p style="text-align: center; color: #666; margin-top: 15px;">Showing first 20 of ${listAlbums.length} albums</p>` : ''}
                `;
                container.style.display = 'block';
                console.log('Albums displayed successfully');
            } else {
                container.style.display = 'none';
                console.log('Albums hidden');
            }
        }

        // Settings Functions
        function toggleViewMode() {
            const viewportMeta = document.getElementById('viewport-meta');
            const toggleBtn = document.getElementById('viewToggleBtn');
            const currentContent = viewportMeta.getAttribute('content');
            
            if (currentContent.includes('width=1400')) {
                // Switch to mobile view
                viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0');
                toggleBtn.innerHTML = ' Desktop View';
                localStorage.setItem('viewMode', 'mobile');
            } else {
                // Switch to desktop view
                viewportMeta.setAttribute('content', 'width=1400, user-scalable=yes');
                toggleBtn.innerHTML = ' Mobile View';
                localStorage.setItem('viewMode', 'desktop');
            }
        }

        function openSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.add('active');
            loadSettingsData();
            initializeCustomThemeCreator();
            
            // Populate color pickers with current theme colors
            setTimeout(() => {
                populateColorPickersFromTheme();
            }, 100);
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('active');
        }
        
        function toggleCollapse(sectionId) {
            const content = document.getElementById(sectionId);
            const icon = document.getElementById(sectionId + 'Icon');
            
            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        // Theme Management
        function selectTheme(themeName) {
            // Update body data-theme attribute
            document.body.setAttribute('data-theme', themeName);
            
            // Update UI to show selected theme
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('selected');
            });
            document.querySelector(`[data-theme="${themeName}"]`).classList.add('selected');
            
            // Save theme preference
            saveThemePreference(themeName);
            
            // Populate color pickers with theme colors (with small delay to ensure CSS is applied)
            setTimeout(() => {
                populateColorPickersFromTheme();
            }, 100);
            
            // Show success message
            showMessage(`Theme changed to ${themeName}!`, 'success');
        }
        
        function populateColorPickersFromTheme() {
            console.log(' Populating color pickers from theme...');
            
            // Get computed CSS variable values from body (where data-theme is applied)
            const body = document.body;
            const computedStyle = getComputedStyle(body);
            const currentTheme = body.getAttribute('data-theme') || 'forest';
            
            console.log('Current theme:', currentTheme);
            
            // Helper function to convert RGB to Hex
            function rgbToHex(rgb) {
                // Handle rgb() format
                const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (match) {
                    const r = parseInt(match[1]).toString(16).padStart(2, '0');
                    const g = parseInt(match[2]).toString(16).padStart(2, '0');
                    const b = parseInt(match[3]).toString(16).padStart(2, '0');
                    return `#${r}${g}${b}`;
                }
                // If already hex, return as is
                if (rgb.startsWith('#')) {
                    return rgb;
                }
                return rgb;
            }
            
            // Get all CSS variable values
            const gradientStart = computedStyle.getPropertyValue('--gradient-start').trim();
            const gradientEnd = computedStyle.getPropertyValue('--gradient-end').trim();
            
            console.log('Gradient start (raw):', gradientStart);
            console.log('Gradient end (raw):', gradientEnd);
            const contentBg = computedStyle.getPropertyValue('--content-bg').trim();
            const cardBg = computedStyle.getPropertyValue('--card-bg').trim();
            const modalBg = computedStyle.getPropertyValue('--modal-bg').trim();
            const chartBg = computedStyle.getPropertyValue('--chart-bg').trim();
            const contentText = computedStyle.getPropertyValue('--content-text').trim();
            const cardText = computedStyle.getPropertyValue('--card-text').trim();
            const modalText = computedStyle.getPropertyValue('--modal-text').trim();
            const chartText = computedStyle.getPropertyValue('--chart-text').trim();
            const headerText = computedStyle.getPropertyValue('--header-text').trim();
            const subheaderText = computedStyle.getPropertyValue('--subheader-text').trim();
            const buttonBg = computedStyle.getPropertyValue('--button-bg').trim();
            const buttonHover = computedStyle.getPropertyValue('--button-hover').trim();
            const borderColor = computedStyle.getPropertyValue('--border-color').trim();
            const borderHover = computedStyle.getPropertyValue('--border-hover').trim();
            
            // Populate color pickers
            const customGradientStart = document.getElementById('customGradientStart');
            const customGradientEnd = document.getElementById('customGradientEnd');
            const customContentBg = document.getElementById('customContentBg');
            const customCardBg = document.getElementById('customCardBg');
            const customModalBg = document.getElementById('customModalBg');
            const customChartBg = document.getElementById('customChartBg');
            const customContentText = document.getElementById('customContentText');
            const customCardText = document.getElementById('customCardText');
            const customModalText = document.getElementById('customModalText');
            const customChartText = document.getElementById('customChartText');
            const customHeaderText = document.getElementById('customHeaderText');
            const customSubheaderText = document.getElementById('customSubheaderText');
            const customButtonBg = document.getElementById('customButtonBg');
            const customButtonHover = document.getElementById('customButtonHover');
            const customBorderColor = document.getElementById('customBorderColor');
            const customBorderHover = document.getElementById('customBorderHover');
            
            if (customGradientStart) {
                const hexValue = rgbToHex(gradientStart);
                customGradientStart.value = hexValue;
                console.log(' Set gradient start to:', hexValue);
            } else {
                console.log(' customGradientStart element not found');
            }
            
            if (customGradientEnd) {
                const hexValue = rgbToHex(gradientEnd);
                customGradientEnd.value = hexValue;
                console.log(' Set gradient end to:', hexValue);
            } else {
                console.log(' customGradientEnd element not found');
            }
            
            if (customContentBg) customContentBg.value = rgbToHex(contentBg);
            if (customCardBg) customCardBg.value = rgbToHex(cardBg);
            if (customModalBg) customModalBg.value = rgbToHex(modalBg);
            if (customChartBg) customChartBg.value = rgbToHex(chartBg);
            if (customContentText) customContentText.value = rgbToHex(contentText);
            if (customCardText) customCardText.value = rgbToHex(cardText);
            if (customModalText) customModalText.value = rgbToHex(modalText);
            if (customChartText) customChartText.value = rgbToHex(chartText);
            if (customHeaderText) customHeaderText.value = rgbToHex(headerText);
            if (customSubheaderText) customSubheaderText.value = rgbToHex(subheaderText);
            if (customButtonBg) customButtonBg.value = rgbToHex(buttonBg);
            if (customButtonHover) customButtonHover.value = rgbToHex(buttonHover);
            if (customBorderColor) customBorderColor.value = rgbToHex(borderColor);
            if (customBorderHover) customBorderHover.value = rgbToHex(borderHover);
            
            console.log(' Color pickers populated successfully!');
        }

        function saveThemePreference(themeName) {
            // Save to localStorage
            localStorage.setItem('app_theme', themeName);
            
            // Save to OneDrive sync data
            const syncData = JSON.parse(localStorage.getItem('onedrive_sync_data') || '{}');
            syncData.theme = themeName;
            localStorage.setItem('onedrive_sync_data', JSON.stringify(syncData));
            
            // Trigger OneDrive sync if connected
            if (typeof oneDriveManager !== 'undefined' && oneDriveManager && oneDriveManager.isAuthenticated()) {
                oneDriveManager.syncToOneDrive();
            }
        }

        function loadThemePreference() {
            // Try to load from OneDrive sync data first
            const syncData = JSON.parse(localStorage.getItem('onedrive_sync_data') || '{}');
            let theme = syncData.theme;
            
            // Fall back to localStorage if not in sync data
            if (!theme) {
                theme = localStorage.getItem('app_theme');
            }
            
            // Default to forest green if no preference
            if (!theme) {
                theme = 'forest';
            }
            
            // Apply theme
            document.body.setAttribute('data-theme', theme);
            
            // Update UI if settings are open
            const themeOption = document.querySelector(`[data-theme="${theme}"]`);
            if (themeOption) {
                document.querySelectorAll('.theme-option').forEach(option => {
                    option.classList.remove('selected');
                });
                themeOption.classList.add('selected');
            }
            
            return theme;
        }

        // Custom Theme Functions
        function applyCustomTheme() {
            const gradientStart = document.getElementById('customGradientStart').value;
            const gradientEnd = document.getElementById('customGradientEnd').value;
            const contentBg = document.getElementById('customContentBg').value;
            const cardBg = document.getElementById('customCardBg').value;
            const modalBg = document.getElementById('customModalBg').value;
            const chartBg = document.getElementById('customChartBg').value;
            const contentText = document.getElementById('customContentText').value;
            const cardText = document.getElementById('customCardText').value;
            const modalText = document.getElementById('customModalText').value;
            const chartText = document.getElementById('customChartText').value;
            const headerText = document.getElementById('customHeaderText').value;
            const subheaderText = document.getElementById('customSubheaderText').value;
            const buttonBg = document.getElementById('customButtonBg').value;
            const buttonHover = document.getElementById('customButtonHover').value;
            const borderColor = document.getElementById('customBorderColor').value;
            const borderHover = document.getElementById('customBorderHover').value;
            
            // Set CSS variables
            document.documentElement.style.setProperty('--custom-gradient-start', gradientStart);
            document.documentElement.style.setProperty('--custom-gradient-end', gradientEnd);
            document.documentElement.style.setProperty('--custom-content-bg', contentBg);
            document.documentElement.style.setProperty('--custom-card-bg', cardBg);
            document.documentElement.style.setProperty('--custom-modal-bg', modalBg);
            document.documentElement.style.setProperty('--custom-chart-bg', chartBg);
            document.documentElement.style.setProperty('--custom-content-text', contentText);
            document.documentElement.style.setProperty('--custom-card-text', cardText);
            document.documentElement.style.setProperty('--custom-modal-text', modalText);
            document.documentElement.style.setProperty('--custom-chart-text', chartText);
            document.documentElement.style.setProperty('--custom-header-text', headerText);
            document.documentElement.style.setProperty('--custom-subheader-text', subheaderText);
            document.documentElement.style.setProperty('--custom-button-bg', buttonBg);
            document.documentElement.style.setProperty('--custom-button-hover', buttonHover);
            document.documentElement.style.setProperty('--custom-border-color', borderColor);
            document.documentElement.style.setProperty('--custom-border-hover', borderHover);
            
            // Apply custom theme
            selectTheme('custom');
            
            // Save custom colors
            saveCustomThemeColors(gradientStart, gradientEnd, contentBg, cardBg, modalBg, chartBg, contentText, cardText, modalText, chartText, headerText, subheaderText, buttonBg, buttonHover, borderColor, borderHover);
            
            showMessage('Custom theme applied! ', 'success');
        }

        function saveCustomThemeColors(gradientStart, gradientEnd, contentBg, cardBg, modalBg, chartBg, contentText, cardText, modalText, chartText, headerText, subheaderText, buttonBg, buttonHover, borderColor, borderHover) {
            localStorage.setItem('customGradientStart', gradientStart);
            localStorage.setItem('customGradientEnd', gradientEnd);
            localStorage.setItem('customContentBg', contentBg);
            localStorage.setItem('customCardBg', cardBg);
            localStorage.setItem('customModalBg', modalBg);
            localStorage.setItem('customChartBg', chartBg);
            localStorage.setItem('customContentText', contentText);
            localStorage.setItem('customCardText', cardText);
            localStorage.setItem('customModalText', modalText);
            localStorage.setItem('customChartText', chartText);
            localStorage.setItem('customHeaderText', headerText);
            localStorage.setItem('customSubheaderText', subheaderText);
            localStorage.setItem('customButtonBg', buttonBg);
            localStorage.setItem('customButtonHover', buttonHover);
            localStorage.setItem('customBorderColor', borderColor);
            localStorage.setItem('customBorderHover', borderHover);
            
            // Also save to OneDrive
            const syncData = JSON.parse(localStorage.getItem('onedrive_sync_data') || '{}');
            syncData.customTheme = {
                gradientStart: gradientStart,
                gradientEnd: gradientEnd,
                contentBg: contentBg,
                cardBg: cardBg,
                modalBg: modalBg,
                chartBg: chartBg,
                contentText: contentText,
                cardText: cardText,
                modalText: modalText,
                chartText: chartText,
                headerText: headerText,
                subheaderText: subheaderText,
                buttonBg: buttonBg,
                buttonHover: buttonHover,
                borderColor: borderColor,
                borderHover: borderHover
            };
            localStorage.setItem('onedrive_sync_data', JSON.stringify(syncData));
            
            // Trigger OneDrive sync if connected
            if (typeof oneDriveManager !== 'undefined' && oneDriveManager && oneDriveManager.isAuthenticated()) {
                oneDriveManager.syncToOneDrive();
            }
        }

        function loadCustomThemeColors() {
            // Try OneDrive first
            const syncData = JSON.parse(localStorage.getItem('onedrive_sync_data') || '{}');
            if (syncData.customTheme) {
                return syncData.customTheme;
            }
            
            // Fall back to localStorage
            const gradientStart = localStorage.getItem('customGradientStart');
            const gradientEnd = localStorage.getItem('customGradientEnd');
            const contentBg = localStorage.getItem('customContentBg');
            const cardBg = localStorage.getItem('customCardBg');
            const modalBg = localStorage.getItem('customModalBg');
            const chartBg = localStorage.getItem('customChartBg');
            const contentText = localStorage.getItem('customContentText');
            const cardText = localStorage.getItem('customCardText');
            const modalText = localStorage.getItem('customModalText');
            const chartText = localStorage.getItem('customChartText');
            const headerText = localStorage.getItem('customHeaderText');
            const subheaderText = localStorage.getItem('customSubheaderText');
            const buttonBg = localStorage.getItem('customButtonBg');
            const buttonHover = localStorage.getItem('customButtonHover');
            const borderColor = localStorage.getItem('customBorderColor');
            const borderHover = localStorage.getItem('customBorderHover');
            
            if (gradientStart) {
                return { 
                    gradientStart, 
                    gradientEnd: gradientEnd || '#71B280',
                    contentBg: contentBg || '#ffffff',
                    cardBg: cardBg || '#f8f9ff',
                    modalBg: modalBg || '#ffffff',
                    chartBg: chartBg || '#fafbff',
                    contentText: contentText || '#333333',
                    cardText: cardText || '#333333',
                    modalText: modalText || '#333333',
                    chartText: chartText || '#333333',
                    headerText: headerText || '#ffffff',
                    subheaderText: subheaderText || '#ffffff',
                    buttonBg: buttonBg || '#667eea',
                    buttonHover: buttonHover || '#764ba2',
                    borderColor: borderColor || '#667eea',
                    borderHover: borderHover || '#764ba2'
                };
            }
            
            return null;
        }

        function resetToDefault() {
            document.getElementById('customGradientStart').value = '#134E5E';
            document.getElementById('customGradientEnd').value = '#71B280';
            document.getElementById('customContentBg').value = '#ffffff';
            document.getElementById('customCardBg').value = '#f8f9ff';
            document.getElementById('customModalBg').value = '#ffffff';
            document.getElementById('customChartBg').value = '#fafbff';
            document.getElementById('customContentText').value = '#333333';
            document.getElementById('customCardText').value = '#333333';
            document.getElementById('customModalText').value = '#333333';
            document.getElementById('customChartText').value = '#333333';
            document.getElementById('customHeaderText').value = '#ffffff';
            document.getElementById('customSubheaderText').value = '#ffffff';
            document.getElementById('customButtonBg').value = '#667eea';
            document.getElementById('customButtonHover').value = '#764ba2';
            document.getElementById('customBorderColor').value = '#667eea';
            document.getElementById('customBorderHover').value = '#764ba2';
            selectTheme('forest');
            showMessage('Reset to default theme', 'success');
        }

        function initializeCustomThemeCreator() {
            // Load saved custom colors
            const customColors = loadCustomThemeColors();
            if (customColors) {
                const gradientStartInput = document.getElementById('customGradientStart');
                const gradientEndInput = document.getElementById('customGradientEnd');
                const contentBgInput = document.getElementById('customContentBg');
                const cardBgInput = document.getElementById('customCardBg');
                const modalBgInput = document.getElementById('customModalBg');
                const chartBgInput = document.getElementById('customChartBg');
                const contentTextInput = document.getElementById('customContentText');
                const cardTextInput = document.getElementById('customCardText');
                const modalTextInput = document.getElementById('customModalText');
                const chartTextInput = document.getElementById('customChartText');
                const headerTextInput = document.getElementById('customHeaderText');
                const subheaderTextInput = document.getElementById('customSubheaderText');
                const buttonBgInput = document.getElementById('customButtonBg');
                const buttonHoverInput = document.getElementById('customButtonHover');
                
                if (gradientStartInput && gradientEndInput && contentBgInput && cardBgInput && modalBgInput && chartBgInput && 
                    contentTextInput && cardTextInput && modalTextInput && chartTextInput &&
                    headerTextInput && subheaderTextInput && buttonBgInput && buttonHoverInput) {
                    gradientStartInput.value = customColors.gradientStart || '#134E5E';
                    gradientEndInput.value = customColors.gradientEnd || '#71B280';
                    contentBgInput.value = customColors.contentBg || '#ffffff';
                    cardBgInput.value = customColors.cardBg || '#f8f9ff';
                    modalBgInput.value = customColors.modalBg || '#ffffff';
                    chartBgInput.value = customColors.chartBg || '#fafbff';
                    contentTextInput.value = customColors.contentText || '#333333';
                    cardTextInput.value = customColors.cardText || '#333333';
                    modalTextInput.value = customColors.modalText || '#333333';
                    chartTextInput.value = customColors.chartText || '#333333';
                    headerTextInput.value = customColors.headerText || '#ffffff';
                    subheaderTextInput.value = customColors.subheaderText || '#ffffff';
                    buttonBgInput.value = customColors.buttonBg || '#667eea';
                    buttonHoverInput.value = customColors.buttonHover || '#764ba2';
                    
                    // Apply if custom theme is active
                    const currentTheme = document.body.getAttribute('data-theme');
                    if (currentTheme === 'custom') {
                        document.documentElement.style.setProperty('--custom-gradient-start', customColors.gradientStart || '#134E5E');
                        document.documentElement.style.setProperty('--custom-gradient-end', customColors.gradientEnd || '#71B280');
                        document.documentElement.style.setProperty('--custom-content-bg', customColors.contentBg || '#ffffff');
                        document.documentElement.style.setProperty('--custom-card-bg', customColors.cardBg || '#f8f9ff');
                        document.documentElement.style.setProperty('--custom-modal-bg', customColors.modalBg || '#ffffff');
                        document.documentElement.style.setProperty('--custom-chart-bg', customColors.chartBg || '#fafbff');
                        document.documentElement.style.setProperty('--custom-content-text', customColors.contentText || '#333333');
                        document.documentElement.style.setProperty('--custom-card-text', customColors.cardText || '#333333');
                        document.documentElement.style.setProperty('--custom-modal-text', customColors.modalText || '#333333');
                        document.documentElement.style.setProperty('--custom-chart-text', customColors.chartText || '#333333');
                        document.documentElement.style.setProperty('--custom-header-text', customColors.headerText || '#ffffff');
                        document.documentElement.style.setProperty('--custom-subheader-text', customColors.subheaderText || '#ffffff');
                        document.documentElement.style.setProperty('--custom-button-bg', customColors.buttonBg || '#667eea');
                        document.documentElement.style.setProperty('--custom-button-hover', customColors.buttonHover || '#764ba2');
                    }
                }
            }
        }

        // Save a named custom theme
        function saveNamedCustomTheme() {
            const nameInput = document.getElementById('customThemeName');
            const themeName = nameInput.value.trim();
            
            if (!themeName) {
                showMessage('Please enter a theme name', 'error');
                return;
            }
            
            // Get current color values
            const themeData = {
                name: themeName,
                colors: {
                    start: document.getElementById('customGradientStart').value,
                    end: document.getElementById('customGradientEnd').value,
                    contentBg: document.getElementById('customContentBg').value,
                    cardBg: document.getElementById('customCardBg').value,
                    modalBg: document.getElementById('customModalBg').value,
                    chartBg: document.getElementById('customChartBg').value,
                    contentText: document.getElementById('customContentText').value,
                    cardText: document.getElementById('customCardText').value,
                    modalText: document.getElementById('customModalText').value,
                    chartText: document.getElementById('customChartText').value,
                    headerText: document.getElementById('customHeaderText').value,
                    subheaderText: document.getElementById('customSubheaderText').value,
                    buttonBg: document.getElementById('customButtonBg').value,
                    buttonHover: document.getElementById('customButtonHover').value,
                    borderColor: document.getElementById('customBorderColor').value,
                    borderHover: document.getElementById('customBorderHover').value
                }
            };
            
            // Load existing saved themes
            let savedThemes = JSON.parse(localStorage.getItem('saved_custom_themes') || '[]');
            
            // Check if we already have 3 themes
            if (savedThemes.length >= 3) {
                // Check if we're updating an existing theme
                const existingIndex = savedThemes.findIndex(t => t.name === themeName);
                if (existingIndex === -1) {
                    showMessage('Maximum 3 saved themes. Delete one to save a new theme.', 'error');
                    return;
                } else {
                    // Update existing theme
                    savedThemes[existingIndex] = themeData;
                }
            } else {
                // Check if theme name already exists
                const existingIndex = savedThemes.findIndex(t => t.name === themeName);
                if (existingIndex !== -1) {
                    // Update existing theme
                    savedThemes[existingIndex] = themeData;
                } else {
                    // Add new theme
                    savedThemes.push(themeData);
                }
            }
            
            // Save to localStorage
            localStorage.setItem('saved_custom_themes', JSON.stringify(savedThemes));
            
            // Save to OneDrive sync data
            const syncData = JSON.parse(localStorage.getItem('onedrive_sync_data') || '{}');
            syncData.savedThemes = savedThemes;
            localStorage.setItem('onedrive_sync_data', JSON.stringify(syncData));
            
            // Trigger OneDrive sync if connected
            if (typeof oneDriveManager !== 'undefined' && oneDriveManager && oneDriveManager.isAuthenticated()) {
                oneDriveManager.syncToOneDrive();
            }
            
            // Clear input and refresh list
            nameInput.value = '';
            loadSavedThemesList();
            showMessage(`Theme "${themeName}" saved successfully!`, 'success');
        }

        // Load and display saved themes
        function loadSavedThemesList() {
            const savedThemes = JSON.parse(localStorage.getItem('saved_custom_themes') || '[]');
            const listContainer = document.getElementById('savedThemesList');
            
            if (savedThemes.length === 0) {
                listContainer.innerHTML = '<p style="color: #6c757d; font-size: 13px; text-align: center; padding: 20px;">No saved themes yet</p>';
                return;
            }
            
            listContainer.innerHTML = savedThemes.map(theme => `
                <div style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #f8f9fa; border-radius: 8px; border: 2px solid #e0e0e0;">
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #212529; margin-bottom: 4px;">${theme.name}</div>
                        <div style="height: 20px; border-radius: 4px; background: linear-gradient(135deg, ${theme.colors.start} 0%, ${theme.colors.end} 100%);"></div>
                    </div>
                    <button onclick="loadSavedTheme('${theme.name}')" class="settings-btn settings-btn-secondary" style="padding: 8px 12px; font-size: 13px;">
                         Load
                    </button>
                    <button onclick="deleteSavedTheme('${theme.name}')" class="settings-btn settings-btn-secondary" style="padding: 8px 12px; font-size: 13px; background: #dc3545; color: white;">
                        
                    </button>
                </div>
            `).join('');
        }

        // Load a saved theme into the color pickers
        function loadSavedTheme(themeName) {
            const savedThemes = JSON.parse(localStorage.getItem('saved_custom_themes') || '[]');
            const theme = savedThemes.find(t => t.name === themeName);
            
            if (!theme) {
                showMessage('Theme not found', 'error');
                return;
            }
            
            // Populate color pickers
            document.getElementById('customGradientStart').value = theme.colors.start;
            document.getElementById('customGradientEnd').value = theme.colors.end;
            document.getElementById('customContentBg').value = theme.colors.contentBg;
            document.getElementById('customCardBg').value = theme.colors.cardBg;
            document.getElementById('customModalBg').value = theme.colors.modalBg;
            document.getElementById('customChartBg').value = theme.colors.chartBg;
            document.getElementById('customContentText').value = theme.colors.contentText;
            document.getElementById('customCardText').value = theme.colors.cardText;
            document.getElementById('customModalText').value = theme.colors.modalText;
            document.getElementById('customChartText').value = theme.colors.chartText;
            document.getElementById('customHeaderText').value = theme.colors.headerText;
            document.getElementById('customSubheaderText').value = theme.colors.subheaderText;
            document.getElementById('customButtonBg').value = theme.colors.buttonBg;
            document.getElementById('customButtonHover').value = theme.colors.buttonHover;
            document.getElementById('customBorderColor').value = theme.colors.borderColor;
            document.getElementById('customBorderHover').value = theme.colors.borderHover;
            
            // Update preview
            updateCustomPreview();
            
            showMessage(`Theme "${themeName}" loaded into editor`, 'success');
        }

        // Delete a saved theme
        function deleteSavedTheme(themeName) {
            if (!confirm(`Delete theme "${themeName}"?`)) {
                return;
            }
            
            let savedThemes = JSON.parse(localStorage.getItem('saved_custom_themes') || '[]');
            savedThemes = savedThemes.filter(t => t.name !== themeName);
            
            // Save to localStorage
            localStorage.setItem('saved_custom_themes', JSON.stringify(savedThemes));
            
            // Save to OneDrive sync data
            const syncData = JSON.parse(localStorage.getItem('onedrive_sync_data') || '{}');
            syncData.savedThemes = savedThemes;
            localStorage.setItem('onedrive_sync_data', JSON.stringify(syncData));
            
            // Trigger OneDrive sync if connected
            if (typeof oneDriveManager !== 'undefined' && oneDriveManager && oneDriveManager.isAuthenticated()) {
                oneDriveManager.syncToOneDrive();
            }
            
            // Refresh list
            loadSavedThemesList();
            showMessage(`Theme "${themeName}" deleted`, 'success');
        }

        function loadSettingsData() {
            // Load theme preference
            loadThemePreference();
            
            // Load saved themes list
            loadSavedThemesList();
            
            // Load Discogs token
            const token = localStorage.getItem('discogs_api_token');
            const tokenInput = document.getElementById('discogsToken');
            if (token) {
                tokenInput.value = token;
                updateDiscogsStatus('connected');
            } else {
                tokenInput.value = '';
                updateDiscogsStatus('disconnected');
            }
            
            // Load OneDrive status
            updateOneDriveSettingsStatus();
        }

        function saveDiscogsToken() {
            const token = document.getElementById('discogsToken').value.trim();
            
            if (!token) {
                updateDiscogsStatus('error', 'Please enter a token');
                return;
            }
            
            // Validate token format (basic check)
            if (token.length < 20) {
                updateDiscogsStatus('error', 'Token appears to be invalid');
                return;
            }
            
            // Save token
            localStorage.setItem('discogs_api_token', token);
            
            // Test the token
            testDiscogsToken(token);
        }

        async function testDiscogsToken(token) {
            updateDiscogsStatus('disconnected', 'Testing token...');
            
            try {
                const response = await fetch('https://api.discogs.com/database/search?q=test&per_page=1', {
                    headers: {
                        'Authorization': `Discogs token=${token}`,
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (response.ok) {
                    updateDiscogsStatus('connected', ' Token saved and verified successfully!');
                    
                    // Show confirmation alert
                    setTimeout(() => {
                        alert(' Discogs API token saved successfully!\n\nYou can now use the "Find on Discogs" feature when adding albums.');
                    }, 100);
                    
                    // Sync to OneDrive if connected
                    if (oneDriveManager && oneDriveManager.isAuthenticated) {
                        await syncSettingsToOneDrive();
                    }
                } else {
                    updateDiscogsStatus('error', 'Token is invalid. Please check and try again.');
                    localStorage.removeItem('discogs_api_token');
                }
            } catch (error) {
                updateDiscogsStatus('error', 'Could not verify token. It has been saved but may not work.');
            }
        }

        function clearDiscogsToken() {
            if (confirm('Are you sure you want to remove your Discogs API token?')) {
                localStorage.removeItem('discogs_api_token');
                document.getElementById('discogsToken').value = '';
                updateDiscogsStatus('disconnected', 'Token removed');
                
                // Sync to OneDrive if connected
                if (oneDriveManager && oneDriveManager.isAuthenticated) {
                    syncSettingsToOneDrive();
                }
            }
        }

        function updateDiscogsStatus(status, message) {
            const statusDiv = document.getElementById('discogsStatus');
            
            if (status === 'connected') {
                statusDiv.innerHTML = `
                    <div class="settings-status connected">
                         ${message || 'Connected to Discogs'}
                    </div>
                `;
            } else if (status === 'disconnected') {
                statusDiv.innerHTML = `
                    <div class="settings-status disconnected">
                         ${message || 'Not configured'}
                    </div>
                `;
            } else if (status === 'error') {
                statusDiv.innerHTML = `
                    <div class="settings-status error">
                         ${message || 'Error'}
                    </div>
                `;
            }
        }

        function updateOneDriveSettingsStatus() {
            const statusDiv = document.getElementById('oneDriveSettingsStatus');
            const buttonsDiv = document.getElementById('oneDriveSettingsButtons');
            
            if (!statusDiv || !buttonsDiv) return;
            
            if (syncManager && syncManager.isConnected()) {
                const lastSync = localStorage.getItem('last_sync_time');
                const lastSyncText = lastSync ? new Date(lastSync).toLocaleString() : 'Never';
                
                statusDiv.innerHTML = `
                    <div class="settings-status connected">
                         Connected to OneDrive<br>
                        <small>Last synced: ${lastSyncText}</small>
                    </div>
                `;
                
                buttonsDiv.innerHTML = `
                    <button onclick="disconnectOneDriveFromSettings()" class="settings-btn settings-btn-secondary">
                        Disconnect from OneDrive
                    </button>
                    <button onclick="syncManager.syncToOneDrive()" class="settings-btn settings-btn-primary">
                        Sync Now
                    </button>
                `;
            } else {
                statusDiv.innerHTML = `
                    <div class="settings-status disconnected">
                         Not connected
                    </div>
                `;
                
                buttonsDiv.innerHTML = `
                    <button onclick="syncManager.connect()" class="settings-btn settings-btn-primary">
                        Connect to OneDrive
                    </button>
                `;
            }
        }

        function disconnectOneDriveFromSettings() {
            if (confirm('Are you sure you want to disconnect from OneDrive? Your local data will not be affected.')) {
                syncManager.disconnect();
                updateOneDriveSettingsStatus();
                syncManager.updateUI();
            }
        }

        async function syncSettingsToOneDrive() {
            // Sync settings (like API tokens) to OneDrive
            const settings = {
                discogs_api_token: localStorage.getItem('discogs_api_token')
            };
            
            try {
                await oneDriveManager.saveFile('settings.json', JSON.stringify(settings));
            } catch (error) {
                console.error('Failed to sync settings to OneDrive:', error);
            }
        }

        function showDiscogsInstructions() {
            const modal = document.getElementById('instructionsModal');
            modal.classList.add('active');
        }

        function closeInstructions() {
            const modal = document.getElementById('instructionsModal');
            modal.classList.remove('active');
        }

        // Discogs Integration Functions
        async function searchDiscogs() {
            const artist = document.getElementById('quickSearchArtist').value.trim();
            const album = document.getElementById('quickSearchAlbum').value.trim();
            const statusDiv = document.getElementById('discogsSearchStatus');
            
            if (!artist || !album) {
                showDiscogsStatus('Please enter both artist and album name.', 'error');
                return;
            }
            
            // Check if API token is configured
            const apiToken = localStorage.getItem('discogs_api_token');
            if (!apiToken) {
                showDiscogsStatus(' Discogs API not configured. Please add your API token in Settings.', 'error');
                setTimeout(() => {
                    if (confirm('Would you like to open Settings to add your Discogs API token?')) {
                        openSettings();
                    }
                }, 500);
                return;
            }
            
            showDiscogsStatus(' Searching Discogs...', 'loading');
            
            try {
                const query = `${artist} ${album}`;
                
                // First, try to find master release
                const masterUrl = `https://api.discogs.com/database/search?q=${encodeURIComponent(query)}&type=master&token=${apiToken}`;
                
                const masterResponse = await fetch(masterUrl, {
                    headers: {
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (!masterResponse.ok) {
                    throw new Error(`Discogs API error: ${masterResponse.status}`);
                }
                
                const masterData = await masterResponse.json();
                
                // If we found a master release with exact match, use it immediately
                if (masterData.results && masterData.results.length > 0) {
                    const exactMaster = masterData.results.find(m => {
                        const titleLower = m.title.toLowerCase();
                        const albumLower = album.toLowerCase();
                        const artistLower = artist.toLowerCase();
                        
                        // Check if title contains album name and artist name
                        return titleLower.includes(albumLower) && titleLower.includes(artistLower);
                    });
                    
                    if (exactMaster) {
                        // Found exact master match - auto-fill immediately
                        showDiscogsStatus(' Found master release! Auto-filling...', 'success');
                        await fetchAlbumDetails(exactMaster.id, true);
                        return;
                    }
                }
                
                // If no exact master found, search all releases
                const url = `https://api.discogs.com/database/search?q=${encodeURIComponent(query)}&type=release&token=${apiToken}`;
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Discogs API error: ${response.status}`);
                }
                
                const data = await response.json();
                
                // Combine master and release results
                let albums = [];
                if (masterData.results) {
                    albums = albums.concat(masterData.results);
                }
                if (data.results) {
                    albums = albums.concat(data.results.filter(r => r.type === 'release' || r.type === 'master'));
                }
                
                if (albums.length === 0) {
                    showDiscogsStatus(' No results found. Try different search terms or search manually.', 'error');
                    return;
                }
                
                // Remove duplicates (same ID)
                const uniqueAlbums = [];
                const seenIds = new Set();
                albums.forEach(a => {
                    if (!seenIds.has(a.id)) {
                        seenIds.add(a.id);
                        uniqueAlbums.push(a);
                    }
                });
                albums = uniqueAlbums;
                
                // Sort: masters first, then by year (newest first)
                albums.sort((a, b) => {
                    if (a.type === 'master' && b.type !== 'master') return -1;
                    if (a.type !== 'master' && b.type === 'master') return 1;
                    return (b.year || 0) - (a.year || 0);
                });
                
                // If there's only one master and multiple releases, auto-select the master
                const masters = albums.filter(a => a.type === 'master');
                if (masters.length === 1 && albums.length > 1) {
                    showDiscogsStatus(' Found master release! Auto-filling...', 'success');
                    await fetchAlbumDetails(masters[0].id, true);
                    return;
                }
                
                // Check for clear match
                const exactMatch = albums.find(a => {
                    const titleLower = a.title.toLowerCase();
                    const albumLower = album.toLowerCase();
                    const artistLower = artist.toLowerCase();
                    return titleLower.includes(albumLower) && titleLower.includes(artistLower);
                });
                
                if (albums.length === 1) {
                    // Single result - auto-fill
                    const selectedAlbum = albums[0];
                    const isMaster = selectedAlbum.type === 'master';
                    await fetchAlbumDetails(selectedAlbum.id, isMaster);
                } else if (exactMatch && albums.length <= 3 && exactMatch.type === 'master') {
                    // Exact master match with few results - auto-fill
                    await fetchAlbumDetails(exactMatch.id, true);
                } else {
                    // Multiple matches - show selection UI
                    showDiscogsResults(albums.slice(0, 10)); // Show top 10 results
                }
                
            } catch (error) {
                console.error('Discogs search error:', error);
                showDiscogsStatus(' Error searching Discogs. Please try again or search manually.', 'error');
            }
        }

        async function fetchAlbumDetails(releaseId, isMaster = false) {
            const apiToken = localStorage.getItem('discogs_api_token');
            const statusDiv = document.getElementById('discogsSearchStatus');
            
            showDiscogsStatus(' Loading album details...', 'loading');
            
            try {
                // Use appropriate endpoint based on whether it's a master or release
                const endpoint = isMaster ? 'masters' : 'releases';
                const url = `https://api.discogs.com/${endpoint}/${releaseId}?token=${apiToken}`;
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'AlbumTracker/1.0'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Discogs API error: ${response.status}`);
                }
                
                const album = await response.json();
                
                // Auto-fill form fields
                fillFormFromDiscogs(album);
                
                showDiscogsStatus(' Album details loaded! Review and save below.', 'success');
                
                // Close results modal if open
                closeDiscogsResults();
                
            } catch (error) {
                console.error('Error fetching album details:', error);
                showDiscogsStatus(' Error loading album details. Please try again.', 'error');
            }
        }

        function fillFormFromDiscogs(album) {
            // Extract data from Discogs response
            const albumName = album.title || '';
            // Join all artists with "; " separator (handles multiple artists)
            const artist = album.artists && album.artists.length > 0 
                ? album.artists.map(a => a.name).join('; ') 
                : '';
            const year = album.year || new Date().getFullYear();
            const genres = album.genres ? album.genres.join('; ') : '';
            const styles = album.styles ? album.styles.join('; ') : '';
            const labels = album.labels ? album.labels.map(l => l.name).join('; ') : '';
            const artworkUrl = album.images && album.images.length > 0 ? album.images[0].uri : '';
            const discogsUrl = album.uri || '';
            
            // Fill inline form fields
            document.getElementById('albumNameInline').value = albumName;
            document.getElementById('artistInline').value = artist;
            document.getElementById('yearInline').value = year;
            document.getElementById('genreInline').value = genres;
            document.getElementById('styleInline').value = styles;
            document.getElementById('reasonInline').value = labels ? `Discogs: ${labels}` : 'Discogs';
            document.getElementById('artworkUrlInline').value = artworkUrl;
            document.getElementById('discogsUrlInline').value = discogsUrl;
            
            // Scroll to form
            document.getElementById('addAlbumFormInline').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function showDiscogsResults(results) {
            const modal = document.getElementById('discogsResultsModal');
            const listDiv = document.getElementById('discogsResultsList');
            
            listDiv.innerHTML = results.map((result, index) => {
                const title = result.title || 'Unknown Album';
                const year = result.year || 'Unknown';
                const format = result.format ? result.format.join(', ') : 'Unknown';
                const label = result.label ? result.label.join(', ') : 'Unknown';
                const country = result.country || 'Unknown';
                const imageUrl = result.thumb || result.cover_image || '';
                const isMaster = result.type === 'master';
                const typeLabel = isMaster ? ' <span style="background: #667eea; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.8em;">MASTER</span>' : '';
                
                return `
                    <div class="discogs-result-card" onclick="selectDiscogsResult(${result.id}, ${isMaster})">
                        ${imageUrl ? `<img src="${imageUrl}" alt="${title}" class="discogs-result-image">` : '<div class="discogs-result-image"></div>'}
                        <div class="discogs-result-info">
                            <div class="discogs-result-title">${title}${typeLabel}</div>
                            <div class="discogs-result-details">
                                <strong>Year:</strong> ${year}<br>
                                <strong>Format:</strong> ${format}<br>
                                <strong>Label:</strong> ${label}<br>
                                <strong>Country:</strong> ${country}
                            </div>
                        </div>
                        <button class="discogs-result-button" onclick="event.stopPropagation(); selectDiscogsResult(${result.id}, ${isMaster})">
                            Select This
                        </button>
                    </div>
                `;
            }).join('');
            
            modal.classList.add('active');
            showDiscogsStatus('', 'hidden');
        }

        function selectDiscogsResult(releaseId, isMaster = false) {
            fetchAlbumDetails(releaseId, isMaster);
        }

        function closeDiscogsResults() {
            const modal = document.getElementById('discogsResultsModal');
            modal.classList.remove('active');
        }

        function showDiscogsStatus(message, type) {
            const statusDiv = document.getElementById('discogsSearchStatus');
            statusDiv.textContent = message;
            statusDiv.style.display = message ? 'block' : 'none';
            
            // Set colors based on type
            if (type === 'error') {
                statusDiv.style.background = '#fee';
                statusDiv.style.color = '#c33';
                statusDiv.style.border = '1px solid #fcc';
            } else if (type === 'success') {
                statusDiv.style.background = '#efe';
                statusDiv.style.color = '#3a3';
                statusDiv.style.border = '1px solid #cfc';
            } else if (type === 'loading') {
                statusDiv.style.background = '#fef9e7';
                statusDiv.style.color = '#856404';
                statusDiv.style.border = '1px solid #ffeaa7';
            } else {
                statusDiv.style.display = 'none';
            }
        }

        function clearQuickSearch() {
            document.getElementById('quickSearchArtist').value = '';
            document.getElementById('quickSearchAlbum').value = '';
            document.getElementById('discogsUrl').value = '';
            showDiscogsStatus('', 'hidden');
        }

        async function fetchFromDiscogsUrl() {
            const urlInput = document.getElementById('discogsUrl').value.trim();
            
            if (!urlInput) {
                showDiscogsStatus('Please enter a Discogs URL.', 'error');
                return;
            }
            
            // Check if API token is configured
            const apiToken = localStorage.getItem('discogs_api_token');
            if (!apiToken) {
                showDiscogsStatus(' Discogs API not configured. Please add your API token in Settings.', 'error');
                setTimeout(() => {
                    if (confirm('Would you like to open Settings to add your Discogs API token?')) {
                        openSettings();
                    }
                }, 500);
                return;
            }
            
            // Extract release ID from URL
            // Formats: https://www.discogs.com/release/123456 or https://www.discogs.com/Artist-Album/release/123456
            let releaseId = null;
            let isMaster = false;
            
            const releaseMatch = urlInput.match(/\/release\/(\d+)/);
            const masterMatch = urlInput.match(/\/master\/(\d+)/);
            
            if (releaseMatch) {
                releaseId = releaseMatch[1];
                isMaster = false;
            } else if (masterMatch) {
                releaseId = masterMatch[1];
                isMaster = true;
            } else {
                showDiscogsStatus(' Invalid Discogs URL. Please use a release or master URL.', 'error');
                return;
            }
            
            showDiscogsStatus(' Loading album from Discogs URL...', 'loading');
            
            try {
                await fetchAlbumDetails(releaseId, isMaster);
            } catch (error) {
                console.error('Error fetching from URL:', error);
                showDiscogsStatus(' Error loading album from URL. Please check the URL and try again.', 'error');
            }
        }

        function openDiscogsManually() {
            const artist = document.getElementById('quickSearchArtist').value.trim();
            const album = document.getElementById('quickSearchAlbum').value.trim();
            
            let url = 'https://www.discogs.com/search/';
            if (artist || album) {
                const query = `${artist} ${album}`.trim();
                url += `?q=${encodeURIComponent(query)}&type=release`;
            }
            
            window.open(url, '_blank');
        }

        function exportBackup() {
            // Use existing export functionality
            exportToExcel();
        }

        function confirmClearData() {
            if (confirm(' WARNING: This will delete ALL your album data from this device!\n\nThis action cannot be undone. Are you absolutely sure?')) {
                if (confirm('This is your last chance! Click OK to permanently delete all data.')) {
                    localStorage.removeItem('albumTrackerData');
                    db.albums = [];
                    db.saveToStorage();
                    
                    // Sync empty data to OneDrive so other devices also clear
                    if (syncManager && syncManager.isConnected()) {
                        syncManager.syncToOneDrive();
                    }
                    
                    alert('All data has been cleared and synced to OneDrive.');
                    closeSettings();
                    loadBrowseSection();
                }
            }
        }

        // Duplicate Cleanup Functions
        let duplicatesToDelete = [];

        function openDuplicateCleanup() {
            const modal = document.getElementById('duplicateCleanupModal');
            modal.classList.add('active');
            scanForDuplicates();
        }

        function closeDuplicateCleanup() {
            const modal = document.getElementById('duplicateCleanupModal');
            modal.classList.remove('active');
            duplicatesToDelete = [];
        }

        function scanForDuplicates() {
            const content = document.getElementById('duplicateCleanupContent');
            content.innerHTML = '<p style="color: #666;">Scanning for duplicates...</p>';

            // Find potential duplicates
            const duplicateGroups = [];
            const processed = new Set();

            db.albums.forEach((album, index) => {
                if (processed.has(album.id)) return;

                const potentialDupes = db.albums.filter((other, otherIndex) => {
                    if (otherIndex === index || processed.has(other.id)) return false;
                    
                    // Check if album names match
                    const nameMatch = String(album.albumName).toLowerCase().trim() === 
                                    String(other.albumName).toLowerCase().trim();
                    
                    if (!nameMatch) return false;

                    // Check if artist names are similar
                    const artist1 = String(album.artist).toLowerCase().trim();
                    const artist2 = String(other.artist).toLowerCase().trim();
                    
                    // Exact match
                    if (artist1 === artist2) return true;
                    
                    // Check if only difference is semicolon vs comma
                    const artist1Normalized = artist1.replace(/[;,]/g, '|').split('|').map(s => s.trim()).sort().join('|');
                    const artist2Normalized = artist2.replace(/[;,]/g, '|').split('|').map(s => s.trim()).sort().join('|');
                    
                    return artist1Normalized === artist2Normalized;
                });

                if (potentialDupes.length > 0) {
                    const group = [album, ...potentialDupes];
                    group.forEach(a => processed.add(a.id));
                    duplicateGroups.push(group);
                }
            });

            if (duplicateGroups.length === 0) {
                content.innerHTML = `
                    <div class="alert alert-success">
                        <strong> No duplicates found!</strong>
                        <p>Your album collection is clean.</p>
                    </div>
                `;
                document.getElementById('deleteDuplicatesBtn').style.display = 'none';
                return;
            }

            // Count confidence levels
            const decisions = duplicateGroups.map(g => decideDuplicateAction(g));
            const highConfidence = decisions.filter(d => d.confidence === 'high').length;
            const mediumConfidence = decisions.filter(d => d.confidence === 'medium').length;
            const lowConfidence = decisions.filter(d => d.confidence === 'low').length;
            const totalToDelete = decisions.reduce((sum, d) => sum + d.deleteIndices.length, 0);

            // Display duplicate groups
            let html = `
                <div class="alert alert-info">
                    <strong>Found ${duplicateGroups.length} duplicate group(s)</strong>
                    <p>Review the albums below and confirm which ones to delete.</p>
                    <div style="margin-top: 10px; font-size: 0.9em;">
                        <strong>Confidence:</strong> 
                        <span style="color: #28a745;"></span> High: ${highConfidence} | 
                        <span style="color: #ffc107;"></span> Medium: ${mediumConfidence} | 
                        <span style="color: #dc3545;"></span> Low: ${lowConfidence}
                    </div>
                    <div style="margin-top: 10px;">
                        <button onclick="selectAllMarkedDelete()" class="btn btn-sm" style="margin-right: 5px;">Select All Marked Delete</button>
                        <button onclick="selectHighConfidenceOnly()" class="btn btn-sm" style="margin-right: 5px;">Select High Confidence Only</button>
                        <button onclick="deselectAll()" class="btn btn-sm">Deselect All</button>
                    </div>
                </div>
            `;

            duplicateGroups.forEach((group, groupIndex) => {
                const decision = decideDuplicateAction(group);
                const confidenceColor = decision.confidence === 'high' ? '#28a745' : 
                                       decision.confidence === 'medium' ? '#ffc107' : '#dc3545';
                const confidenceLabel = decision.confidence.toUpperCase();

                html += `
                    <div class="duplicate-group" data-confidence="${decision.confidence}">
                        <h4 style="margin-bottom: 10px;">
                            ${group[0].albumName} - ${group[0].artist}
                            <span style="color: ${confidenceColor}; font-size: 0.8em; margin-left: 10px;">
                                 ${confidenceLabel} CONFIDENCE
                            </span>
                        </h4>
                        <div style="font-size: 0.85em; color: #666; margin-bottom: 15px; font-style: italic;">
                            ${decision.reason}
                        </div>
                `;

                group.forEach((album, itemIndex) => {
                    // Use itemIndex instead of album.id to distinguish albums with same ID
                    const action = decision.keepIndices.includes(itemIndex) ? 'keep' : 
                                 decision.deleteIndices.includes(itemIndex) ? 'delete' : 'query';
                    
                    const checked = action === 'delete' ? 'checked' : '';
                    const badge = action === 'keep' ? '<span class="duplicate-badge badge-keep"> KEEP</span>' :
                                action === 'delete' ? '<span class="duplicate-badge badge-delete"> DELETE</span>' :
                                '<span class="duplicate-badge badge-query">? REVIEW</span>';

                    // Use unique identifier combining group and item index
                    const uniqueId = `${groupIndex}-${itemIndex}`;
                    const albumIndex = db.albums.indexOf(album);

                    html += `
                        <div class="duplicate-item ${action}" id="duplicate-${uniqueId}" data-confidence="${decision.confidence}">
                            <input type="checkbox" 
                                   class="duplicate-checkbox" 
                                   id="check-${uniqueId}" 
                                   data-album-index="${albumIndex}"
                                   data-album-id="${album.id}"
                                   data-confidence="${decision.confidence}"
                                   ${checked}
                                   onchange="toggleDuplicateSelection('${uniqueId}', ${albumIndex})">
                            <div class="duplicate-info">
                                <div><strong>ID:</strong> ${album.id} ${badge}</div>
                                <div><strong>Artist:</strong> ${album.artist}</div>
                                <div><strong>Year:</strong> ${album.year || 'N/A'}</div>
                                <div><strong>Score:</strong> ${album.score || 'Unrated'}</div>
                                <div><strong>Genre:</strong> ${album.genre || 'N/A'}</div>
                                ${album.discogsUrl ? `<div><strong>Discogs:</strong> <a href="${album.discogsUrl}" target="_blank">View</a></div>` : ''}
                            </div>
                        </div>
                    `;
                });

                html += '</div>';
            });

            content.innerHTML = html;
            
            // Initialize duplicatesToDelete with auto-selected items
            duplicatesToDelete = [];
            duplicateGroups.forEach(group => {
                const decision = decideDuplicateAction(group);
                // Push album objects based on deleteIndices
                const albumsToDelete = decision.deleteIndices.map(index => group[index]);
                duplicatesToDelete.push(...albumsToDelete);
            });

            document.getElementById('deleteDuplicatesBtn').style.display = 'block';
        }

        function decideDuplicateAction(group) {
            const decision = { keepIndices: [], deleteIndices: [], confidence: 'low', reason: '' };

            // Helper function to convert albums to their indices in the group
            const getIndices = (albums) => albums.map(album => group.indexOf(album));

            // Rule 1: Semicolon vs Comma in artist names
            const semicolonVersions = group.filter(a => String(a.artist).includes(';'));
            const commaVersions = group.filter(a => String(a.artist).includes(',') && !String(a.artist).includes(';'));
            
            if (semicolonVersions.length > 0 && commaVersions.length > 0) {
                // Check if comma versions are rated
                const ratedCommaVersions = commaVersions.filter(a => a.score && a.score !== '');
                const ratedSemicolonVersions = semicolonVersions.filter(a => a.score && a.score !== '');
                
                // Exception: If comma version is rated and semicolon is not, keep comma version
                if (ratedCommaVersions.length > 0 && ratedSemicolonVersions.length === 0) {
                    decision.keepIndices.push(group.indexOf(ratedCommaVersions[0]));
                    decision.deleteIndices.push(...getIndices(commaVersions.filter(a => a !== ratedCommaVersions[0])));
                    decision.deleteIndices.push(...getIndices(semicolonVersions));
                    decision.confidence = 'high';
                    decision.reason = 'Rated comma version kept over unrated semicolon version';
                    return decision;
                }
                
                // Default: Keep semicolon version, delete comma versions
                decision.keepIndices.push(group.indexOf(semicolonVersions[0]));
                decision.deleteIndices.push(...getIndices(commaVersions));
                
                // If multiple semicolon versions, mark as medium confidence
                if (semicolonVersions.length > 1) {
                    decision.deleteIndices.push(...getIndices(semicolonVersions.slice(1)));
                    decision.confidence = 'medium';
                    decision.reason = 'Multiple semicolon versions - kept first one';
                } else {
                    decision.confidence = 'high';
                    decision.reason = 'Semicolon separator preferred over comma';
                }
                return decision;
            }

            // Rule 2: Rated vs Unrated
            const ratedAlbums = group.filter(a => a.score && a.score !== '');
            const unratedAlbums = group.filter(a => !a.score || a.score === '');
            
            if (ratedAlbums.length === 1 && unratedAlbums.length > 0) {
                decision.keepIndices.push(group.indexOf(ratedAlbums[0]));
                decision.deleteIndices.push(...getIndices(unratedAlbums));
                decision.confidence = 'high';
                decision.reason = 'Rated version kept over unrated';
                return decision;
            }
            
            if (ratedAlbums.length > 1) {
                // Multiple rated versions - need manual review
                decision.keepIndices.push(group.indexOf(ratedAlbums[0]));
                decision.deleteIndices.push(...getIndices(ratedAlbums.slice(1)));
                decision.deleteIndices.push(...getIndices(unratedAlbums));
                decision.confidence = 'low';
                decision.reason = 'Multiple rated versions - manual review needed';
                return decision;
            }

            // Rule 3: Same details except ID - keep lowest ID
            const allSame = group.every(a => 
                a.albumName === group[0].albumName &&
                a.artist === group[0].artist &&
                (a.year || '') === (group[0].year || '') &&
                (a.genre || '') === (group[0].genre || '') &&
                (a.score || '') === (group[0].score || '')
            );

            if (allSame) {
                const sorted = [...group].sort((a, b) => a.id - b.id);
                decision.keepIndices.push(group.indexOf(sorted[0]));
                decision.deleteIndices.push(...getIndices(sorted.slice(1)));
                decision.confidence = 'high';
                decision.reason = 'Identical albums - kept lowest ID';
                return decision;
            }

            // Rule 4: Different years - likely different editions
            const years = [...new Set(group.map(a => a.year).filter(y => y))];
            if (years.length > 1) {
                decision.keepIndices.push(0);
                decision.deleteIndices.push(...Array.from({length: group.length - 1}, (_, i) => i + 1));
                decision.confidence = 'low';
                decision.reason = 'Different years - possibly different editions';
                return decision;
            }

            // Rule 5: Different genres - uncertain
            const genres = [...new Set(group.map(a => a.genre).filter(g => g))];
            if (genres.length > 1) {
                decision.keepIndices.push(0);
                decision.deleteIndices.push(...Array.from({length: group.length - 1}, (_, i) => i + 1));
                decision.confidence = 'low';
                decision.reason = 'Different genres - manual review needed';
                return decision;
            }

            // Default: Can't decide automatically
            decision.keepIndices.push(0);
            decision.deleteIndices.push(...Array.from({length: group.length - 1}, (_, i) => i + 1));
            decision.confidence = 'low';
            decision.reason = 'Unable to determine automatically';
            return decision;
        }

        function toggleDuplicateSelection(uniqueId, albumIndex) {
            const checkbox = document.getElementById(`check-${uniqueId}`);
            const item = document.getElementById(`duplicate-${uniqueId}`);
            const album = db.albums[albumIndex];
            
            if (checkbox.checked) {
                // Add to delete list if not already there
                if (!duplicatesToDelete.some(a => db.albums.indexOf(a) === albumIndex)) {
                    duplicatesToDelete.push(album);
                }
                item.classList.add('delete');
                item.classList.remove('keep');
            } else {
                // Remove from delete list
                duplicatesToDelete = duplicatesToDelete.filter(a => db.albums.indexOf(a) !== albumIndex);
                item.classList.add('keep');
                item.classList.remove('delete');
            }
        }

        function selectAllMarkedDelete() {
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            duplicatesToDelete = [];
            
            checkboxes.forEach(checkbox => {
                const uniqueId = checkbox.id.replace('check-', '');
                const item = document.getElementById(`duplicate-${uniqueId}`);
                const badge = item.querySelector('.duplicate-badge');
                const albumIndex = parseInt(checkbox.dataset.albumIndex);
                
                // Check if originally marked for deletion
                if (badge && badge.textContent.includes('DELETE')) {
                    checkbox.checked = true;
                    duplicatesToDelete.push(db.albums[albumIndex]);
                    item.classList.add('delete');
                    item.classList.remove('keep');
                }
            });
            
            alert(`Selected ${duplicatesToDelete.length} albums marked for deletion.`);
        }

        function selectHighConfidenceOnly() {
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            duplicatesToDelete = [];
            
            checkboxes.forEach(checkbox => {
                const uniqueId = checkbox.id.replace('check-', '');
                const item = document.getElementById(`duplicate-${uniqueId}`);
                const badge = item.querySelector('.duplicate-badge');
                const confidence = checkbox.dataset.confidence;
                const albumIndex = parseInt(checkbox.dataset.albumIndex);
                
                // Check if high confidence AND marked for deletion
                if (confidence === 'high' && badge && badge.textContent.includes('DELETE')) {
                    checkbox.checked = true;
                    duplicatesToDelete.push(db.albums[albumIndex]);
                    item.classList.add('delete');
                    item.classList.remove('keep');
                } else {
                    checkbox.checked = false;
                    item.classList.add('keep');
                    item.classList.remove('delete');
                }
            });
            
            alert(`Selected ${duplicatesToDelete.length} high-confidence albums for deletion.`);
        }

        function deselectAll() {
            const checkboxes = document.querySelectorAll('.duplicate-checkbox');
            duplicatesToDelete = [];
            
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
                const uniqueId = checkbox.id.replace('check-', '');
                const item = document.getElementById(`duplicate-${uniqueId}`);
                item.classList.add('keep');
                item.classList.remove('delete');
            });
            
            alert('All selections cleared.');
        }

        function deleteDuplicates() {
            if (duplicatesToDelete.length === 0) {
                alert('No albums selected for deletion.');
                return;
            }

            if (!confirm(`Are you sure you want to delete ${duplicatesToDelete.length} duplicate album(s)?\n\nThis action cannot be undone.`)) {
                return;
            }

            // Delete the selected albums by ID
            duplicatesToDelete.forEach(album => {
                db.deleteAlbum(album.id);
            });

            // Sync to OneDrive immediately
            if (syncManager && syncManager.isConnected()) {
                syncManager.syncToOneDrive();
            }

            alert(`Successfully deleted ${duplicatesToDelete.length} duplicate album(s).\n\nChanges have been synced to OneDrive.`);
            closeDuplicateCleanup();
            loadBrowseSection();
        }

        // Clean Up IDs Function
        function cleanupIDs() {
            if (!confirm('This will renumber all album IDs starting from 1.\n\nExisting IDs will be replaced with sequential numbers.\n\nContinue?')) {
                return;
            }

            // Sort albums by current ID
            const sortedAlbums = [...db.albums].sort((a, b) => a.id - b.id);

            // Reassign IDs sequentially
            sortedAlbums.forEach((album, index) => {
                album.id = index + 1;
            });

            // Update the database
            db.albums = sortedAlbums;
            db.saveToStorage();

            // Sync to OneDrive immediately
            if (syncManager && syncManager.isConnected()) {
                syncManager.syncToOneDrive();
            }

            alert(`Successfully renumbered ${sortedAlbums.length} albums.\n\nIDs now range from 1 to ${sortedAlbums.length}.\n\nChanges have been synced to OneDrive.`);
            loadBrowseSection();
        }

        // Close modals when clicking outside
        document.addEventListener('click', function(event) {
            const settingsModal = document.getElementById('settingsModal');
            const instructionsModal = document.getElementById('instructionsModal');
            const discogsResultsModal = document.getElementById('discogsResultsModal');
            const duplicateCleanupModal = document.getElementById('duplicateCleanupModal');
            
            if (event.target === settingsModal) {
                closeSettings();
            }
            
            if (event.target === instructionsModal) {
                closeInstructions();
            }
            
            if (event.target === discogsResultsModal) {
                closeDiscogsResults();
            }
            
            if (event.target === duplicateCleanupModal) {
                closeDuplicateCleanup();
            }
        });

        // Navigation
        function showSection(sectionId, event) {
            console.log('showSection called with:', sectionId);
            
            // Update active button
            const navButtons = document.querySelectorAll('.nav button');
            console.log('Found nav buttons:', navButtons.length);
            navButtons.forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }

            // Show section
            const sections = document.querySelectorAll('.section');
            console.log('Found sections:', sections.length);
            sections.forEach(section => section.classList.remove('active'));
            
            const targetSection = document.getElementById(sectionId);
            console.log('Target section:', targetSection);
            if (targetSection) {
                targetSection.classList.add('active');
            }

            // Load section-specific content
            if (sectionId === 'browse') {
                loadBrowseSection();
            } else if (sectionId === 'stats') {
                loadStatsSection();
            } else if (sectionId === 'lists') {
                if (allCuratedLists.length === 0) {
                    loadCuratedLists();
                }
            }
        }

        // Show/Hide Add Album Form
        function showAddAlbumForm() {
            document.getElementById('addAlbumFormContainer').style.display = 'block';
            document.getElementById('albumNameInline').focus();
        }

        function hideAddAlbumForm() {
            document.getElementById('addAlbumFormContainer').style.display = 'none';
            document.getElementById('addAlbumFormInline').reset();
        }

        function addAlbumInline(event) {
            event.preventDefault();
            
            const albumData = {
                albumName: document.getElementById('albumNameInline').value,
                artist: document.getElementById('artistInline').value,
                year: document.getElementById('yearInline').value,
                artworkUrl: document.getElementById('artworkUrlInline').value,
                discogsUrl: document.getElementById('discogsUrlInline').value || '',
                genre: document.getElementById('genreInline').value || '',
                style: document.getElementById('styleInline').value || '',
                reason: document.getElementById('reasonInline').value || 'Manual',
                score: document.getElementById('scoreInline').value || null,
                dateListened: null,
                notes: ''
            };

            if (db.isDuplicate(albumData.albumName, albumData.artist)) {
                alert('This album already exists in your collection!');
                return;
            }

            db.addAlbum(albumData);
            autoSyncToOneDrive();
            alert('Album added successfully!');
            hideAddAlbumForm();
            loadBrowseSection();
        }

        // Download Import Template
        function downloadImportTemplate() {
            const headers = ['ID', 'Album Name', 'Artist', 'Year', 'Reason', 'Album Artwork URL', 'Discogs URL', 'Artist ID', 'Genre', 'Style', 'Score', 'Date Listened', 'Notes'];
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([headers]);
            
            // Set column widths
            ws['!cols'] = [
                { wch: 5 },   // ID
                { wch: 30 },  // Album Name
                { wch: 25 },  // Artist
                { wch: 6 },   // Year
                { wch: 20 },  // Reason
                { wch: 50 },  // Album Artwork URL
                { wch: 50 },  // Discogs URL
                { wch: 15 },  // Artist ID
                { wch: 20 },  // Genre
                { wch: 20 },  // Style
                { wch: 6 },   // Score
                { wch: 12 },  // Date Listened
                { wch: 30 }   // Notes
            ];
            
            XLSX.utils.book_append_sheet(wb, ws, 'Template');
            XLSX.writeFile(wb, 'album_import_template.xlsx');
        }

        // Record Player State Management
        let currentPlayingAlbum = null;
        let currentRPM = 33.3;

        // Handle Vinyl Click (opens album modal if playing, otherwise picks random album)
        function handleVinylClick() {
            if (currentPlayingAlbum && currentPlayingAlbum.id) {
                // Album is playing - open the album detail modal
                showAlbumDetail(currentPlayingAlbum.id);
            } else {
                // No album playing - pick a random album
                pickRandomAlbum();
            }
        }

        // Pick Random Album (from vinyl button)
        function pickRandomAlbum() {
            // Navigate to random section and automatically select an album
            showSection('random');
            // Wait for section to be visible, then trigger album selection
            setTimeout(() => {
                selectRandomAlbum();
            }, 100);
        }

        // Play Album on Record Player
        function playAlbum(albumId, albumName, artist, artworkUrl) {
            currentPlayingAlbum = { id: albumId, name: albumName, artist: artist, artwork: artworkUrl };
            
            // Update vinyl label with album artwork
            const albumArtwork = document.getElementById('albumArtwork');
            const labelCenterText = document.getElementById('labelCenterText');
            const vinylText = document.getElementById('vinylText');
            
            albumArtwork.src = artworkUrl;
            albumArtwork.style.display = 'block';
            labelCenterText.style.display = 'none';
            vinylText.style.display = 'none';
            
            // Move tonearm to playing position
            const tonearm = document.getElementById('tonearm');
            tonearm.classList.add('playing');
            
            // Update power switch to ON state
            const switchIndicator = document.getElementById('switchIndicator');
            const powerSwitch = document.getElementById('powerSwitch');
            switchIndicator.classList.add('on');
            powerSwitch.setAttribute('data-tooltip', 'Power On - Click to Remove');
            
            // Show now playing display
            const nowPlayingDisplay = document.getElementById('nowPlayingDisplay');
            const displayText = `Now Playing: ${artist} - ${albumName}`;
            nowPlayingDisplay.textContent = displayText;
            nowPlayingDisplay.setAttribute('data-text', displayText);
            nowPlayingDisplay.classList.add('visible');
            
            // Add scrolling animation if text is too long
            setTimeout(() => {
                if (nowPlayingDisplay.scrollWidth > nowPlayingDisplay.clientWidth) {
                    nowPlayingDisplay.classList.add('scrolling');
                    nowPlayingDisplay.textContent = ''; // Clear text content, use ::before instead
                }
            }, 100);
            
            // Update vinyl button title
            const vinylButton = document.querySelector('.vinyl-button');
            vinylButton.title = 'Now Playing - Click to View Album Details';
            
            // Save state to localStorage
            localStorage.setItem('recordPlayerState', JSON.stringify({
                albumId: albumId,
                albumName: albumName,
                artist: artist,
                artworkUrl: artworkUrl,
                rpm: currentRPM
            }));
        }

        // Remove Album from Record Player
        function removeAlbum() {
            currentPlayingAlbum = null;
            
            // Reset vinyl label
            const albumArtwork = document.getElementById('albumArtwork');
            const labelCenterText = document.getElementById('labelCenterText');
            const vinylText = document.getElementById('vinylText');
            
            albumArtwork.style.display = 'none';
            labelCenterText.style.display = 'block';
            vinylText.style.display = 'block';
            
            // Move tonearm back to rest position
            const tonearm = document.getElementById('tonearm');
            tonearm.classList.remove('playing');
            
            // Update power switch to OFF state
            const switchIndicator = document.getElementById('switchIndicator');
            const powerSwitch = document.getElementById('powerSwitch');
            switchIndicator.classList.remove('on');
            powerSwitch.setAttribute('data-tooltip', 'Power Off');
            
            // Hide now playing display
            const nowPlayingDisplay = document.getElementById('nowPlayingDisplay');
            nowPlayingDisplay.classList.remove('visible');
            nowPlayingDisplay.classList.remove('scrolling');
            nowPlayingDisplay.removeAttribute('data-text');
            nowPlayingDisplay.textContent = '';
            
            // Reset vinyl button title
            const vinylButton = document.querySelector('.vinyl-button');
            vinylButton.title = 'Pick an Album';
            
            // Reset RPM to default
            currentRPM = 33.3;
            updateRPMSpeed();
            
            // Clear saved state from localStorage
            localStorage.removeItem('recordPlayerState');
        }

        // Cycle RPM Speed
        function cycleRPM() {
            if (currentRPM === 33.3) {
                currentRPM = 45;
            } else if (currentRPM === 45) {
                currentRPM = 78;
            } else {
                currentRPM = 33.3;
            }
            updateRPMSpeed();
            
            // Update saved state if album is playing
            if (currentPlayingAlbum) {
                const savedState = localStorage.getItem('recordPlayerState');
                if (savedState) {
                    const state = JSON.parse(savedState);
                    state.rpm = currentRPM;
                    localStorage.setItem('recordPlayerState', JSON.stringify(state));
                }
            }
        }

        // Update RPM Speed
        function updateRPMSpeed() {
            const vinylRecord = document.getElementById('vinylRecord');
            const speedSlider = document.getElementById('speedSlider');
            const sliderHandle = document.getElementById('sliderHandle');
            
            // Remove existing RPM classes
            vinylRecord.classList.remove('rpm-45', 'rpm-78');
            sliderHandle.classList.remove('speed-45', 'speed-78');
            
            // Add appropriate class and update slider position
            if (currentRPM === 45) {
                vinylRecord.classList.add('rpm-45');
                sliderHandle.classList.add('speed-45');
                speedSlider.setAttribute('data-tooltip', 'Speed: 45 RPM');
            } else if (currentRPM === 78) {
                vinylRecord.classList.add('rpm-78');
                sliderHandle.classList.add('speed-78');
                speedSlider.setAttribute('data-tooltip', 'Speed: 78 RPM');
            } else {
                speedSlider.setAttribute('data-tooltip', 'Speed: 33 RPM');
            }
        }

        // Random Album Selection
        // Helper function to create Wikipedia link
        function getWikipediaLink(searchTerm, type, artistName = null) {
            let searchQuery = searchTerm;
            if (type === 'album' && artistName) {
                // Include artist name for album searches to get more accurate results
                searchQuery = `${searchTerm} ${artistName}`;
            }
            const encodedSearch = encodeURIComponent(searchQuery + ' ' + type + ' wikipedia');
            return `https://www.google.com/search?q=${encodedSearch}&btnI=I%27m+Feeling+Lucky`;
        }

        // Helper function to create Wikipedia icon
        function getWikiIcon() {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path>
                <polyline points="15 3 21 3 21 9"></polyline>
                <line x1="10" y1="14" x2="21" y2="3"></line>
            </svg>`;
        }

        // Helper function to create Spotify link
        function getSpotifyLink(albumName, artistName) {
            const searchQuery = `${albumName} ${artistName}`;
            const encodedSearch = encodeURIComponent(searchQuery);
            return `https://open.spotify.com/search/${encodedSearch}`;
        }

        // Helper function to create Spotify icon (green logo)
        function getSpotifyIcon() {
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/>
            </svg>`;
        }

        // Store current random album data
        let currentRandomAlbum = null;

        function selectRandomAlbum() {
            const album = db.getRandomUnscoredAlbum();
            const display = document.getElementById('randomAlbumDisplay');
            const nowPlayingBtn = document.getElementById('randomNowPlayingBtn');

            if (!album) {
                display.innerHTML = `
                    <div class="empty-state" style="color: white;">
                        <h3> All albums have been rated!</h3>
                        <p>You've completed your collection. Add more albums or browse your ratings.</p>
                    </div>
                `;
                nowPlayingBtn.style.display = 'none';
                currentRandomAlbum = null;
                return;
            }

            // Store current album data
            currentRandomAlbum = {
                id: album.id,
                albumName: album.albumName,
                artist: album.artist,
                artworkUrl: album.artworkUrl
            };

            // Show the Now Playing button
            nowPlayingBtn.style.display = 'inline-block';

            const genres = db.parseMultiValue(album.genre, true);
            const styles = db.parseMultiValue(album.style);
            const sources = db.parseMultiValue(album.reason);

            display.innerHTML = `
                <div class="random-album-content">
                    <div>
                        <img src="${album.artworkUrl}" alt="${album.albumName}" class="album-artwork" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22300%22%3E%3Crect fill=%22%23ddd%22 width=%22300%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2220%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    </div>
                    <div class="album-details">
                        <h2>${album.albumName}<a href="${getWikipediaLink(album.albumName, 'album', album.artist)}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia">${getWikiIcon()}</a><a href="${getSpotifyLink(album.albumName, album.artist)}" target="_blank" rel="noopener noreferrer" class="spotify-link" title="Search on Spotify">${getSpotifyIcon()}</a></h2>
                        <p><strong>Artist:</strong> ${album.artist}<a href="${getWikipediaLink(album.artist, 'artist')}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia">${getWikiIcon()}</a></p>
                        <p><strong>Year:</strong> ${album.year}</p>
                        ${genres.length > 0 ? `<p><strong>Genre:</strong> ${genres.join(', ')}</p>` : ''}
                        ${styles.length > 0 ? `<p><strong>Style:</strong> ${styles.join(', ')}</p>` : ''}
                        ${sources.length > 0 ? `<p><strong>Source:</strong> ${sources.join(', ')}</p>` : ''}
                        
                        <div class="rating-form">
                            <h3 style="margin-bottom: 15px;">Rate This Album</h3>
                            <form onsubmit="rateAlbum(event, ${album.id})">
                                <div class="form-group">
                                    <label>Score (0-10) *</label>
                                    <input type="number" id="ratingScore" min="0" max="10" step="0.1" required>
                                </div>
                                <div class="form-group">
                                    <label>Date Listened</label>
                                    <input type="date" id="ratingDate" value="${new Date().toISOString().split('T')[0]}">
                                </div>
                                <div class="form-group">
                                    <label>Notes</label>
                                    <textarea id="ratingNotes" placeholder="Your thoughts..."></textarea>
                                </div>
                                <button type="submit" class="btn btn-success">Submit Rating</button>
                            </form>
                        </div>
                    </div>
                </div>
            `;
        }

        function playRandomAlbum() {
            if (currentRandomAlbum) {
                playAlbum(
                    currentRandomAlbum.id,
                    currentRandomAlbum.albumName,
                    currentRandomAlbum.artist,
                    currentRandomAlbum.artworkUrl
                );
            }
        }

        function rateAlbum(event, albumId) {
            event.preventDefault();
            
            const score = parseFloat(document.getElementById('ratingScore').value);
            const dateListened = document.getElementById('ratingDate').value;
            const notes = document.getElementById('ratingNotes').value;

            db.updateAlbum(albumId, {
                score,
                dateListened,
                notes
            });

            autoSyncToOneDrive();
            showAlert('success', 'Album rated successfully!');
            selectRandomAlbum();
        }

        // Generate Random List of 10 Albums
        function generateRandomList() {
            const albums = db.getAllAlbums();
            if (albums.length === 0) {
                showAlert('warning', 'No albums in your collection!');
                return;
            }

            // Filter to only unrated albums (no score or score is 0)
            const unratedAlbums = albums.filter(album => !album.score || album.score === 0 || album.score === '0');
            
            if (unratedAlbums.length === 0) {
                showAlert('info', 'All albums have been rated! Add more albums to generate a new list.');
                return;
            }

            // Get 10 random unrated albums
            const shuffled = [...unratedAlbums].sort(() => 0.5 - Math.random());
            const randomAlbums = shuffled.slice(0, Math.min(10, unratedAlbums.length));

            // Hide the single album display
            document.getElementById('randomAlbumDisplay').style.display = 'none';
            
            // Show the list display
            const listDisplay = document.getElementById('randomListDisplay');
            listDisplay.style.display = 'block';
            
            // Create the list HTML
            listDisplay.innerHTML = `
                <div style="text-align: center; margin: 30px 0;">
                    <div id="albumListCanvas" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; border-radius: 20px; max-width: 600px; margin: 0 auto; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                        <h2 style="color: white; margin-bottom: 30px; font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);"> My Next 10 Albums</h2>
                        <div style="background: rgba(255,255,255,0.95); padding: 30px; border-radius: 15px; text-align: left;">
                            ${randomAlbums.map((album, index) => `
                                <div style="margin-bottom: 20px; padding-bottom: 20px; ${index < randomAlbums.length - 1 ? 'border-bottom: 2px solid #e0e0e0;' : ''}">
                                    <div style="font-size: 1.3em; font-weight: bold; color: #667eea; margin-bottom: 5px;">
                                        ${index + 1}. ${album.albumName}
                                    </div>
                                    <div style="font-size: 1.1em; color: #555; padding-left: 20px;">
                                        ${album.artist}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div style="margin-top: 20px; color: white; font-size: 0.9em; opacity: 0.8;">
                            Generated ${new Date().toLocaleDateString()}
                        </div>
                    </div>
                    <button class="btn btn-success" onclick="downloadListAsImage()" style="margin-top: 20px; font-size: 1.2em; padding: 15px 40px;">
                         Download as Image
                    </button>
                    <button class="btn btn-secondary" onclick="backToRandomAlbum()" style="margin-top: 20px; margin-left: 10px; font-size: 1.2em; padding: 15px 40px;">
                         Back
                    </button>
                </div>
            `;
        }

        function backToRandomAlbum() {
            document.getElementById('randomListDisplay').style.display = 'none';
            document.getElementById('randomAlbumDisplay').style.display = 'block';
        }

        async function downloadListAsImage() {
            try {
                const element = document.getElementById('albumListCanvas');
                
                if (!element) {
                    showAlert('error', 'List element not found!');
                    return;
                }

                // Show loading message
                showAlert('info', 'Generating image... Please wait.');

                // Use modern approach with dom-to-image-more library (more reliable)
                // Or fallback to manual canvas approach
                await downloadUsingCanvas(element);
                
            } catch (err) {
                console.error('Error generating image:', err);
                showAlert('error', 'Failed to generate image. Please try again.');
            }
        }

        async function downloadUsingCanvas(element) {
            // Create a canvas manually for better browser compatibility
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Get element dimensions
            const rect = element.getBoundingClientRect();
            const scale = 2; // High resolution
            
            canvas.width = rect.width * scale;
            canvas.height = rect.height * scale;
            
            // Scale context for high resolution
            ctx.scale(scale, scale);
            
            // Draw gradient background
            const gradient = ctx.createLinearGradient(0, 0, rect.width, rect.height);
            gradient.addColorStop(0, '#667eea');
            gradient.addColorStop(1, '#764ba2');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, rect.width, rect.height);
            
            // Get all the text content
            const albums = db.getAllAlbums();
            const shuffled = [...albums].sort(() => 0.5 - Math.random());
            const randomAlbums = shuffled.slice(0, Math.min(10, albums.length));
            
            // Draw title
            ctx.fillStyle = 'white';
            ctx.font = 'bold 32px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;
            ctx.fillText(' My Next 10 Albums', rect.width / 2, 60);
            ctx.shadowColor = 'transparent';
            
            // Draw white content box
            ctx.fillStyle = 'rgba(255,255,255,0.95)';
            ctx.fillRect(40, 100, rect.width - 80, rect.height - 180);
            
            // Draw albums
            let yPos = 140;
            ctx.textAlign = 'left';
            
            randomAlbums.forEach((album, index) => {
                // Album name
                ctx.fillStyle = '#667eea';
                ctx.font = 'bold 20px Arial, sans-serif';
                ctx.fillText(`${index + 1}. ${album.albumName}`, 70, yPos);
                
                // Artist name
                ctx.fillStyle = '#555';
                ctx.font = '18px Arial, sans-serif';
                ctx.fillText(album.artist, 90, yPos + 25);
                
                // Divider line (except for last item)
                if (index < randomAlbums.length - 1) {
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(70, yPos + 40);
                    ctx.lineTo(rect.width - 70, yPos + 40);
                    ctx.stroke();
                }
                
                yPos += 60;
            });
            
            // Draw date
            ctx.fillStyle = 'white';
            ctx.font = '14px Arial, sans-serif';
            ctx.textAlign = 'center';
            const dateStr = new Date().toLocaleDateString();
            ctx.fillText(`Generated ${dateStr}`, rect.width / 2, rect.height - 30);
            
            // Convert canvas to blob and download
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `album-list-${new Date().toISOString().split('T')[0]}.png`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                showAlert('success', 'List downloaded successfully!');
            }, 'image/png');
        }

        // Browse Section
        function loadBrowseSection() {
            // Populate filter dropdowns
            const genres = db.getAllGenres();
            const sources = db.getAllSources();

            const genreSelect = document.getElementById('filterGenre');
            genreSelect.innerHTML = '<option value="">All Genres</option>';
            genres.forEach(genre => {
                genreSelect.innerHTML += `<option value="${genre}">${genre}</option>`;
            });

            const sourceSelect = document.getElementById('filterSource');
            sourceSelect.innerHTML = '<option value="">All Sources</option>';
            sources.forEach(source => {
                sourceSelect.innerHTML += `<option value="${source}">${source}</option>`;
            });

            applyFilters();
            setupSearch();
        }

        // Track if search is already set up to prevent duplicate listeners
        let searchSetupComplete = false;

        function setupSearch() {
            // Prevent duplicate setup
            if (searchSetupComplete) {
                console.log('Search already set up, skipping...');
                return;
            }

            const searchInput = document.getElementById('browseSearchInput');
            const searchResults = document.getElementById('browseSearchResults');
            const searchIcon = document.getElementById('browseSearchIcon');
            
            if (!searchInput || !searchResults) {
                console.error('Search elements not found:', { searchInput, searchResults });
                return;
            }
            
            console.log('Setting up search functionality...');

            let searchTimeout;

            // Handle input with debouncing
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();

                if (query.length === 0) {
                    searchResults.classList.remove('active');
                    searchResults.innerHTML = '';
                    return;
                }

                // Debounce search by 300ms
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 300);
            });

            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target) && e.target !== searchIcon) {
                    searchResults.classList.remove('active');
                }
            });

            // Show results when focusing on input with text
            searchInput.addEventListener('focus', (e) => {
                if (e.target.value.trim().length > 0) {
                    performSearch(e.target.value.trim());
                }
            });

            // Handle Enter key to apply filters
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    console.log('Enter key pressed, applying filters...');
                    // Close search dropdown
                    searchResults.classList.remove('active');
                    searchResults.innerHTML = '';
                    
                    // Apply filters using the existing filter system
                    applyFilters();
                }
            });

            // Handle click on search icon to apply filters
            if (searchIcon) {
                console.log('Setting up search icon click handler...');
                searchIcon.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Search icon clicked, applying filters...');
                    // Close search dropdown
                    searchResults.classList.remove('active');
                    searchResults.innerHTML = '';
                    
                    // Apply filters using the existing filter system
                    applyFilters();
                });
            } else {
                console.error('Search icon not found!');
            }

            searchSetupComplete = true;
            console.log('Search setup complete!');
        }



        function performSearch(query) {
            console.log('Performing search for:', query);
            const searchResults = document.getElementById('browseSearchResults');
            const allAlbums = db.getAllAlbums();
            console.log('Total albums:', allAlbums.length);
            if (allAlbums.length > 0) {
                console.log('Sample album:', allAlbums[0]);
                console.log('albumName type:', typeof allAlbums[0].albumName);
                console.log('albumName value:', allAlbums[0].albumName);
            }
            
            // Search in album name and artist name (case insensitive)
            const lowerQuery = query.toLowerCase();
            const matches = allAlbums.filter(album => {
                const albumName = String(album.albumName || '').toLowerCase();
                const artistName = String(album.artist || '').toLowerCase();
                return albumName.includes(lowerQuery) || artistName.includes(lowerQuery);
            });
            console.log('Matches found:', matches.length);

            // Sort matches by relevance (exact matches first, then starts with, then contains)
            matches.sort((a, b) => {
                const aAlbum = String(a.albumName || '').toLowerCase();
                const bAlbum = String(b.albumName || '').toLowerCase();
                const aArtist = String(a.artist || '').toLowerCase();
                const bArtist = String(b.artist || '').toLowerCase();

                // Exact match
                if (aAlbum === lowerQuery || aArtist === lowerQuery) return -1;
                if (bAlbum === lowerQuery || bArtist === lowerQuery) return 1;

                // Starts with
                if (aAlbum.startsWith(lowerQuery) || aArtist.startsWith(lowerQuery)) return -1;
                if (bAlbum.startsWith(lowerQuery) || bArtist.startsWith(lowerQuery)) return 1;

                return 0;
            });

            // Limit to 10 results
            const limitedMatches = matches.slice(0, 10);

            if (limitedMatches.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No albums found</div>';
            } else {
                searchResults.innerHTML = limitedMatches.map(album => `
                    <div class="search-result-item" onclick="openAlbumFromSearch(${album.id})">
                        ${album.artworkUrl ? 
                            `<img src="${album.artworkUrl}" alt="${album.albumName}" class="search-result-artwork" onerror="this.style.display='none'">` :
                            '<div class="search-result-artwork"></div>'
                        }
                        <div class="search-result-info">
                            <div class="search-result-album">${album.albumName}</div>
                            <div class="search-result-artist">${album.artist}</div>
                        </div>
                    </div>
                `).join('');
            }

            searchResults.classList.add('active');
        }

        function openAlbumFromSearch(albumId) {
            const searchInput = document.getElementById('browseSearchInput');
            const searchResults = document.getElementById('browseSearchResults');
            
            // Clear search
            searchInput.value = '';
            searchResults.classList.remove('active');
            searchResults.innerHTML = '';
            
            // Open album modal
            showAlbumDetail(albumId);
        }

        function applyFilters() {
            const genreEl = document.getElementById('filterGenre');
            const sourceEl = document.getElementById('filterSource');
            const statusEl = document.getElementById('filterStatus');
            const sortByEl = document.getElementById('sortBy');
            const searchEl = document.getElementById('browseSearchInput');

            // Check if elements exist
            if (!genreEl || !sourceEl || !statusEl || !sortByEl) {
                console.error('Filter elements not found');
                return;
            }

            const filters = {
                genre: genreEl.value,
                source: sourceEl.value,
                status: statusEl.value,
                searchText: searchEl ? searchEl.value.trim() : ''
            };

            const sortBy = sortByEl.value;

            let albums = db.filterAlbums(filters);
            albums = db.sortAlbums(albums, sortBy);

            displayAlbums(albums);
        }

        function clearFilters() {
            document.getElementById('filterGenre').value = '';
            document.getElementById('filterSource').value = '';
            document.getElementById('filterStatus').value = '';
            document.getElementById('sortBy').value = 'name-asc';
            const searchInput = document.getElementById('browseSearchInput');
            if (searchInput) {
                searchInput.value = '';
            }
            applyFilters();
        }

        // Infinite scroll state
        let allFilteredAlbums = [];
        let displayedAlbumsCount = 0;
        const ALBUMS_PER_BATCH = 500;
        let isLoadingMore = false;
        let multiSelectMode = false;
        let selectedAlbumIds = new Set();

        function displayAlbums(albums) {
            const grid = document.getElementById('albumGrid');

            // Store all albums and reset display count
            allFilteredAlbums = albums;
            displayedAlbumsCount = 0;

            if (albums.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <h3>No albums found</h3>
                        <p>Try adjusting your filters or add some albums to get started.</p>
                    </div>
                `;
                return;
            }

            // Clear existing content
            grid.innerHTML = '';

            // Load first batch
            loadMoreAlbums();

            // Setup infinite scroll
            setupInfiniteScroll();
        }

        function loadMoreAlbums() {
            if (isLoadingMore) return;
            
            const grid = document.getElementById('albumGrid');
            if (!grid) return;

            isLoadingMore = true;

            // Get next batch
            const nextBatch = allFilteredAlbums.slice(
                displayedAlbumsCount, 
                displayedAlbumsCount + ALBUMS_PER_BATCH
            );

            if (nextBatch.length === 0) {
                isLoadingMore = false;
                return;
            }

            // Create document fragment for better performance
            const fragment = document.createDocumentFragment();

            nextBatch.forEach(album => {
                const scoreClass = album.score >= 8 ? 'score-high' : 
                                 album.score >= 5 ? 'score-medium' : 
                                 album.score ? 'score-low' : 'score-unrated';
                const scoreText = album.score !== null && album.score !== undefined && album.score !== '' 
                    ? `${album.score}/10` 
                    : 'Not Rated';

                const albumCard = document.createElement('div');
                albumCard.className = 'album-card';
                albumCard.dataset.albumId = album.id;
                
                if (multiSelectMode) {
                    albumCard.classList.add('multi-select-mode');
                    if (selectedAlbumIds.has(album.id)) {
                        albumCard.classList.add('selected');
                    }
                    albumCard.onclick = (e) => {
                        e.stopPropagation();
                        toggleAlbumSelection(album.id);
                    };
                } else {
                    albumCard.onclick = () => showAlbumDetail(album.id);
                }
                
                albumCard.innerHTML = `
                    ${multiSelectMode ? `<input type="checkbox" class="album-checkbox" ${selectedAlbumIds.has(album.id) ? 'checked' : ''} onclick="event.stopPropagation(); toggleAlbumSelection(${album.id})">` : ''}
                    <img src="${album.artworkUrl}" alt="${album.albumName}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    <div class="album-card-info">
                        <h3>${album.albumName}</h3>
                        <p>${album.artist}</p>
                        <p>${album.year}</p>
                        <span class="score-badge ${scoreClass}">${scoreText}</span>
                    </div>
                `;
                
                fragment.appendChild(albumCard);
            });

            grid.appendChild(fragment);
            displayedAlbumsCount += nextBatch.length;

            // Add loading indicator if there are more albums
            if (displayedAlbumsCount < allFilteredAlbums.length) {
                let loadingIndicator = document.getElementById('loadingIndicator');
                if (!loadingIndicator) {
                    loadingIndicator = document.createElement('div');
                    loadingIndicator.id = 'loadingIndicator';
                    loadingIndicator.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;';
                    loadingIndicator.innerHTML = '<p>Loading more albums...</p>';
                }
                if (!grid.contains(loadingIndicator)) {
                    grid.appendChild(loadingIndicator);
                }
            } else {
                // Remove loading indicator if we're done
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
            }

            isLoadingMore = false;
        }

        function setupInfiniteScroll() {
            // Remove existing scroll listener if any
            if (window.infiniteScrollHandler) {
                window.removeEventListener('scroll', window.infiniteScrollHandler);
            }

            // Create new scroll handler
            window.infiniteScrollHandler = () => {
                if (displayedAlbumsCount >= allFilteredAlbums.length) return;
                if (isLoadingMore) return;

                const scrollPosition = window.innerHeight + window.scrollY;
                const threshold = document.documentElement.scrollHeight - 1000; // Load 1000px before bottom

                if (scrollPosition >= threshold) {
                    loadMoreAlbums();
                }
            };

            window.addEventListener('scroll', window.infiniteScrollHandler);
        }

        function toggleMultiSelectMode() {
            multiSelectMode = !multiSelectMode;
            selectedAlbumIds.clear();
            
            const controlsDiv = document.getElementById('multiSelectControls');
            const modeBtn = document.getElementById('multiSelectModeBtn');
            
            if (multiSelectMode) {
                controlsDiv.style.display = 'block';
                modeBtn.textContent = ' Exit Multi-Select';
            } else {
                controlsDiv.style.display = 'none';
                modeBtn.textContent = ' Multi-Select';
            }
            
            updateSelectedCount();
            applyFilters(); // Refresh display
        }

        function toggleAlbumSelection(albumId) {
            if (selectedAlbumIds.has(albumId)) {
                selectedAlbumIds.delete(albumId);
            } else {
                selectedAlbumIds.add(albumId);
            }
            
            // Update the card's visual state
            const card = document.querySelector(`[data-album-id="${albumId}"]`);
            if (card) {
                card.classList.toggle('selected');
                const checkbox = card.querySelector('.album-checkbox');
                if (checkbox) {
                    checkbox.checked = selectedAlbumIds.has(albumId);
                }
            }
            
            updateSelectedCount();
        }

        function toggleSelectAll() {
            const allCurrentIds = allFilteredAlbums.map(a => a.id);
            
            if (selectedAlbumIds.size === allCurrentIds.length) {
                // Deselect all
                selectedAlbumIds.clear();
                document.getElementById('selectAllText').textContent = 'Select All';
            } else {
                // Select all filtered albums
                allCurrentIds.forEach(id => selectedAlbumIds.add(id));
                document.getElementById('selectAllText').textContent = 'Deselect All';
            }
            
            updateSelectedCount();
            applyFilters(); // Refresh display
        }

        function updateSelectedCount() {
            const count = selectedAlbumIds.size;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('deleteSelectedBtn').disabled = count === 0;
            
            // Update Select All button text
            const allCurrentIds = allFilteredAlbums.map(a => a.id);
            if (selectedAlbumIds.size === allCurrentIds.length && allCurrentIds.length > 0) {
                document.getElementById('selectAllText').textContent = 'Deselect All';
            } else {
                document.getElementById('selectAllText').textContent = 'Select All';
            }
        }

        function deleteSelectedAlbums() {
            const count = selectedAlbumIds.size;
            if (count === 0) return;
            
            const confirmMsg = `Are you sure you want to delete ${count} album${count > 1 ? 's' : ''}? This action cannot be undone.`;
            
            if (confirm(confirmMsg)) {
                // Delete each selected album
                selectedAlbumIds.forEach(id => {
                    db.deleteAlbum(id);
                });
                
                autoSyncToOneDrive();
                showAlert('success', `Successfully deleted ${count} album${count > 1 ? 's' : ''}!`);
                
                // Clear selection and exit multi-select mode
                selectedAlbumIds.clear();
                multiSelectMode = false;
                document.getElementById('multiSelectControls').style.display = 'none';
                document.getElementById('multiSelectModeBtn').textContent = ' Multi-Select';
                
                // Refresh the display
                applyFilters();
            }
        }

        function showAlbumDetail(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            const genres = db.parseMultiValue(album.genre, true);
            const styles = db.parseMultiValue(album.style);
            const sources = db.parseMultiValue(album.reason);

            const modalContent = document.getElementById('albumModalContent');
            modalContent.innerHTML = `
                <div style="display: grid; grid-template-columns: 300px 1fr; gap: 30px; margin-top: 40px;">
                    <div>
                        <img src="${album.artworkUrl}" alt="${album.albumName}" style="width: 100%; border-radius: 12px;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22300%22%3E%3Crect fill=%22%23ddd%22 width=%22300%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2220%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    </div>
                    <div>
                        <h2 style="margin-bottom: 20px;">${album.albumName}<a href="${getWikipediaLink(album.albumName, 'album', album.artist)}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia" style="color: #667eea;">${getWikiIcon()}</a><a href="${getSpotifyLink(album.albumName, album.artist)}" target="_blank" rel="noopener noreferrer" class="spotify-link" title="Search on Spotify">${getSpotifyIcon()}</a></h2>
                        <p style="margin-bottom: 10px;"><strong>Artist:</strong> ${album.artist}<a href="${getWikipediaLink(album.artist, 'artist')}" target="_blank" rel="noopener noreferrer" class="wiki-link" title="Search Wikipedia" style="color: #667eea;">${getWikiIcon()}</a></p>
                        <p style="margin-bottom: 10px;"><strong>Year:</strong> ${album.year}</p>
                        ${album.artistId ? `<p style="margin-bottom: 10px;"><strong>Artist ID:</strong> ${album.artistId}</p>` : ''}
                        ${album.discogsUrl ? `<p style="margin-bottom: 10px;"><a href="${album.discogsUrl}" target="_blank" style="color: #667eea; text-decoration: none;">View on Discogs</a></p>` : ''}
                        
                        ${genres.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Genres:</strong>
                                <div class="tags-container">
                                    ${genres.map(g => `<span class="tag">${g}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${styles.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Styles:</strong>
                                <div class="tags-container">
                                    ${styles.map(s => `<span class="tag">${s}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${sources.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Source Lists:</strong>
                                <div class="tags-container">
                                    ${sources.map(s => `<span class="tag">${s}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${album.score !== null && album.score !== undefined && album.score !== '' ? `
                            <p style="margin: 15px 0;"><strong>Score:</strong> <span style="font-size: 1.5em; color: #667eea;">${album.score}/10</span></p>
                        ` : '<p style="margin: 15px 0; color: #6c757d;">Not yet rated</p>'}
                        
                        ${album.dateListened ? `<p style="margin-bottom: 10px;"><strong>Date Listened:</strong> ${new Date(album.dateListened).toLocaleDateString()}</p>` : ''}
                        
                        ${album.notes ? `
                            <div style="margin-top: 20px;">
                                <strong>Notes:</strong>
                                <p style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px;">${album.notes}</p>
                            </div>
                        ` : ''}
                        
                        <div style="margin-top: 30px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                                <button class="btn btn-primary" onclick="playAlbum(${album.id}, '${album.albumName.replace(/'/g, "\\'")}', '${album.artist.replace(/'/g, "\\'")}', '${album.artworkUrl}'); closeModal();" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 0.95em; padding: 10px;"> Play This Record</button>
                                <button class="btn" onclick="scoreAlbum(${album.id})" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-size: 0.95em; padding: 10px;">Score Album</button>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <button class="btn" onclick="editAlbum(${album.id})" style="font-size: 0.95em; padding: 10px;">Edit Album</button>
                                <button class="btn btn-danger" onclick="deleteAlbumConfirm(${album.id})" style="font-size: 0.95em; padding: 10px;">Delete</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('albumModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('albumModal').classList.remove('active');
        }

        let previousSection = 'browse'; // Track which section we were in before editing

        function editAlbum(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            // Remember which section we're currently in
            const sections = ['browse', 'stats', 'import', 'add'];
            for (const section of sections) {
                if (document.getElementById(section).classList.contains('active')) {
                    previousSection = section;
                    break;
                }
            }

            closeModal();
            showSection('add');
            
            // Populate form
            document.getElementById('albumName').value = album.albumName;
            document.getElementById('artist').value = album.artist;
            document.getElementById('artistId').value = album.artistId || '';
            document.getElementById('year').value = album.year;
            document.getElementById('artworkUrl').value = album.artworkUrl;
            document.getElementById('discogsUrl').value = album.discogsUrl || '';
            document.getElementById('genre').value = album.genre || '';
            document.getElementById('style').value = album.style || '';
            document.getElementById('reason').value = album.reason || '';
            document.getElementById('score').value = album.score || '';
            document.getElementById('dateListened').value = album.dateListened || '';
            document.getElementById('notes').value = album.notes || '';

            // Change form to edit mode
            const form = document.getElementById('addAlbumForm');
            form.onsubmit = (e) => updateAlbum(e, albumId);
            document.querySelector('#add h2').textContent = 'Edit Album';
            form.querySelector('button[type="submit"]').textContent = 'Update Album';
        }

        function updateAlbum(event, albumId) {
            event.preventDefault();

            const updates = {
                albumName: document.getElementById('albumName').value,
                artist: document.getElementById('artist').value,
                artistId: document.getElementById('artistId').value,
                year: parseInt(document.getElementById('year').value),
                artworkUrl: document.getElementById('artworkUrl').value,
                discogsUrl: document.getElementById('discogsUrl').value,
                genre: document.getElementById('genre').value,
                style: document.getElementById('style').value,
                reason: document.getElementById('reason').value || 'Manual',
                score: document.getElementById('score').value ? parseFloat(document.getElementById('score').value) : null,
                dateListened: document.getElementById('dateListened').value || null,
                notes: document.getElementById('notes').value
            };

            db.updateAlbum(albumId, updates);
            autoSyncToOneDrive();
            showAlert('success', 'Album updated successfully!');
            
            // Reset form
            document.getElementById('addAlbumForm').reset();
            document.getElementById('addAlbumForm').onsubmit = addAlbum;
            document.querySelector('#add h2').textContent = 'Add New Album';
            document.querySelector('#add button[type="submit"]').textContent = 'Add Album';
            document.getElementById('reason').value = 'Manual';
            
            // Return to the section we were in before editing
            showSection(previousSection);
            if (previousSection === 'browse') {
                loadBrowseSection();
            }
        }

        let currentScoringAlbumId = null;

        function scoreAlbum(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            currentScoringAlbumId = albumId;

            // Populate album info
            const albumInfo = document.getElementById('scoreAlbumInfo');
            albumInfo.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <img src="${album.artworkUrl}" alt="${album.albumName}" 
                         style="width: 80px; height: 80px; border-radius: 8px; object-fit: cover;"
                         onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%2280%22 height=%2280%22%3E%3Crect fill=%22%23ddd%22 width=%2280%22 height=%2280%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2212%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    <div>
                        <div style="font-weight: bold; font-size: 1.1em;">${album.albumName}</div>
                        <div style="color: #6c757d;">${album.artist}</div>
                        <div style="color: #6c757d; font-size: 0.9em;">${album.year}</div>
                    </div>
                </div>
            `;

            // Pre-fill existing values if they exist
            document.getElementById('scoreInput').value = album.score || '';
            document.getElementById('dateListenedInput').value = album.dateListened || getTodayDate();
            document.getElementById('notesInput').value = album.notes || '';

            // Close album detail modal and open score modal
            closeModal();
            document.getElementById('scoreModal').classList.add('active');
        }

        function getTodayDate() {
            const today = new Date();
            const year = today.getFullYear();
            const month = String(today.getMonth() + 1).padStart(2, '0');
            const day = String(today.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function closeScoreModal() {
            document.getElementById('scoreModal').classList.remove('active');
            currentScoringAlbumId = null;
        }

        function submitScore(event) {
            event.preventDefault();

            if (!currentScoringAlbumId) return;

            const album = db.getAlbum(currentScoringAlbumId);
            if (!album) return;

            const updates = {
                ...album,
                score: parseFloat(document.getElementById('scoreInput').value),
                dateListened: document.getElementById('dateListenedInput').value || null,
                notes: document.getElementById('notesInput').value || album.notes || ''
            };

            db.updateAlbum(currentScoringAlbumId, updates);
            autoSyncToOneDrive();
            showAlert('success', 'Album scored successfully!');

            closeScoreModal();

            // Refresh the current view
            if (previousSection === 'browse') {
                loadBrowseSection();
            } else if (previousSection === 'stats') {
                loadStatsSection();
            }

            // Show the updated album detail
            setTimeout(() => {
                showAlbumDetail(currentScoringAlbumId);
            }, 100);
        }

        function deleteAlbumConfirm(albumId) {
            if (confirm('Are you sure you want to delete this album? This action cannot be undone.')) {
                db.deleteAlbum(albumId);
                autoSyncToOneDrive();
                closeModal();
                showAlert('success', 'Album deleted successfully!');
                if (document.getElementById('browse').classList.contains('active')) {
                    loadBrowseSection();
                }
            }
        }

        // Fetch album data from Discogs
        async function fetchFromDiscogs() {
            const discogsUrlInput = document.getElementById('discogsUrl');
            const statusEl = document.getElementById('discogsStatus');
            const url = discogsUrlInput.value.trim();

            if (!url) {
                statusEl.textContent = 'Please enter a Discogs URL first';
                statusEl.style.color = '#e74c3c';
                return;
            }

            // Extract master or release ID from URL
            const masterMatch = url.match(/discogs\.com\/master\/(\d+)/);
            const releaseMatch = url.match(/discogs\.com\/release\/(\d+)/);
            
            if (!masterMatch && !releaseMatch) {
                statusEl.textContent = 'Invalid Discogs URL format';
                statusEl.style.color = '#e74c3c';
                return;
            }

            const isMaster = !!masterMatch;
            const id = isMaster ? masterMatch[1] : releaseMatch[1];
            const apiUrl = isMaster 
                ? `https://api.discogs.com/masters/${id}`
                : `https://api.discogs.com/releases/${id}`;

            statusEl.textContent = 'Fetching data from Discogs...';
            statusEl.style.color = '#3498db';

            try {
                // Use CORS proxy to avoid CORS issues
                const proxyUrl = 'https://corsproxy.io/?';
                const response = await fetch(proxyUrl + encodeURIComponent(apiUrl));

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                let data = await response.json();
                
                // If it's a master release and images are empty, fetch the main release instead
                if (isMaster && data.main_release_url && (!data.images || !data.images[0]?.uri)) {
                    console.log('Master images empty, fetching main release...');
                    const mainReleaseResponse = await fetch(proxyUrl + encodeURIComponent(data.main_release_url));
                    if (mainReleaseResponse.ok) {
                        data = await mainReleaseResponse.json();
                        console.log('Main release data:', JSON.stringify(data, null, 2));
                    }
                } else {
                    console.log('Full Discogs response:', JSON.stringify(data, null, 2));
                }

                // Populate form fields
                document.getElementById('albumName').value = data.title || '';
                document.getElementById('artist').value = data.artists?.[0]?.name || '';
                document.getElementById('artistId').value = data.artists?.[0]?.id || '';
                document.getElementById('year').value = data.year || '';
                
                // Get the best quality image
                if (data.images && data.images.length > 0) {
                    // Try to get the highest resolution image
                    // Discogs provides: uri, uri150, resource_url
                    const image = data.images[0];
                    const artworkUrl = image.resource_url || image.uri || image.uri150 || '';
                    document.getElementById('artworkUrl').value = artworkUrl;
                    console.log('Image data:', image);
                    console.log('Using artwork URL:', artworkUrl);
                }

                // Join genres with semicolons
                if (data.genres && data.genres.length > 0) {
                    document.getElementById('genre').value = data.genres.join('; ');
                }

                // Join styles with semicolons
                if (data.styles && data.styles.length > 0) {
                    document.getElementById('style').value = data.styles.join('; ');
                }

                statusEl.textContent = ' Successfully fetched album data!';
                statusEl.style.color = '#27ae60';

                // Clear status after 3 seconds
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);

            } catch (error) {
                console.error('Error fetching from Discogs:', error);
                statusEl.textContent = ' Error fetching data. Please check the URL and try again.';
                statusEl.style.color = '#e74c3c';
            }
        }

        // Add Album
        function addAlbum(event) {
            event.preventDefault();

            const album = {
                albumName: document.getElementById('albumName').value,
                artist: document.getElementById('artist').value,
                artistId: document.getElementById('artistId').value,
                year: parseInt(document.getElementById('year').value),
                artworkUrl: document.getElementById('artworkUrl').value,
                discogsUrl: document.getElementById('discogsUrl').value,
                genre: document.getElementById('genre').value,
                style: document.getElementById('style').value,
                reason: document.getElementById('reason').value || 'Manual',
                score: document.getElementById('score').value ? parseFloat(document.getElementById('score').value) : null,
                dateListened: document.getElementById('dateListened').value || null,
                notes: document.getElementById('notes').value
            };

            if (db.isDuplicate(album.albumName, album.artist)) {
                showAlert('error', 'This album already exists in your collection!');
                return;
            }

            db.addAlbum(album);
            autoSyncToOneDrive();
            showAlert('success', 'Album added successfully!');
            document.getElementById('addAlbumForm').reset();
            document.getElementById('reason').value = 'Manual';
            
            // Return to Browse Albums section
            showSection('browse');
        }

        // Import Excel
        async function importExcel(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show loading indicator
            document.getElementById('importStatus').innerHTML = `
                <div class="alert alert-info" style="margin-top: 20px;">
                    <strong>Processing...</strong><br>
                    Reading file and preparing data...
                </div>
            `;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-info" style="margin-top: 20px;">
                            <strong>Processing...</strong><br>
                            Importing ${jsonData.length} albums...
                        </div>
                    `;

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const albums = jsonData.map(row => {
                        // Helper to get value, allowing falsy values like 0 but not null/undefined
                        const getValue = (primary, secondary, defaultVal = '') => {
                            const val = primary !== undefined && primary !== null ? primary : secondary;
                            return val !== undefined && val !== null ? val : defaultVal;
                        };

                        // Helper to parse Excel date (which can be a serial number or string)
                        const parseExcelDate = (dateValue) => {
                            if (!dateValue) return null;
                            
                            // If it's already a string in YYYY-MM-DD format, return it
                            if (typeof dateValue === 'string' && dateValue.match(/^\d{4}-\d{2}-\d{2}$/)) {
                                return dateValue;
                            }
                            
                            // If it's a string in other formats, try to parse it
                            if (typeof dateValue === 'string') {
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    return parsed.toISOString().split('T')[0];
                                }
                            }
                            
                            // If it's an Excel serial number (number of days since 1900-01-01)
                            if (typeof dateValue === 'number') {
                                // Excel date serial number conversion
                                const excelEpoch = new Date(1899, 11, 30); // Excel's epoch (Dec 30, 1899)
                                const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                                return date.toISOString().split('T')[0];
                            }
                            
                            return null;
                        };

                        return {
                            albumName: getValue(row['Album Name'], getValue(row['Album'], row['albumName'], ''), ''),
                            artist: getValue(row['Artist'], row['artist'], ''),
                            artistId: getValue(row['Artist ID'], row['artistId'], ''),
                            year: parseInt(row['Year'] || row['year']) || new Date().getFullYear(),
                            artworkUrl: getValue(row['Album Artwork URL'], getValue(row['Album Artwork'], row['artworkUrl'], ''), ''),
                            discogsUrl: getValue(row['Discogs URL'], getValue(row['Discogs'], row['discogsUrl'], ''), ''),
                            genre: getValue(row['Genre'], row['genre'], ''),
                            style: getValue(row['Style'], row['style'], ''),
                            reason: getValue(row['Reason'], row['reason'], 'Manual'),
                            score: row['Score'] || row['score'] ? parseFloat(row['Score'] || row['score']) : null,
                            dateListened: parseExcelDate(row['Date Listened'] || row['Listened on'] || row['dateListened']),
                            notes: getValue(row['Notes'], row['notes'], '')
                        };
                    });

                    const result = await db.importAlbumsAsync(albums, (progress) => {
                        document.getElementById('importStatus').innerHTML = `
                            <div class="alert alert-info" style="margin-top: 20px;">
                                <strong>Processing...</strong><br>
                                Progress: ${progress.processed} / ${progress.total} albums<br>
                                Added: ${progress.added}, Updated: ${progress.updated}, Skipped: ${progress.skipped}
                            </div>
                        `;
                    });
                    
                    autoSyncToOneDrive();
                    
                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-success" style="margin-top: 20px;">
                            <strong>Import Complete!</strong><br>
                            Added: ${result.added} albums<br>
                            Updated: ${result.updated} albums<br>
                            Skipped (no changes): ${result.skipped} albums
                        </div>
                    `;

                    // Reset file input
                    event.target.value = '';

                } catch (error) {
                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-error" style="margin-top: 20px;">
                            <strong>Import Failed!</strong><br>
                            ${error.message}
                        </div>
                    `;
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Export Data
        function exportData() {
            const albums = db.getAllAlbums();
            
            if (albums.length === 0) {
                showAlert('error', 'No albums to export!');
                return;
            }

            // Prepare data for export
            const exportData = albums.map(album => ({
                'ID': album.id,
                'Album Name': album.albumName,
                'Artist': album.artist,
                'Artist ID': album.artistId || '',
                'Year': album.year,
                'Album Artwork URL': album.artworkUrl,
                'Discogs URL': album.discogsUrl || '',
                'Genre': album.genre || '',
                'Style': album.style || '',
                'Reason': album.reason || '',
                'Score': album.score !== null && album.score !== undefined && album.score !== '' ? album.score : '',
                'Date Listened': album.dateListened || '',
                'Notes': album.notes || ''
            }));

            // Create worksheet
            const ws = XLSX.utils.json_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Albums');

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `album-tracker-${timestamp}.xlsx`;

            // Download
            XLSX.writeFile(wb, filename);
            showAlert('success', 'Data exported successfully!');
        }

        // Statistics
        function loadStatsSection() {
            const statsContent = document.getElementById('statsContent');
            
            const albums = db.getAllAlbums();
            if (albums.length === 0) {
                statsContent.innerHTML = `
                    <div class="empty-state">
                        <h3>No data available</h3>
                        <p>Add some albums to see statistics.</p>
                    </div>
                `;
                return;
            }

            const monthlyStats = db.getMonthlyStats();
            const artistAvg = db.getAverageScoreByArtist();
            const genreAvg = db.getAverageScoreByGenre();
            const genreCounts = db.getGenreCounts();
            const sourceStats = db.getSourceListStats();

            // Ranking method toggle
            const rankingMethod = localStorage.getItem('ranking_method') || 'raw';
            
            let html = `
                <div style="background: var(--chart-bg); padding: 20px; border-radius: 12px; margin-bottom: 20px; color: var(--chart-text);">
                    <h3 style="margin: 0 0 15px 0; color: var(--chart-text);"> Ranking Method</h3>
                    <div style="display: flex; gap: 15px; align-items: center; flex-wrap: wrap;">
                        <label style="display: flex; align-items: center; cursor: pointer; background: var(--button-hover-bg); padding: 10px 15px; border-radius: 8px; color: var(--button-hover-text); ${rankingMethod === 'raw' ? 'opacity: 1; box-shadow: 0 2px 8px rgba(0,0,0,0.2);' : 'opacity: 0.7;'}">
                            <input type="radio" name="rankingMethod" value="raw" ${rankingMethod === 'raw' ? 'checked' : ''} onchange="changeRankingMethod('raw')">
                            <span style="font-weight: 600;">Raw Score</span>
                            <span style="margin-left: 8px; font-size: 0.9em; opacity: 0.9;">(Simple Average)</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer; background: var(--button-hover-bg); padding: 10px 15px; border-radius: 8px; color: var(--button-hover-text); ${rankingMethod === 'weighted' ? 'opacity: 1; box-shadow: 0 2px 8px rgba(0,0,0,0.2);' : 'opacity: 0.7;'}">
                            <input type="radio" name="rankingMethod" value="weighted" ${rankingMethod === 'weighted' ? 'checked' : ''} onchange="changeRankingMethod('weighted')">
                            <span style="font-weight: 600;">Weighted Score</span>
                            <span style="margin-left: 8px; font-size: 0.9em; opacity: 0.9;">(Bayesian)</span>
                        </label>
                        <button onclick="showRankingExplanation()" style="background: var(--button-hover-bg); border: none; color: var(--button-hover-text); padding: 10px 15px; border-radius: 8px; cursor: pointer; font-weight: 600; display: flex; align-items: center; gap: 5px;">
                            <span></span>
                            <span>What's the difference?</span>
                        </button>
                    </div>
                </div>
            `;

            // Listening Timeline Graph
            const timelineFilter = window.listeningTimelineFilter || 'all';
            const chartBg = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
            const chartTextColor = getComputedStyle(document.body).getPropertyValue('--chart-text').trim();
            html += `
                <div style="background: var(--chart-bg); padding: 25px; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                        <h3 style="margin: 0; color: var(--chart-text);"> Listening Timeline</h3>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button onclick="changeTimelineFilter('all')" style="padding: 8px 16px; border-radius: 8px; border: 2px solid ${timelineFilter === 'all' ? 'var(--button-bg)' : '#ddd'}; background: ${timelineFilter === 'all' ? 'var(--button-bg)' : 'var(--chart-bg)'}; color: ${timelineFilter === 'all' ? 'white' : 'var(--chart-text)'}; cursor: pointer; font-weight: 600; transition: all 0.3s;">All Time</button>
                            <button onclick="changeTimelineFilter('5years')" style="padding: 8px 16px; border-radius: 8px; border: 2px solid ${timelineFilter === '5years' ? 'var(--button-bg)' : '#ddd'}; background: ${timelineFilter === '5years' ? 'var(--button-bg)' : 'var(--chart-bg)'}; color: ${timelineFilter === '5years' ? 'white' : 'var(--chart-text)'}; cursor: pointer; font-weight: 600; transition: all 0.3s;">5 Years</button>
                            <button onclick="changeTimelineFilter('3years')" style="padding: 8px 16px; border-radius: 8px; border: 2px solid ${timelineFilter === '3years' ? 'var(--button-bg)' : '#ddd'}; background: ${timelineFilter === '3years' ? 'var(--button-bg)' : 'var(--chart-bg)'}; color: ${timelineFilter === '3years' ? 'white' : 'var(--chart-text)'}; cursor: pointer; font-weight: 600; transition: all 0.3s;">3 Years</button>
                            <button onclick="changeTimelineFilter('1year')" style="padding: 8px 16px; border-radius: 8px; border: 2px solid ${timelineFilter === '1year' ? 'var(--button-bg)' : '#ddd'}; background: ${timelineFilter === '1year' ? 'var(--button-bg)' : 'var(--chart-bg)'}; color: ${timelineFilter === '1year' ? 'white' : 'var(--chart-text)'}; cursor: pointer; font-weight: 600; transition: all 0.3s;">1 Year</button>
                        </div>
                    </div>
                    <div style="position: relative; height: 400px;">
                        <canvas id="listeningTimelineChart"></canvas>
                    </div>
                </div>
                <div class="stats-grid">
            `;

            // Overall Stats
            const totalAlbums = albums.length;
            const listenedAlbums = albums.filter(a => a.dateListened).length;
            const ratedAlbums = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '').length;
            const listenedPercentage = totalAlbums > 0 ? ((listenedAlbums / totalAlbums) * 100).toFixed(1) : '0';
            const avgScore = ratedAlbums > 0 
                ? (albums.filter(a => a.score).reduce((sum, a) => sum + parseFloat(a.score), 0) / ratedAlbums).toFixed(2)
                : 'N/A';

            html += `
                <div class="stat-card">
                    <h3> Overall Statistics</h3>
                    <div class="stat-item">
                        <span>Total Albums</span>
                        <strong>${totalAlbums}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Albums Listened</span>
                        <strong>${listenedAlbums} (${listenedPercentage}%)</strong>
                    </div>
                    <div class="stat-item">
                        <span>Albums Rated</span>
                        <strong>${ratedAlbums}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Average Score</span>
                        <strong>${avgScore}</strong>
                    </div>
                </div>
            `;

            // Monthly Listening Stats
            const currentYear = new Date().getFullYear().toString();
            const availableYears = [...new Set(Object.keys(monthlyStats).map(m => m.split('-')[0]).filter(y => y))].sort().reverse();
            const selectedYear = window.monthlyStatsYear || (availableYears.includes(currentYear) ? currentYear : (availableYears.length > 0 ? availableYears[0] : currentYear));
            
            html += `
                <div class="stat-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;"> Monthly Listening</h3>
                        ${availableYears.length > 0 ? `
                            <select id="monthlyYearSelector" onchange="filterMonthlyStatsByYear(this.value)" style="padding: 5px 10px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer;">
                                ${availableYears.map(year => `<option value="${year}" ${year === selectedYear ? 'selected' : ''}>${year}</option>`).join('')}
                            </select>
                        ` : ''}
                    </div>
                    ${Object.keys(monthlyStats).length > 0 ? 
                        Object.entries(monthlyStats)
                            .filter(([month]) => month.startsWith(selectedYear))
                            .sort((a, b) => b[0].localeCompare(a[0]))
                            .map(([month, data]) => {
                                const [year, monthNum] = month.split('-');
                                const date = new Date(year, parseInt(monthNum) - 1);
                                const displayMonth = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                const avgScore = data.scores.length > 0 
                                    ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2)
                                    : 'N/A';
                                return `
                                    <div class="stat-item" style="cursor: pointer;" onclick="showMonthDrilldown('${month}')">
                                        <span>${displayMonth}</span>
                                        <strong>${data.count} albums (Avg: ${avgScore})</strong>
                                    </div>
                                `;
                            }).join('')
                        : '<p style="color: #6c757d;">No listening data yet</p>'
                    }
                </div>
            `;
            
            // Yearly Stats
            const yearlyStats = db.getYearlyStats();
            if (Object.keys(yearlyStats).length > 0) {
                html += `
                    <div class="stat-card">
                        <h3> Yearly Listening</h3>
                        ${Object.entries(yearlyStats)
                            .sort((a, b) => b[0].localeCompare(a[0]))
                            .map(([year, data]) => {
                                const avgScore = data.scores.length > 0 
                                    ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2)
                                    : 'N/A';
                                return `
                                    <div class="stat-item" style="cursor: pointer;" onclick="showYearDrilldown('${year}')">
                                        <span>${year}</span>
                                        <strong>${data.count} albums (Avg: ${avgScore})</strong>
                                    </div>
                                `;
                            }).join('')
                        }
                    </div>
                `;
            }

            html += '</div>';
            
            // Top Artists by Average Score
            if (Object.keys(artistAvg).length > 0) {
                const globalMean = getGlobalMean(albums);
                const confidenceWeight = getConfidenceWeight(albums.length);
                
                // Calculate weighted scores if needed
                const artistData = Object.entries(artistAvg).map(([artist, data]) => {
                    const artistAlbums = albums.filter(a => a.artist === artist && a.score);
                    const scores = artistAlbums.map(a => parseFloat(a.score));
                    const rawScore = data.average;
                    const weightedScore = rankingMethod === 'weighted' 
                        ? calculateWeightedScore(scores, globalMean, confidenceWeight)
                        : rawScore;
                    
                    return {
                        artist,
                        rawScore,
                        weightedScore,
                        displayScore: rankingMethod === 'weighted' ? weightedScore : rawScore,
                        count: data.count
                    };
                });
                
                // Sort by display score
                artistData.sort((a, b) => b.displayScore - a.displayScore);
                
                html += `
                    <div class="chart">
                        <h3> Top Artists by Average Score (${rankingMethod === 'weighted' ? 'Weighted' : 'Raw Score'})</h3>
                        ${artistData.slice(0, 10).map(data => `
                            <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px;" onclick="showArtistDrilldown('${data.artist.replace(/'/g, "\\'")}')">
                                <div style="min-width: 150px; max-width: 150px; padding-right: 10px; color: ${chartTextColor}; font-weight: 600; font-size: 13px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${data.artist}">${data.artist}</div>
                                <div style="flex: 1; display: flex; align-items: center;">
                                    <div class="chart-bar-fill" style="width: ${(data.displayScore / 10) * 100}%; background: linear-gradient(90deg, #f093fb 0%, #f5576c 100%); color: white; padding: 8px 12px; border-radius: 4px; font-weight: 600; min-width: 100px;">
                                        ${rankingMethod === 'weighted' 
                                            ? `${data.weightedScore.toFixed(2)} <span style="opacity: 0.7; font-size: 0.9em;">(Raw: ${data.rawScore.toFixed(2)})</span> | ${data.count} album${data.count !== 1 ? 's' : ''}`
                                            : `${data.rawScore.toFixed(2)} (${data.count} album${data.count !== 1 ? 's' : ''})`
                                        }
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Top Genres by Album Count
            if (Object.keys(genreCounts).length > 0) {
                const maxCount = Math.max(...Object.values(genreCounts));
                html += `
                    <div class="chart">
                        <h3> Top Genres by Album Count</h3>
                        ${Object.entries(genreCounts).slice(0, 15).map(([genre, count]) => `
                            <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px;" onclick="showGenreDrilldown('${genre.replace(/'/g, "\\'")}')">
                                <div style="min-width: 150px; max-width: 150px; padding-right: 10px; color: ${chartTextColor}; font-weight: 600; font-size: 13px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${genre}">${genre}</div>
                                <div style="flex: 1; display: flex; align-items: center; position: relative;">
                                    <div class="chart-bar-fill" style="width: ${(count / maxCount) * 100}%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); padding: 8px 12px; border-radius: 4px; min-height: 32px; min-width: 80px;"></div>
                                    <div style="position: absolute; left: ${(count / maxCount) * 100 < 20 ? ((count / maxCount) * 100) + 2 : 12}%; color: ${(count / maxCount) * 100 < 20 ? chartTextColor : 'white'}; font-weight: 600; font-size: 14px; white-space: nowrap;">
                                        ${count} album${count !== 1 ? 's' : ''}
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Top Genres by Average Score
            if (Object.keys(genreAvg).length > 0) {
                const globalMean = getGlobalMean(albums);
                const confidenceWeight = getConfidenceWeight(albums.length);
                
                // Calculate weighted scores if needed
                const genreData = Object.entries(genreAvg).map(([genre, rawScore]) => {
                    const genreAlbums = albums.filter(a => {
                        if (!a.genre || !a.score) return false;
                        const genres = a.genre.split(';').map(g => g.trim());
                        return genres.includes(genre);
                    });
                    const scores = genreAlbums.map(a => parseFloat(a.score));
                    const weightedScore = rankingMethod === 'weighted' 
                        ? calculateWeightedScore(scores, globalMean, confidenceWeight)
                        : rawScore;
                    
                    return {
                        genre,
                        rawScore,
                        weightedScore,
                        displayScore: rankingMethod === 'weighted' ? weightedScore : rawScore,
                        count: genreAlbums.length
                    };
                });
                
                // Sort by display score
                genreData.sort((a, b) => b.displayScore - a.displayScore);
                
                html += `
                    <div class="chart">
                        <h3> Top Genres by Average Score (${rankingMethod === 'weighted' ? 'Weighted' : 'Raw Score'})</h3>
                        ${genreData.slice(0, 10).map(data => `
                            <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px;" onclick="showGenreDrilldown('${data.genre.replace(/'/g, "\\'")}')">
                                <div style="min-width: 150px; max-width: 150px; padding-right: 10px; color: ${chartTextColor}; font-weight: 600; font-size: 13px; text-align: right; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${data.genre}">${data.genre}</div>
                                <div style="flex: 1; display: flex; align-items: center; position: relative;">
                                    <div class="chart-bar-fill" style="width: ${(data.displayScore / 10) * 100}%; background: linear-gradient(90deg, #28a745 0%, #20c997 100%); padding: 8px 12px; border-radius: 4px; min-height: 32px;"></div>
                                    <div style="position: absolute; left: 12px; color: white; font-weight: 600; font-size: 14px; text-shadow: 1px 1px 2px rgba(0,0,0,0.5);">
                                        ${rankingMethod === 'weighted' 
                                            ? `${data.weightedScore.toFixed(2)} <span style="opacity: 0.7; font-size: 0.85em;">(Raw: ${data.rawScore.toFixed(2)})</span>`
                                            : data.rawScore.toFixed(2)
                                        }
                                    </div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Highest and Lowest Scoring Albums (Side by Side with Filter)
            // Get available months and years for dropdowns
            const allMonths = [...new Set(albums.filter(a => a.dateListened).map(a => a.dateListened.substring(0, 7)))].sort().reverse();
            const allYears = [...new Set(albums.filter(a => a.dateListened).map(a => a.dateListened.substring(0, 4)))].sort().reverse();
            
            html += `
                <div style="margin-top: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; gap: 10px;">
                        <h3 style="margin: 0;"> Top & Bottom Albums</h3>
                        <select id="scoreFilterSelect" onchange="updateScoreFilter()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 14px;">
                            <option value="all-time">All Time</option>
                            <option value="this-month">This Month</option>
                            <option value="previous-month">Previous Month</option>
                            <option value="last-year">Last Year</option>
                            <optgroup label="Select Month">
                                ${allMonths.map(m => {
                                    const date = new Date(m + '-01');
                                    const label = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                                    return `<option value="month:${m}">${label}</option>`;
                                }).join('')}
                            </optgroup>
                            <optgroup label="Select Year">
                                ${allYears.map(y => `<option value="year:${y}">${y}</option>`).join('')}
                            </optgroup>
                        </select>
                    </div>
                    <div id="scoreFilteredAlbums" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <!-- Will be populated by updateScoreFilter() -->
                    </div>
                </div>
            `;

            // Top & Bottom 10 Lists (by source/reason)
            // This will be populated by updateScoreFilter() along with Top & Bottom Albums
            html += `
                <div id="topBottomListsSection" class="score-albums-section" style="margin-top: 20px;">
                    <!-- Will be populated by updateScoreFilter() -->
                </div>
            `;

            // Source List Statistics (Moved to bottom)
            if (Object.keys(sourceStats).length > 0) {
                html += `
                    <div class="chart" style="margin-top: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;">
                            <h3 style="margin: 0;"> Source List Statistics</h3>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <select id="sourceListSort" onchange="sortSourceLists()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 14px;">
                                    <option value="score-desc">Score (High to Low)</option>
                                    <option value="score-asc">Score (Low to High)</option>
                                    <option value="complete-desc">% Complete (High to Low)</option>
                                    <option value="complete-asc">% Complete (Low to High)</option>
                                    <option value="name-asc">Name (A to Z)</option>
                                    <option value="name-desc">Name (Z to A)</option>
                                </select>
                                <button id="sourceListViewToggle" onclick="toggleSourceListView()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 5px;">
                                    <span id="sourceListViewIcon"></span>
                                    <span id="sourceListViewText">Table View</span>
                                </button>
                            </div>
                        </div>
                        <div id="sourceListsGrid" class="stats-grid">
                            ${Object.entries(sourceStats).map(([source, stats]) => {
                                const percentComplete = stats.total > 0 ? ((stats.listened / stats.total) * 100).toFixed(0) : 0;
                                return `
                                    <div class="stat-card" style="cursor: pointer;" onclick="showSourceDrilldown('${source.replace(/'/g, "\\'")}')">
                                        <h4 style="font-size: 1em; margin-bottom: 10px;">${source}</h4>
                                        <div class="stat-item">
                                            <span>Total Albums</span>
                                            <strong>${stats.total}</strong>
                                        </div>
                                        <div class="stat-item">
                                            <span>Listened</span>
                                            <strong>${stats.listened}</strong>
                                        </div>
                                        <div class="stat-item">
                                            <span>% Complete</span>
                                            <strong style="color: ${percentComplete >= 75 ? '#28a745' : percentComplete >= 50 ? '#ffc107' : '#dc3545'};">${percentComplete}%</strong>
                                        </div>
                                        <div class="stat-item">
                                            <span>Average Score</span>
                                            <strong>${stats.avgScore ? stats.avgScore.toFixed(2) : 'N/A'}</strong>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            statsContent.innerHTML = html;
            
            // Render the listening timeline chart
            renderListeningTimelineChart();
            
            // Initialize score filter
            updateScoreFilter();
        }

        // Global variable to store the chart instance
        let listeningTimelineChartInstance = null;

        // Render the listening timeline chart
        function renderListeningTimelineChart() {
            const canvas = document.getElementById('listeningTimelineChart');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const albums = db.getAllAlbums();
            const filter = window.listeningTimelineFilter || 'all';

            // Calculate date range based on filter
            const now = new Date();
            let startDate = null;
            
            if (filter === '1year') {
                startDate = new Date(now.getFullYear() - 1, now.getMonth(), 1);
            } else if (filter === '3years') {
                startDate = new Date(now.getFullYear() - 3, now.getMonth(), 1);
            } else if (filter === '5years') {
                startDate = new Date(now.getFullYear() - 5, now.getMonth(), 1);
            }

            // Get monthly stats and filter by date range
            const monthlyStats = db.getMonthlyStats();
            let filteredStats = monthlyStats;
            
            if (startDate) {
                filteredStats = {};
                Object.entries(monthlyStats).forEach(([key, value]) => {
                    const [year, month] = key.split('-');
                    const date = new Date(parseInt(year), parseInt(month) - 1, 1);
                    if (date >= startDate) {
                        filteredStats[key] = value;
                    }
                });
            }

            // Sort months chronologically
            const sortedMonths = Object.keys(filteredStats).sort();
            
            // Calculate cumulative totals
            let cumulative = 0;
            const labels = [];
            const monthlyData = [];
            const cumulativeData = [];

            sortedMonths.forEach(month => {
                const [year, monthNum] = month.split('-');
                const date = new Date(parseInt(year), parseInt(monthNum) - 1, 1);
                const label = date.toLocaleDateString('en-US', { month: 'short', year: '2-digit' });
                
                labels.push(label);
                monthlyData.push(filteredStats[month].count);
                cumulative += filteredStats[month].count;
                cumulativeData.push(cumulative);
            });

            // Destroy existing chart if it exists
            if (listeningTimelineChartInstance) {
                listeningTimelineChartInstance.destroy();
            }

            // Create new chart
            listeningTimelineChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            type: 'line',
                            label: 'Cumulative Total',
                            data: cumulativeData,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 3,
                            fill: true,
                            tension: 0.4,
                            yAxisID: 'y1',
                            pointRadius: 4,
                            pointHoverRadius: 6,
                            pointBackgroundColor: '#667eea',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2
                        },
                        {
                            type: 'bar',
                            label: 'Monthly Albums',
                            data: monthlyData,
                            backgroundColor: 'rgba(118, 75, 162, 0.7)',
                            borderColor: '#764ba2',
                            borderWidth: 1,
                            yAxisID: 'y'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false,
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                font: {
                                    size: 13,
                                    weight: '600'
                                },
                                padding: 15,
                                usePointStyle: true,
                                color: getComputedStyle(document.body).getPropertyValue('--chart-text').trim()
                            }
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.8)',
                            padding: 12,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    label += context.parsed.y + ' albums';
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Monthly Albums',
                                font: {
                                    size: 12,
                                    weight: '600'
                                },
                                color: getComputedStyle(document.body).getPropertyValue('--chart-text').trim()
                            },
                            ticks: {
                                stepSize: 1,
                                font: {
                                    size: 11
                                },
                                color: getComputedStyle(document.body).getPropertyValue('--chart-text').trim()
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Cumulative Total',
                                font: {
                                    size: 12,
                                    weight: '600'
                                },
                                color: getComputedStyle(document.body).getPropertyValue('--chart-text').trim()
                            },
                            ticks: {
                                stepSize: 5,
                                font: {
                                    size: 11
                                },
                                color: getComputedStyle(document.body).getPropertyValue('--chart-text').trim()
                            },
                            grid: {
                                drawOnChartArea: false,
                            }
                        },
                        x: {
                            ticks: {
                                font: {
                                    size: 11
                                },
                                maxRotation: 45,
                                minRotation: 45,
                                color: getComputedStyle(document.body).getPropertyValue('--chart-text').trim()
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Change timeline filter
        function changeTimelineFilter(filter) {
            window.listeningTimelineFilter = filter;
            loadStatsSection();
        }

        // Update score filter for highest/lowest albums
        function updateScoreFilter() {
            const filterValue = document.getElementById('scoreFilterSelect')?.value || 'all-time';
            const albums = db.getAllAlbums();
            let filteredAlbums = albums;

            // Apply date filter
            const now = new Date();
            if (filterValue === 'this-month') {
                const thisMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(thisMonth));
            } else if (filterValue === 'previous-month') {
                const prevDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const prevMonth = `${prevDate.getFullYear()}-${String(prevDate.getMonth() + 1).padStart(2, '0')}`;
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(prevMonth));
            } else if (filterValue === 'last-year') {
                const lastYear = (now.getFullYear() - 1).toString();
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(lastYear));
            } else if (filterValue.startsWith('month:')) {
                const month = filterValue.substring(6);
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(month));
            } else if (filterValue.startsWith('year:')) {
                const year = filterValue.substring(5);
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(year));
            }

            const highScoring = filteredAlbums
                .filter(a => a.score >= 8)
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);

            const lowScoring = filteredAlbums
                .filter(a => a.score && a.score <= 4)
                .sort((a, b) => a.score - b.score)
                .slice(0, 10);

            const container = document.getElementById('scoreFilteredAlbums');
            if (!container) return;

            const chartTextColor = getComputedStyle(document.body).getPropertyValue('--chart-text').trim();
            
            container.innerHTML = `
                <div class="chart" style="margin: 0;">
                    <h4 style="color: #28a745;"> Highest Scoring Albums (8)</h4>
                    ${highScoring.length > 0 ? highScoring.map(album => `
                        <div class="stat-item" style="cursor: pointer;" onclick="showAlbumDetail(${album.id})">
                            <span style="color: ${chartTextColor};">${album.albumName} - ${album.artist}</span>
                            <strong style="color: #28a745;">${album.score}/10</strong>
                        </div>
                    `).join('') : `<p style="color: ${chartTextColor}; opacity: 0.6; padding: 20px; text-align: center;">No albums found</p>`}
                </div>
                <div class="chart" style="margin: 0;">
                    <h4 style="color: #dc3545;"> Lowest Scoring Albums (4)</h4>
                    ${lowScoring.length > 0 ? lowScoring.map(album => `
                        <div class="stat-item" style="cursor: pointer;" onclick="showAlbumDetail(${album.id})">
                            <span style="color: ${chartTextColor};">${album.albumName} - ${album.artist}</span>
                            <strong style="color: #dc3545;">${album.score}/10</strong>
                        </div>
                    `).join('') : `<p style="color: ${chartTextColor}; opacity: 0.6; padding: 20px; text-align: center;">No albums found</p>`}
                </div>
            `;

            // Update Top & Bottom Lists section
            const listsContainer = document.getElementById('topBottomListsSection');
            if (listsContainer) {
                const rankingMethod = localStorage.getItem('ranking_method') || 'raw';
                const useWeighted = rankingMethod === 'weighted';
                
                // Calculate list statistics
                const listStats = {};
                filteredAlbums.forEach(album => {
                    if (album.reason && album.score) {
                        const lists = db.parseMultiValue(album.reason);
                        lists.forEach(list => {
                            if (!listStats[list]) {
                                listStats[list] = { scores: [], count: 0 };
                            }
                            listStats[list].scores.push(parseFloat(album.score));
                            listStats[list].count++;
                        });
                    }
                });

                // Calculate averages (raw or weighted)
                const listAverages = Object.entries(listStats).map(([list, stats]) => {
                    let avgScore;
                    if (useWeighted) {
                        const globalMean = getGlobalMean(albums);
                        const confidenceWeight = getConfidenceWeight(albums.length);
                        avgScore = calculateWeightedScore(stats.scores, globalMean, confidenceWeight);
                    } else {
                        avgScore = stats.scores.reduce((a, b) => a + b, 0) / stats.scores.length;
                    }
                    return { list, avgScore, count: stats.count };
                });

                // Sort and get top/bottom 10
                const sortedLists = listAverages.sort((a, b) => b.avgScore - a.avgScore);
                const top10Lists = sortedLists.slice(0, 10);
                const bottom10Lists = sortedLists.slice(-10).reverse();

                const filterLabel = document.getElementById('scoreFilterSelect')?.selectedOptions[0]?.text || 'All Time';
                const chartBgColor = getComputedStyle(document.body).getPropertyValue('--chart-bg').trim();
                const chartTextColor = getComputedStyle(document.body).getPropertyValue('--chart-text').trim();
                
                console.log(' Top & Bottom Lists - Chart BG Color:', chartBgColor);
                console.log(' Top & Bottom Lists - Chart Text Color:', chartTextColor);

                listsContainer.innerHTML = `
                    <div style="background: ${chartBgColor}; color: ${chartTextColor}; padding: 20px; border-radius: 8px; margin-top: 30px;">
                    <h3 style="margin-bottom: 20px; color: ${chartTextColor};"> Top & Bottom 10 Lists (${filterLabel}) (${useWeighted ? 'Weighted' : 'Raw Score'})</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <div class="chart">
                            <h4 style="color: #28a745; margin-bottom: 15px;"> Top 10 Lists</h4>
                            ${top10Lists.length > 0 ? top10Lists.map((item, index) => `
                                <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px; padding: 10px; background: ${index === 0 ? 'linear-gradient(135deg, #ffd700 0%, #ffed4e 100%)' : 'rgba(255,255,255,0.1)'}; border-radius: 8px; border: 1px solid rgba(0,0,0,0.1);" onclick="showSourceDrilldown('${item.list.replace(/'/g, "\\'")}')">
                                    <div style="min-width: 30px; font-weight: 700; font-size: 18px; color: ${index === 0 ? '#000' : chartTextColor};">#${index + 1}</div>
                                    <div style="flex: 1; padding: 0 10px;">
                                        <div style="font-weight: 600; color: ${chartTextColor}; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${item.list}">${item.list}</div>
                                        <div style="font-size: 12px; color: ${chartTextColor}; opacity: 0.7;">${item.count} album${item.count !== 1 ? 's' : ''}</div>
                                    </div>
                                    <div style="min-width: 50px; text-align: right; font-weight: 700; font-size: 16px; color: #28a745;">${item.avgScore.toFixed(1)}</div>
                                </div>
                            `).join('') : `<p style="color: ${chartTextColor}; opacity: 0.6; padding: 20px; text-align: center;">No lists found</p>`}
                        </div>
                        <div class="chart">
                            <h4 style="color: #dc3545; margin-bottom: 15px;"> Bottom 10 Lists</h4>
                            ${bottom10Lists.length > 0 ? bottom10Lists.map((item, index) => `
                                <div class="chart-bar" style="cursor: pointer; display: flex; align-items: center; margin-bottom: 8px; padding: 10px; background: rgba(255,255,255,0.1); border-radius: 8px; border: 1px solid rgba(0,0,0,0.1);" onclick="showSourceDrilldown('${item.list.replace(/'/g, "\\'")}')">
                                    <div style="min-width: 30px; font-weight: 700; font-size: 18px; color: #dc3545;">#${sortedLists.length - index}</div>
                                    <div style="flex: 1; padding: 0 10px;">
                                        <div style="font-weight: 600; color: ${chartTextColor}; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;" title="${item.list}">${item.list}</div>
                                        <div style="font-size: 12px; color: ${chartTextColor}; opacity: 0.7;">${item.count} album${item.count !== 1 ? 's' : ''}</div>
                                    </div>
                                    <div style="min-width: 50px; text-align: right; font-weight: 700; font-size: 16px; color: #dc3545;">${item.avgScore.toFixed(1)}</div>
                                </div>
                            `).join('') : `<p style="color: ${chartTextColor}; opacity: 0.6; padding: 20px; text-align: center;">No lists found</p>`}
                        </div>
                    </div>
                    </div>
                `;
            }
        }

        // Sort source lists
        let sourceListViewMode = 'tiles'; // 'tiles' or 'table'
        let sourceListTableSort = { column: 'score', direction: 'desc' }; // Track table sorting
        
        function sortSourceLists() {
            const sortValue = document.getElementById('sourceListSort')?.value || 'score-desc';
            const albums = db.getAllAlbums();
            
            // Calculate source stats
            const sourceStats = {};
            albums.forEach(album => {
                if (album.reason) {
                    const sources = db.parseMultiValue(album.reason);
                    sources.forEach(source => {
                        if (!sourceStats[source]) {
                            sourceStats[source] = { total: 0, listened: 0, scores: [] };
                        }
                        sourceStats[source].total++;
                        if (album.score) {
                            sourceStats[source].listened++;
                            sourceStats[source].scores.push(parseFloat(album.score));
                        }
                    });
                }
            });

            // Calculate averages and percentages
            const sourceData = Object.entries(sourceStats).map(([source, stats]) => {
                const avgScore = stats.scores.length > 0 
                    ? stats.scores.reduce((a, b) => a + b, 0) / stats.scores.length 
                    : 0;
                const percentComplete = stats.total > 0 ? (stats.listened / stats.total) * 100 : 0;
                return { source, ...stats, avgScore, percentComplete };
            });

            // Sort based on selection (use table sort if in table view, otherwise use dropdown)
            let sortColumn, sortDirection;
            if (sourceListViewMode === 'table') {
                sortColumn = sourceListTableSort.column;
                sortDirection = sourceListTableSort.direction;
            } else {
                // Parse dropdown value for tiles view
                if (sortValue === 'score-desc') {
                    sortColumn = 'score';
                    sortDirection = 'desc';
                } else if (sortValue === 'score-asc') {
                    sortColumn = 'score';
                    sortDirection = 'asc';
                } else if (sortValue === 'complete-desc') {
                    sortColumn = 'complete';
                    sortDirection = 'desc';
                } else if (sortValue === 'complete-asc') {
                    sortColumn = 'complete';
                    sortDirection = 'asc';
                } else if (sortValue === 'name-asc') {
                    sortColumn = 'name';
                    sortDirection = 'asc';
                } else if (sortValue === 'name-desc') {
                    sortColumn = 'name';
                    sortDirection = 'desc';
                }
            }

            // Apply sorting
            if (sortColumn === 'score') {
                sourceData.sort((a, b) => sortDirection === 'desc' ? b.avgScore - a.avgScore : a.avgScore - b.avgScore);
            } else if (sortColumn === 'complete') {
                sourceData.sort((a, b) => sortDirection === 'desc' ? b.percentComplete - a.percentComplete : a.percentComplete - b.percentComplete);
            } else if (sortColumn === 'name') {
                sourceData.sort((a, b) => sortDirection === 'desc' ? b.source.localeCompare(a.source) : a.source.localeCompare(b.source));
            } else if (sortColumn === 'total') {
                sourceData.sort((a, b) => sortDirection === 'desc' ? b.total - a.total : a.total - b.total);
            } else if (sortColumn === 'listened') {
                sourceData.sort((a, b) => sortDirection === 'desc' ? b.listened - a.listened : a.listened - b.listened);
            }

            // Update the grid based on view mode
            const grid = document.getElementById('sourceListsGrid');
            if (grid) {
                if (sourceListViewMode === 'tiles') {
                    grid.className = 'stats-grid';
                    grid.innerHTML = sourceData.map(data => {
                        const percentComplete = data.percentComplete.toFixed(0);
                        return `
                            <div class="stat-card" style="cursor: pointer;" onclick="showSourceDrilldown('${data.source.replace(/'/g, "\\'")}')">
                                <h4 style="font-size: 1em; margin-bottom: 10px;">${data.source}</h4>
                                <div class="stat-item">
                                    <span>Total Albums</span>
                                    <strong>${data.total}</strong>
                                </div>
                                <div class="stat-item">
                                    <span>Listened</span>
                                    <strong>${data.listened}</strong>
                                </div>
                                <div class="stat-item">
                                    <span>% Complete</span>
                                    <strong style="color: ${percentComplete >= 75 ? '#28a745' : percentComplete >= 50 ? '#ffc107' : '#dc3545'};">${percentComplete}%</strong>
                                </div>
                                <div class="stat-item">
                                    <span>Average Score</span>
                                    <strong>${data.avgScore > 0 ? data.avgScore.toFixed(2) : 'N/A'}</strong>
                                </div>
                            </div>
                        `;
                    }).join('');
                } else {
                    // Table view
                    grid.className = '';
                    
                    // Helper function to get sort indicator
                    const getSortIndicator = (column) => {
                        if (sourceListTableSort.column === column) {
                            return sourceListTableSort.direction === 'desc' ? ' ' : ' ';
                        }
                        return '';
                    };
                    
                    // Get theme colors from CSS variables
                    const gradientStart = getComputedStyle(document.documentElement).getPropertyValue('--gradient-start').trim();
                    const gradientEnd = getComputedStyle(document.documentElement).getPropertyValue('--gradient-end').trim();
                    const chartBg = getComputedStyle(document.documentElement).getPropertyValue('--chart-bg').trim();
                    const chartText = getComputedStyle(document.documentElement).getPropertyValue('--chart-text').trim();
                    
                    grid.innerHTML = `
                        <table style="width: 100%; border-collapse: collapse; background: ${chartBg}; border-radius: 8px; overflow: hidden;">
                            <thead>
                                <tr style="background: ${chartBg}; color: ${chartText}; border-bottom: 2px solid rgba(0,0,0,0.2);">
                                    <th style="padding: 12px; text-align: left; font-weight: 600; cursor: pointer; user-select: none;" onclick="sortSourceListTable('name')" title="Click to sort">
                                        Source List${getSortIndicator('name')}
                                    </th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; cursor: pointer; user-select: none;" onclick="sortSourceListTable('total')" title="Click to sort">
                                        Total Albums${getSortIndicator('total')}
                                    </th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; cursor: pointer; user-select: none;" onclick="sortSourceListTable('listened')" title="Click to sort">
                                        Listened${getSortIndicator('listened')}
                                    </th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; cursor: pointer; user-select: none;" onclick="sortSourceListTable('complete')" title="Click to sort">
                                        % Complete${getSortIndicator('complete')}
                                    </th>
                                    <th style="padding: 12px; text-align: center; font-weight: 600; cursor: pointer; user-select: none;" onclick="sortSourceListTable('score')" title="Click to sort">
                                        Average Score${getSortIndicator('score')}
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                ${sourceData.map(data => {
                                    const percentComplete = data.percentComplete.toFixed(0);
                                    return `
                                        <tr style="cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.1); transition: background 0.2s; color: ${chartText};" onclick="showSourceDrilldown('${data.source.replace(/'/g, "\\'")}')">
                                            <td style="padding: 12px; font-weight: 500;">${data.source}</td>
                                            <td style="padding: 12px; text-align: center;">${data.total}</td>
                                            <td style="padding: 12px; text-align: center;">${data.listened}</td>
                                            <td style="padding: 12px; text-align: center;">
                                                <span style="color: ${percentComplete >= 75 ? '#28a745' : percentComplete >= 50 ? '#ffc107' : '#dc3545'}; font-weight: 600;">${percentComplete}%</span>
                                            </td>
                                            <td style="padding: 12px; text-align: center; font-weight: 600;">${data.avgScore > 0 ? data.avgScore.toFixed(2) : 'N/A'}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                        <style>
                            #sourceListsGrid tbody tr:hover {
                                background: rgba(0, 0, 0, 0.05) !important;
                            }
                            #sourceListsGrid thead th:hover {
                                filter: brightness(0.85) !important;
                            }
                        </style>
                    `;
                }
            }
        }
        
        function toggleSourceListView() {
            sourceListViewMode = sourceListViewMode === 'tiles' ? 'table' : 'tiles';
            
            // Update button text and icon
            const icon = document.getElementById('sourceListViewIcon');
            const text = document.getElementById('sourceListViewText');
            if (icon && text) {
                if (sourceListViewMode === 'tiles') {
                    icon.textContent = '';
                    text.textContent = 'Table View';
                } else {
                    icon.textContent = '';
                    text.textContent = 'Tiles View';
                }
            }
            
            // Re-render with current sort
            sortSourceLists();
        }

        function sortSourceListTable(column) {
            // Toggle direction if clicking the same column, otherwise default to descending
            if (sourceListTableSort.column === column) {
                sourceListTableSort.direction = sourceListTableSort.direction === 'desc' ? 'asc' : 'desc';
            } else {
                sourceListTableSort.column = column;
                sourceListTableSort.direction = 'desc';
            }
            
            // Re-render the table with new sort
            sortSourceLists();
        }

        // Drilldown functions
        function showArtistDrilldown(artist) {
            const albums = db.getAllAlbums().filter(a => a.artist === artist);
            showDrilldownModal(`Albums by ${artist}`, albums);
        }

        function showGenreDrilldown(genre) {
            const albums = db.getAllAlbums().filter(a => {
                const genres = db.parseMultiValue(a.genre, true);
                return genres.includes(genre);
            });
            showDrilldownModal(`Albums in ${genre}`, albums);
        }

        function showSourceDrilldown(source) {
            const albums = db.getAllAlbums().filter(a => {
                const sources = db.parseMultiValue(a.reason);
                return sources.includes(source);
            });
            showDrilldownModal(`Albums from ${source}`, albums);
        }

        function filterMonthlyStatsByYear(year) {
            window.monthlyStatsYear = year;
            loadStatsSection();
        }

        // Bayesian weighted scoring with improved sample size handling
        function calculateWeightedScore(scores, globalMean, baseConfidence) {
            if (!scores || scores.length === 0) return 0;
            const n = scores.length;
            const sum = scores.reduce((a, b) => a + parseFloat(b), 0);
            
            // Use dynamic confidence that decreases with sample size
            // This gives more weight to actual data as sample size increases
            const dynamicConfidence = getDynamicConfidence(n, baseConfidence);
            
            return (dynamicConfidence * globalMean + sum) / (dynamicConfidence + n);
        }

        // Get dynamic confidence weight that adapts to sample size
        // Smaller samples get less shrinkage, larger samples get more reliable weighting
        function getDynamicConfidence(sampleSize, baseConfidence) {
            // For very small samples (1-2 albums), use minimal shrinkage
            if (sampleSize === 1) return baseConfidence * 0.3;  // 30% of base
            if (sampleSize === 2) return baseConfidence * 0.5;  // 50% of base
            if (sampleSize === 3) return baseConfidence * 0.7;  // 70% of base
            
            // For medium samples (4-6 albums), use moderate shrinkage
            if (sampleSize <= 6) return baseConfidence * 0.85; // 85% of base
            
            // For larger samples (7+ albums), use full shrinkage
            return baseConfidence;
        }

        // Get base confidence weight based on collection size
        function getConfidenceWeight(totalAlbums) {
            // Reduced base values since we now apply dynamic scaling
            if (totalAlbums < 50) return 2;
            if (totalAlbums < 200) return 3;
            if (totalAlbums < 500) return 5;
            return 8;
        }

        // Calculate global mean score
        function getGlobalMean(albums) {
            const ratedAlbums = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '');
            if (ratedAlbums.length === 0) return 7.5; // Default
            return ratedAlbums.reduce((sum, a) => sum + parseFloat(a.score), 0) / ratedAlbums.length;
        }

        // Change ranking method
        function changeRankingMethod(method) {
            localStorage.setItem('ranking_method', method);
            loadStatsSection();
        }

        // Show ranking explanation modal
        function showRankingExplanation() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.style.display = 'flex';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <div class="modal-header">
                        <h2> Ranking Methods Explained</h2>
                        <button class="close-modal" onclick="this.closest('.modal').remove()">&times;</button>
                    </div>
                    <div class="modal-body">
                        <h3 style="color: #667eea; margin-top: 0;">Raw Score (Simple Average)</h3>
                        <p>Calculates the simple average of all scores.</p>
                        <p><strong>Example:</strong></p>
                        <ul>
                            <li>Artist A: 1 album, score 10.0  Average: <strong>10.0</strong></li>
                            <li>Artist B: 50 albums, average 9.2  Average: <strong>9.2</strong></li>
                        </ul>
                        <p style="color: #dc3545;"><strong>Problem:</strong> Artist A ranks higher, but is it really better with only 1 album?</p>
                        
                        <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
                        
                        <h3 style="color: #667eea;">Weighted Score (Bayesian)</h3>
                        <p>Adjusts scores based on sample size using <strong>adaptive shrinkage</strong>. Small samples get minimal adjustment to preserve their high scores, while still accounting for uncertainty.</p>
                        <p><strong>How it works:</strong></p>
                        <ul>
                            <li>1-2 albums: <strong>Minimal shrinkage</strong> (30-50% adjustment) - preserves exceptional ratings</li>
                            <li>3-6 albums: <strong>Moderate shrinkage</strong> (70-85% adjustment) - balances data and uncertainty</li>
                            <li>7+ albums: <strong>Full confidence</strong> - relies heavily on actual data</li>
                        </ul>
                        <p><strong>Same Example:</strong></p>
                        <ul>
                            <li>Artist A: 1 album, score 10.0  Weighted: <strong>9.4</strong> (lightly adjusted)</li>
                            <li>Artist B: 50 albums, average 9.2  Weighted: <strong>9.1</strong> (barely adjusted)</li>
                        </ul>
                        <p style="color: #28a745;"><strong>Result:</strong> Both artists can rank high, but with appropriate confidence levels!</p>
                        
                        <hr style="margin: 20px 0; border: none; border-top: 1px solid #ddd;">
                        
                        <h3 style="color: #667eea;">When to Use Each?</h3>
                        <ul>
                            <li><strong>Raw Score:</strong> Personal tracking, you trust all your ratings equally</li>
                            <li><strong>Weighted Score:</strong> More accurate rankings, especially with varying sample sizes</li>
                        </ul>
                        
                        <p style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-top: 20px;">
                            <strong> Tip:</strong> Weighted scoring is recommended for collections with 50+ albums, as it provides more meaningful rankings.
                        </p>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
            
            // Close on outside click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) modal.remove();
            });
        }

        function showMonthDrilldown(month) {
            const albums = db.getAllAlbums().filter(a => {
                if (!a.dateListened) return false;
                const date = new Date(a.dateListened);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                return key === month;
            });
            showDrilldownModal(`Albums listened in ${month}`, albums);
        }

        function showYearDrilldown(year) {
            const albums = db.getAllAlbums().filter(a => {
                if (!a.dateListened) return false;
                const date = new Date(a.dateListened);
                return String(date.getFullYear()) === year;
            });
            showDrilldownModal(`Albums listened in ${year}`, albums);
        }

        function showDrilldownModal(title, albums) {
            const modalContent = document.getElementById('albumModalContent');
            
            // Store albums for re-sorting
            window.drilldownAlbums = albums;
            window.drilldownTitle = title;
            
            // Default sort by score
            renderDrilldownAlbums('score');
        }

        function renderDrilldownAlbums(sortBy) {
            const modalContent = document.getElementById('albumModalContent');
            const albums = [...window.drilldownAlbums]; // Clone array
            const title = window.drilldownTitle;
            
            // Sort albums based on selection
            if (sortBy === 'score') {
                albums.sort((a, b) => {
                    if (a.score && b.score) return b.score - a.score;
                    if (a.score) return -1;
                    if (b.score) return 1;
                    return String(a.albumName).localeCompare(String(b.albumName));
                });
            } else if (sortBy === 'date') {
                albums.sort((a, b) => {
                    if (!a.dateListened && !b.dateListened) return 0;
                    if (!a.dateListened) return 1;
                    if (!b.dateListened) return -1;
                    return new Date(b.dateListened) - new Date(a.dateListened);
                });
            }

            modalContent.innerHTML = `
                <div style="margin-top: 40px;">
                    <h2 style="margin-bottom: 20px;">${title}</h2>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <p style="color: #6c757d;">Total: ${albums.length} albums</p>
                        <div>
                            <label style="font-size: 0.9em; color: #666; margin-right: 8px;">Sort by:</label>
                            <select id="drilldownSort" onchange="renderDrilldownAlbums(this.value)" style="padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer;">
                                <option value="score" ${sortBy === 'score' ? 'selected' : ''}>Score (Highest First)</option>
                                <option value="date" ${sortBy === 'date' ? 'selected' : ''}>Date Listened (Newest First)</option>
                            </select>
                        </div>
                    </div>
                    <div class="album-grid">
                        ${albums.map(album => `
                            <div class="album-card" onclick="showAlbumDetail(${album.id})">
                                <img src="${album.artworkUrl}" alt="${album.albumName}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                                <div class="album-card-info">
                                    <h3>${album.albumName}</h3>
                                    <p>${album.artist}</p>
                                    <p>${album.year}</p>
                                    ${album.score !== null && album.score !== undefined && album.score !== '' ? 
                                        `<span class="score-badge ${
                                            album.score >= 8 ? 'score-high' : 
                                            album.score >= 6 ? 'score-medium' : 
                                            album.score >= 4 ? 'score-low' : 'score-low'
                                        }">${album.score}/10</span>` : 
                                        '<span class="score-badge score-unrated">Not Rated</span>'
                                    }
                                    ${album.dateListened ? `<p style="font-size: 0.8em; margin-top: 5px;">Listened: ${new Date(album.dateListened).toLocaleDateString()}</p>` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            document.getElementById('albumModal').classList.add('active');
        }

        // Sync Menu Toggle
        function toggleSyncMenu() {
            const menu = document.getElementById('syncMenu');
            menu.classList.toggle('active');
        }

        // Close sync menu when clicking outside
        document.addEventListener('click', function(e) {
            const syncStatus = document.getElementById('syncStatus');
            const syncMenu = document.getElementById('syncMenu');
            
            if (syncStatus && syncMenu && 
                !syncStatus.contains(e.target) && 
                !syncMenu.contains(e.target)) {
                syncMenu.classList.remove('active');
            }
        });

        // Auto-sync to OneDrive after data changes
        function autoSyncToOneDrive() {
            if (syncManager && syncManager.isConnected()) {
                // Debounce sync to avoid too many requests
                clearTimeout(window.autoSyncTimeout);
                window.autoSyncTimeout = setTimeout(() => {
                    syncManager.syncToOneDrive().catch(err => {
                        console.error('Auto-sync failed:', err);
                    });
                }, 2000); // Wait 2 seconds after last change
            }
        }

        // Alert System
        function showAlert(type, message) {
            const alertClass = type === 'success' ? 'alert-success' : 
                             type === 'error' ? 'alert-error' : 'alert-info';
            
            const alert = document.createElement('div');
            alert.className = `alert ${alertClass}`;
            alert.textContent = message;
            alert.style.position = 'fixed';
            alert.style.top = '20px';
            alert.style.right = '20px';
            alert.style.zIndex = '10000';
            alert.style.minWidth = '300px';
            alert.style.animation = 'slideIn 0.3s';

            document.body.appendChild(alert);

            setTimeout(() => {
                alert.style.animation = 'slideOut 0.3s';
                setTimeout(() => alert.remove(), 300);
            }, 3000);
        }

        // Initialize
        // Auto-sync on activity
        let autoSyncTimeout = null;
        
        function scheduleAutoSync() {
            // Clear any existing timeout
            if (autoSyncTimeout) {
                clearTimeout(autoSyncTimeout);
            }
            
            // Schedule sync for 30 seconds from now
            autoSyncTimeout = setTimeout(() => {
                if (syncManager && syncManager.isConnected()) {
                    console.log('Auto-syncing to OneDrive...');
                    syncManager.syncToOneDrive();
                }
            }, 30000); // 30 seconds
        }
        
        // Trigger auto-sync on any user activity
        function setupAutoSync() {
            const activityEvents = ['click', 'keydown', 'scroll', 'touchstart'];
            
            activityEvents.forEach(eventType => {
                document.addEventListener(eventType, scheduleAutoSync, { passive: true });
            });
        }

        document.addEventListener('DOMContentLoaded', function() {
            // Load theme preference first
            loadThemePreference();
            
            // Initialize RPM speed slider to default (33.3 RPM)
            updateRPMSpeed();
            
            // Restore record player state from localStorage
            const savedState = localStorage.getItem('recordPlayerState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    currentRPM = state.rpm || 33.3;
                    updateRPMSpeed();
                    playAlbum(state.albumId, state.albumName, state.artist, state.artworkUrl);
                } catch (e) {
                    console.error('Failed to restore record player state:', e);
                    localStorage.removeItem('recordPlayerState');
                }
            }
            
            // Restore view mode preference
            const savedViewMode = localStorage.getItem('viewMode');
            const viewportMeta = document.getElementById('viewport-meta');
            const toggleBtn = document.getElementById('viewToggleBtn');
            
            if (savedViewMode === 'mobile') {
                viewportMeta.setAttribute('content', 'width=device-width, initial-scale=1.0');
                toggleBtn.innerHTML = ' Desktop View';
            } else {
                // Default to desktop view on mobile devices
                viewportMeta.setAttribute('content', 'width=1400, user-scalable=yes');
                toggleBtn.innerHTML = ' Mobile View';
            }
            
            // Setup auto-sync
            setupAutoSync();
            
            // Auto-sync from OneDrive on page load if connected
            if (syncManager.isConnected()) {
                console.log('Connected to OneDrive - syncing data...');
                syncManager.syncFromOneDrive().catch(err => {
                    console.error('Auto-sync from OneDrive failed:', err);
                });
            }
            
            // Load initial section
            loadBrowseSection();
            
            // Close modal on outside click
            document.getElementById('albumModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeModal();
                }
            });
        });
    </script>

    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</body>
</html>