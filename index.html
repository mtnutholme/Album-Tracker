<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https: data: blob:;">
    <title>Album Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .sync-status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
        }

        .sync-status.compact {
            padding: 8px 12px;
            border-radius: 12px;
            min-width: 100px;
            width: auto;
            max-width: 120px;
        }

        .sync-status.compact .sync-details {
            max-width: 0;
            opacity: 0;
            transition: all 0.3s;
        }

        .sync-status.compact:hover {
            padding: 10px 20px;
        }

        .sync-status.compact:hover .sync-details {
            max-width: 200px;
            opacity: 1;
            margin-left: 10px;
        }

        .sync-status:hover {
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
            transform: translateY(-2px);
        }

        .sync-details {
            display: flex;
            flex-direction: column;
            transition: all 0.3s;
        }

        .sync-main-text {
            font-weight: 600;
        }

        .sync-sub-text {
            font-size: 0.75em;
            color: #666;
        }

        .sync-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .sync-indicator.connected {
            background: #28a745;
        }

        .sync-indicator.syncing {
            background: #ffc107;
        }

        .sync-indicator.offline {
            background: #6c757d;
        }

        .sync-indicator.error {
            background: #dc3545;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .sync-menu {
            position: fixed;
            bottom: 80px;
            right: 20px;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            padding: 15px;
            min-width: 250px;
            z-index: 999;
            display: none;
        }

        .sync-menu.active {
            display: block;
            animation: fadeIn 0.2s;
        }

        .sync-menu-item {
            padding: 10px;
            cursor: pointer;
            border-radius: 6px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .sync-menu-item:hover {
            background: #f8f9fa;
        }

        .sync-menu-divider {
            height: 1px;
            background: #e9ecef;
            margin: 10px 0;
        }

        .nav {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }

        .nav button {
            padding: 12px 24px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .nav button:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .nav button.active {
            background: #764ba2;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* Vinyl Record Button */
        .vinyl-button {
            background: transparent;
            border: none;
            cursor: pointer;
            padding: 10px;
            transition: transform 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: white;
            font-weight: 600;
        }

        .vinyl-button:hover {
            transform: scale(1.1) rotate(15deg);
        }

        .vinyl-record {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            border-radius: 50%;
            position: relative;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4), inset 0 2px 5px rgba(255,255,255,0.1);
            animation: spin 3s linear infinite paused;
        }

        .vinyl-button:hover .vinyl-record {
            animation-play-state: running;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .vinyl-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            box-shadow: 0 0 0 2px #1a1a1a, 0 2px 5px rgba(0,0,0,0.3);
        }

        .vinyl-groove {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 45px;
            height: 45px;
            border: 2px solid rgba(255,255,255,0.05);
            border-radius: 50%;
        }

        .vinyl-groove::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35px;
            height: 35px;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
        }

        .content {
            padding: 30px;
            min-height: 500px;
        }

        .section {
            display: none;
        }

        .section.active {
            display: block;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .form-group textarea {
            resize: vertical;
            min-height: 100px;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            background: #667eea;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .random-album-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 16px;
            padding: 30px;
            color: white;
            margin-bottom: 30px;
        }

        .random-album-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            margin-top: 20px;
        }

        .album-artwork {
            width: 100%;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }

        .album-details {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .album-details h2 {
            font-size: 2em;
            margin-bottom: 10px;
        }

        .album-details p {
            font-size: 1.1em;
            opacity: 0.95;
        }

        .rating-form {
            background: white;
            color: #333;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
        }

        .filters {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            margin-bottom: 30px;
        }

        .search-container {
            position: relative;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            padding: 12px 40px 12px 16px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 16px;
            transition: all 0.3s;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .search-icon {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #6c757d;
            pointer-events: none;
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            margin-top: 4px;
            max-height: 400px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            display: none;
        }

        .search-results.active {
            display: block;
        }

        .search-result-item {
            padding: 12px 16px;
            cursor: pointer;
            border-bottom: 1px solid #e9ecef;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .search-result-item:last-child {
            border-bottom: none;
        }

        .search-result-item:hover {
            background: #f8f9fa;
        }

        .search-result-artwork {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            background: #e9ecef;
        }

        .search-result-info {
            flex: 1;
        }

        .search-result-album {
            font-weight: 600;
            color: #212529;
            margin-bottom: 2px;
        }

        .search-result-artist {
            font-size: 14px;
            color: #6c757d;
        }

        .search-no-results {
            padding: 20px;
            text-align: center;
            color: #6c757d;
        }

        .filters-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .album-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .album-card {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 12px;
            overflow: hidden;
            transition: all 0.3s;
            cursor: pointer;
        }

        .album-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border-color: #667eea;
        }

        .album-card img {
            width: 100%;
            height: 200px;
            object-fit: cover;
        }

        .album-card-info {
            padding: 15px;
        }

        .album-card-info h3 {
            font-size: 1em;
            margin-bottom: 5px;
            color: #333;
        }

        .album-card-info p {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 3px;
        }

        .score-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 0.9em;
            margin-top: 8px;
        }

        .score-high {
            background: #28a745;
            color: white;
        }

        .score-medium {
            background: #ffc107;
            color: #333;
        }

        .score-low {
            background: #dc3545;
            color: white;
        }

        .score-unrated {
            background: #e9ecef;
            color: #6c757d;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .stat-card {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid #e9ecef;
        }

        .stat-card h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 10px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .chart {
            background: white;
            padding: 20px;
            border-radius: 12px;
            margin-top: 20px;
            border: 2px solid #e9ecef;
        }

        .chart-bar {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        .chart-label {
            width: 150px;
            font-size: 0.9em;
            color: #333;
        }

        .chart-bar-fill {
            height: 30px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            padding: 0 10px;
            color: white;
            font-weight: 600;
            font-size: 0.9em;
            min-width: 40px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 16px;
            max-width: 800px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 30px;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: none;
            border: none;
            font-size: 2em;
            cursor: pointer;
            color: #6c757d;
            line-height: 1;
        }

        .modal-close:hover {
            color: #333;
        }

        .file-upload {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .file-upload:hover {
            background: #f8f9fa;
            border-color: #764ba2;
        }

        .file-upload input {
            display: none;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .alert-info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        @media (max-width: 768px) {
            .random-album-content {
                grid-template-columns: 1fr;
            }

            .album-grid {
                grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            }

            .filters-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }

            .nav {
                flex-direction: column;
            }

            .nav button {
                width: 100%;
            }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #6c757d;
        }

        .empty-state svg {
            width: 100px;
            height: 100px;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5em;
            margin-bottom: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #667eea;
            font-size: 1.2em;
        }

        .tag {
            display: inline-block;
            padding: 4px 10px;
            background: #e9ecef;
            border-radius: 12px;
            font-size: 0.85em;
            margin: 2px;
            color: #495057;
        }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .album-checkbox {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 24px;
            height: 24px;
            cursor: pointer;
            z-index: 10;
            accent-color: #9b59b6;
        }

        .album-card.multi-select-mode {
            cursor: pointer;
        }

        .album-card.selected {
            outline: 3px solid #9b59b6;
            outline-offset: -3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <!-- Random Album Button (Vinyl Record Style) -->
            <button onclick="pickRandomAlbum()" class="vinyl-button" title="Pick a Random Album" style="position: absolute; left: 25%; transform: translateX(-50%); top: 50%; margin-top: -30px;">
                <div class="vinyl-record">
                    <div class="vinyl-center"></div>
                    <div class="vinyl-groove"></div>
                </div>
                <span style="display: block; margin-top: 8px; font-size: 0.75em; white-space: nowrap;">Pick a Random Album</span>
            </button>
            
            <h1>üéµ Album Tracker</h1>
            <p>Track, Rate, and Discover Your Music Journey</p>
        </div>

        <div class="nav">
            <button onclick="showSection('browse', event)" class="active">Browse Albums</button>
            <button onclick="showSection('import', event)">Import/Export Data</button>
            <button onclick="showSection('stats', event)">Statistics</button>
        </div>

        <div class="content">
            <!-- Random Album Section -->
            <div id="random" class="section">
                <div class="random-album-card">
                    <h2 style="text-align: center;">Discover Your Next Album</h2>
                    <div style="text-align: center; margin: 20px 0;">
                        <button class="btn btn-success" onclick="selectRandomAlbum()" style="font-size: 1.2em; padding: 15px 40px;">
                            üé≤ Pick Random Album
                        </button>
                    </div>
                    <div id="randomAlbumDisplay"></div>
                </div>
            </div>

            <!-- Browse Albums Section -->
            <div id="browse" class="section active">
                <h2>Browse Albums</h2>
                
                <!-- Multi-select Controls -->
                <div id="multiSelectControls" style="margin-bottom: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; display: none;">
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="toggleSelectAll()">
                            <span id="selectAllText">Select All</span>
                        </button>
                        <button class="btn btn-danger" onclick="deleteSelectedAlbums()" id="deleteSelectedBtn" disabled>
                            üóëÔ∏è Delete Selected (<span id="selectedCount">0</span>)
                        </button>
                        <button class="btn btn-secondary" onclick="toggleMultiSelectMode()">
                            Cancel
                        </button>
                        <span style="color: #666; margin-left: auto;">Multi-select mode active</span>
                    </div>
                </div>
                
                <!-- Search Box -->
                <div class="search-container">
                    <input 
                        type="text" 
                        id="searchInput" 
                        class="search-input" 
                        placeholder="Search by album name or artist..."
                        autocomplete="off"
                    >
                    <span class="search-icon">üîç</span>
                    <div id="searchResults" class="search-results"></div>
                </div>
                
                <div class="filters">
                    <h3 style="margin-bottom: 15px;">Filters</h3>
                    <div class="filters-grid">
                        <div class="form-group">
                            <label>Genre</label>
                            <select id="filterGenre" onchange="applyFilters()">
                                <option value="">All Genres</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Source List</label>
                            <select id="filterSource" onchange="applyFilters()">
                                <option value="">All Sources</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Status</label>
                            <select id="filterStatus" onchange="applyFilters()">
                                <option value="">All</option>
                                <option value="listened">Listened</option>
                                <option value="unlistened">Unlistened</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Sort By</label>
                            <select id="sortBy" onchange="applyFilters()">
                                <option value="name-asc">Album Name (A-Z)</option>
                                <option value="name-desc">Album Name (Z-A)</option>
                                <option value="artist-asc">Artist (A-Z)</option>
                                <option value="artist-desc">Artist (Z-A)</option>
                                <option value="score-desc">Score (High-Low)</option>
                                <option value="score-asc">Score (Low-High)</option>
                                <option value="date-desc">Date Listened (Newest)</option>
                                <option value="date-asc">Date Listened (Oldest)</option>
                            </select>
                        </div>
                    </div>
                    <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                        <button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>
                        <button class="btn" onclick="toggleMultiSelectMode()">
                            <span id="multiSelectModeBtn">üìã Multi-Select</span>
                        </button>
                        <button class="btn btn-success" onclick="showAddAlbumForm()" style="margin-left: auto;">
                            ‚ûï Add Album
                        </button>
                    </div>
                </div>

                <!-- Add Album Form (Initially Hidden) -->
                <div id="addAlbumFormContainer" style="display: none; margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 12px; border: 2px solid #667eea;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">Add New Album</h3>
                        <button class="btn btn-secondary" onclick="hideAddAlbumForm()">‚úï Cancel</button>
                    </div>
                    <form id="addAlbumFormInline" onsubmit="addAlbumInline(event)">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                            <div class="form-group">
                                <label>Album Name *</label>
                                <input type="text" id="albumNameInline" required>
                            </div>
                            <div class="form-group">
                                <label>Artist *</label>
                                <input type="text" id="artistInline" required>
                            </div>
                            <div class="form-group">
                                <label>Year *</label>
                                <input type="number" id="yearInline" min="1900" max="2100" required>
                            </div>
                            <div class="form-group">
                                <label>Album Artwork URL *</label>
                                <input type="url" id="artworkUrlInline" required placeholder="https://...">
                            </div>
                            <div class="form-group">
                                <label>Genre</label>
                                <input type="text" id="genreInline" placeholder="Rock; Alternative">
                            </div>
                            <div class="form-group">
                                <label>Score (0-10)</label>
                                <input type="number" id="scoreInline" min="0" max="10" step="0.1">
                            </div>
                        </div>
                        <button type="submit" class="btn" style="margin-top: 15px;">Add Album</button>
                    </form>
                </div>

                <div id="albumGrid" class="album-grid"></div>
            </div>

            <!-- Add Album Section (Hidden - replaced by inline form) -->
            <div id="add" class="section">
                <h2>Add New Album</h2>
                <form id="addAlbumForm" onsubmit="addAlbum(event)">
                    <div class="form-group">
                        <label>Album Name *</label>
                        <input type="text" id="albumName" required>
                    </div>
                    <div class="form-group">
                        <label>Artist *</label>
                        <input type="text" id="artist" required>
                    </div>
                    <div class="form-group">
                        <label>Artist ID</label>
                        <input type="text" id="artistId">
                    </div>
                    <div class="form-group">
                        <label>Year *</label>
                        <input type="number" id="year" min="1900" max="2100" required>
                    </div>
                    <div class="form-group">
                        <label>Album Artwork URL *</label>
                        <input type="url" id="artworkUrl" required placeholder="https://...">
                    </div>
                    <div class="form-group">
                        <label>Discogs URL</label>
                        <div style="display: flex; gap: 10px;">
                            <input type="url" id="discogsUrl" placeholder="https://www.discogs.com/..." style="flex: 1;">
                            <button type="button" class="btn" onclick="fetchFromDiscogs()" style="white-space: nowrap;">Fetch from Discogs</button>
                        </div>
                        <small id="discogsStatus" style="color: #888; margin-top: 5px; display: block;"></small>
                    </div>
                    <div class="form-group">
                        <label>Genre (semicolon-separated for multiple)</label>
                        <input type="text" id="genre" placeholder="Rock; Alternative">
                    </div>
                    <div class="form-group">
                        <label>Style (semicolon-separated for multiple)</label>
                        <input type="text" id="style" placeholder="Indie Rock; Post-Punk">
                    </div>
                    <div class="form-group">
                        <label>Reason</label>
                        <input type="text" id="reason" value="Manual" placeholder="Manual or source lists separated by semicolons">
                    </div>
                    <div class="form-group">
                        <label>Score (0-10, leave empty if not rated)</label>
                        <input type="number" id="score" min="0" max="10" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Date Listened</label>
                        <input type="date" id="dateListened">
                    </div>
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="notes" placeholder="Your thoughts about this album..."></textarea>
                    </div>
                    <button type="submit" class="btn">Add Album</button>
                </form>
            </div>

            <!-- Import/Export Data Section -->
            <div id="import" class="section">
                <h2>Import/Export Album Data</h2>
                
                <!-- Export Section -->
                <div style="margin-bottom: 30px; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <h3 style="margin-bottom: 15px;">üì§ Export Data</h3>
                    <p style="color: #666; margin-bottom: 15px;">Download your album collection as an Excel file</p>
                    <button class="btn btn-success" onclick="exportData()" style="font-size: 1.1em; padding: 12px 30px;">
                        üì• Export to Excel
                    </button>
                </div>

                <!-- Import Section -->
                <div style="margin-bottom: 30px;">
                    <h3 style="margin-bottom: 15px;">üì• Import Data</h3>
                    <div class="alert alert-info">
                        <strong>Supported Format:</strong> Excel files (.xlsx, .xls) with columns: ID, Album Name, Artist, Year, Reason, Album Artwork URL, Discogs URL, Artist ID, Genre, Style, Score, Date Listened, Notes
                    </div>
                    <div class="file-upload" onclick="document.getElementById('fileInput').click()">
                        <input type="file" id="fileInput" accept=".xlsx,.xls" onchange="importExcel(event)">
                        <p style="font-size: 3em; margin-bottom: 10px;">üìÅ</p>
                        <p style="font-size: 1.2em; color: #667eea; font-weight: 600;">Click to upload Excel file</p>
                        <p style="color: #6c757d; margin-top: 10px;">Existing albums will be updated with new data</p>
                    </div>
                    <div id="importStatus"></div>
                </div>

                <!-- Template Download -->
                <div style="padding: 20px; background: #f8f9fa; border-radius: 12px;">
                    <h3 style="margin-bottom: 15px;">üìã Import Template</h3>
                    <p style="color: #666; margin-bottom: 15px;">Download a template with the correct column headers to get started</p>
                    <button class="btn btn-secondary" onclick="downloadImportTemplate()" style="font-size: 1.1em; padding: 12px 30px;">
                        üìÑ Download Import Template
                    </button>
                </div>
            </div>

            <!-- Statistics Section -->
            <div id="stats" class="section">
                <h2>Statistics & Analytics</h2>
                <div id="statsContent"></div>
            </div>
        </div>
    </div>

    <!-- Album Detail Modal -->
    <div id="albumModal" class="modal">
        <div class="modal-content">
            <button class="modal-close" onclick="closeModal()">&times;</button>
            <div id="albumModalContent"></div>
        </div>
    </div>

    <!-- OneDrive Sync Status -->
    <div class="sync-status" id="syncStatus" onclick="toggleSyncMenu()">
        <div class="sync-indicator offline" id="syncIndicator"></div>
        <div id="syncText">
            <span class="sync-main-text">Offline Mode</span>
        </div>
    </div>

    <!-- Sync Menu -->
    <div class="sync-menu" id="syncMenu">
        <div id="syncMenuContent"></div>
    </div>

    <!-- Include SheetJS library for Excel parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <script>
        // Database Management
        class AlbumDatabase {
            constructor() {
                this.albums = this.loadFromStorage();
            }

            loadFromStorage() {
                const data = localStorage.getItem('albumTrackerData');
                return data ? JSON.parse(data) : [];
            }

            saveToStorage() {
                localStorage.setItem('albumTrackerData', JSON.stringify(this.albums));
            }

            addAlbum(album) {
                const id = this.albums.length > 0 ? Math.max(...this.albums.map(a => a.id)) + 1 : 1;
                album.id = id;
                this.albums.push(album);
                this.saveToStorage();
                return album;
            }

            updateAlbum(id, updates) {
                const index = this.albums.findIndex(a => a.id === id);
                if (index !== -1) {
                    this.albums[index] = { ...this.albums[index], ...updates };
                    this.saveToStorage();
                    return this.albums[index];
                }
                return null;
            }

            deleteAlbum(id) {
                this.albums = this.albums.filter(a => a.id !== id);
                this.saveToStorage();
            }

            getAlbum(id) {
                return this.albums.find(a => a.id === id);
            }

            getAllAlbums() {
                return this.albums;
            }

            isDuplicate(albumName, artist) {
                return this.albums.some(a => 
                    String(a.albumName).toLowerCase() === String(albumName).toLowerCase() && 
                    String(a.artist).toLowerCase() === String(artist).toLowerCase()
                );
            }

            importAlbums(newAlbums) {
                let added = 0;
                let updated = 0;
                let skipped = 0;

                // Create a lookup map for faster duplicate checking
                const albumMap = new Map();
                this.albums.forEach(album => {
                    const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                    albumMap.set(key, album);
                });

                // Process in batches to avoid memory issues
                const BATCH_SIZE = 100;
                for (let i = 0; i < newAlbums.length; i += BATCH_SIZE) {
                    const batch = newAlbums.slice(i, i + BATCH_SIZE);
                    
                    batch.forEach(album => {
                        // Skip albums with truly empty names (but allow "0" or other falsy values that are valid)
                        if (album.albumName === '' || album.albumName === null || album.albumName === undefined) {
                            skipped++;
                            return;
                        }

                        // Check if album already exists using the map
                        const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                        const existingAlbum = albumMap.get(key);

                        if (existingAlbum) {
                            // Update existing album with new data (only if new data is provided)
                            const updates = {};
                            if (album.score !== null && album.score !== undefined && album.score !== '') updates.score = album.score;
                            if (album.dateListened) updates.dateListened = album.dateListened;
                            if (album.notes) updates.notes = album.notes;
                            if (album.artworkUrl) updates.artworkUrl = album.artworkUrl;
                            if (album.discogsUrl) updates.discogsUrl = album.discogsUrl;
                            if (album.genre) updates.genre = album.genre;
                            if (album.style) updates.style = album.style;
                            if (album.year) updates.year = album.year;
                            if (album.artistId) updates.artistId = album.artistId;
                            
                            // Merge reasons (source lists) if new ones are provided
                            if (album.reason && album.reason !== 'Manual') {
                                const existingReasons = this.parseMultiValue(existingAlbum.reason);
                                const newReasons = this.parseMultiValue(album.reason);
                                const mergedReasons = [...new Set([...existingReasons, ...newReasons])];
                                updates.reason = mergedReasons.join('; ');
                            }

                            if (Object.keys(updates).length > 0) {
                                this.updateAlbum(existingAlbum.id, updates);
                                updated++;
                            } else {
                                skipped++;
                            }
                        } else {
                            const newAlbum = this.addAlbum(album);
                            // Add to map for subsequent batches
                            albumMap.set(key, newAlbum);
                            added++;
                        }
                    });
                    
                    // Save after each batch to prevent memory buildup
                    this.saveToStorage();
                }

                return { added, updated, skipped };
            }

            // Async version of importAlbums with progress callback
            async importAlbumsAsync(newAlbums, progressCallback) {
                let added = 0;
                let updated = 0;
                let skipped = 0;

                // Create a map of existing albums for faster lookup
                const albumMap = new Map();
                this.albums.forEach(album => {
                    const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                    albumMap.set(key, album);
                });

                // Process in smaller batches with async breaks to prevent timeout
                const BATCH_SIZE = 50; // Smaller batches for better UI responsiveness
                const PROGRESS_UPDATE_INTERVAL = 100; // Update progress every 100 albums
                
                for (let i = 0; i < newAlbums.length; i += BATCH_SIZE) {
                    const batch = newAlbums.slice(i, i + BATCH_SIZE);
                    
                    batch.forEach(album => {
                        // Skip albums with truly empty names
                        if (album.albumName === '' || album.albumName === null || album.albumName === undefined) {
                            skipped++;
                            return;
                        }

                        // Check if album already exists using the map
                        const key = `${String(album.albumName).toLowerCase()}|${String(album.artist).toLowerCase()}`;
                        const existingAlbum = albumMap.get(key);

                        if (existingAlbum) {
                            // Update existing album with new data - only if values are different
                            const updates = {};
                            
                            // Update score if new value exists and is different
                            if (album.score !== null && album.score !== undefined && album.score !== '' && album.score !== existingAlbum.score) {
                                updates.score = album.score;
                            }
                            
                            // Update dateListened if new value exists and is different
                            if (album.dateListened && album.dateListened !== existingAlbum.dateListened) {
                                updates.dateListened = album.dateListened;
                            }
                            
                            // Update notes if new value exists and is different
                            if (album.notes && album.notes !== existingAlbum.notes) {
                                updates.notes = album.notes;
                            }
                            
                            // Update artworkUrl if new value exists and is different
                            if (album.artworkUrl && album.artworkUrl !== existingAlbum.artworkUrl) {
                                updates.artworkUrl = album.artworkUrl;
                            }
                            
                            // Update discogsUrl if new value exists and is different
                            if (album.discogsUrl && album.discogsUrl !== existingAlbum.discogsUrl) {
                                updates.discogsUrl = album.discogsUrl;
                            }
                            
                            // Update genre if new value exists and is different
                            if (album.genre && album.genre !== existingAlbum.genre) {
                                updates.genre = album.genre;
                            }
                            
                            // Update style if new value exists and is different
                            if (album.style && album.style !== existingAlbum.style) {
                                updates.style = album.style;
                            }
                            
                            // Update year if new value exists and is different
                            if (album.year && album.year !== existingAlbum.year) {
                                updates.year = album.year;
                            }
                            
                            // Update artistId if new value exists and is different
                            if (album.artistId && album.artistId !== existingAlbum.artistId) {
                                updates.artistId = album.artistId;
                            }
                            
                            // Merge reasons (source lists)
                            if (album.reason && album.reason !== 'Manual') {
                                const existingReasons = this.parseMultiValue(existingAlbum.reason);
                                const newReasons = this.parseMultiValue(album.reason);
                                const mergedReasons = [...new Set([...existingReasons, ...newReasons])];
                                const mergedReason = mergedReasons.join('; ');
                                if (mergedReason !== existingAlbum.reason) {
                                    updates.reason = mergedReason;
                                }
                            }

                            if (Object.keys(updates).length > 0) {
                                this.updateAlbum(existingAlbum.id, updates);
                                updated++;
                            } else {
                                skipped++;
                            }
                        } else {
                            const newAlbum = this.addAlbum(album);
                            albumMap.set(key, newAlbum);
                            added++;
                        }
                    });
                    
                    // Save after each batch
                    this.saveToStorage();
                    
                    // Update progress callback
                    if (progressCallback && (i % PROGRESS_UPDATE_INTERVAL === 0 || i + BATCH_SIZE >= newAlbums.length)) {
                        progressCallback({
                            processed: Math.min(i + BATCH_SIZE, newAlbums.length),
                            total: newAlbums.length,
                            added,
                            updated,
                            skipped
                        });
                    }
                    
                    // Yield to browser to prevent freezing (every batch)
                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                return { added, updated, skipped };
            }

            // Parse semicolon-separated fields
            parseMultiValue(value) {
                if (!value) return [];
                return value.split(';').map(v => v.trim()).filter(v => v);
            }

            // Get all unique genres
            getAllGenres() {
                const genres = new Set();
                this.albums.forEach(album => {
                    this.parseMultiValue(album.genre).forEach(g => genres.add(g));
                });
                return Array.from(genres).sort();
            }

            // Get all unique source lists
            getAllSources() {
                const sources = new Set();
                this.albums.forEach(album => {
                    if (album.reason && album.reason !== 'Manual') {
                        this.parseMultiValue(album.reason).forEach(s => sources.add(s));
                    }
                });
                return Array.from(sources).sort();
            }

            // Get all unique styles
            getAllStyles() {
                const styles = new Set();
                this.albums.forEach(album => {
                    this.parseMultiValue(album.style).forEach(s => styles.add(s));
                });
                return Array.from(styles).sort();
            }

            // Filter albums
            filterAlbums(filters) {
                return this.albums.filter(album => {
                    // Genre filter
                    if (filters.genre) {
                        const genres = this.parseMultiValue(album.genre);
                        if (!genres.includes(filters.genre)) return false;
                    }

                    // Source filter
                    if (filters.source) {
                        const sources = this.parseMultiValue(album.reason);
                        if (!sources.includes(filters.source)) return false;
                    }

                    // Status filter
                    if (filters.status === 'listened' && !album.dateListened) return false;
                    if (filters.status === 'unlistened' && album.dateListened) return false;

                    // Score range filter
                    if (filters.minScore !== undefined && (album.score === null || album.score < filters.minScore)) return false;
                    if (filters.maxScore !== undefined && (album.score === null || album.score > filters.maxScore)) return false;

                    return true;
                });
            }

            // Sort albums
            sortAlbums(albums, sortBy) {
                const sorted = [...albums];
                switch (sortBy) {
                    case 'name-asc':
                        return sorted.sort((a, b) => String(a.albumName).localeCompare(String(b.albumName)));
                    case 'name-desc':
                        return sorted.sort((a, b) => String(b.albumName).localeCompare(String(a.albumName)));
                    case 'artist-asc':
                        return sorted.sort((a, b) => String(a.artist).localeCompare(String(b.artist)));
                    case 'artist-desc':
                        return sorted.sort((a, b) => String(b.artist).localeCompare(String(a.artist)));
                    case 'score-desc':
                        return sorted.sort((a, b) => (b.score || 0) - (a.score || 0));
                    case 'score-asc':
                        return sorted.sort((a, b) => (a.score || 0) - (b.score || 0));
                    case 'date-desc':
                        return sorted.sort((a, b) => {
                            if (!a.dateListened) return 1;
                            if (!b.dateListened) return -1;
                            return new Date(b.dateListened) - new Date(a.dateListened);
                        });
                    case 'date-asc':
                        return sorted.sort((a, b) => {
                            if (!a.dateListened) return 1;
                            if (!b.dateListened) return -1;
                            return new Date(a.dateListened) - new Date(b.dateListened);
                        });
                    default:
                        return sorted;
                }
            }

            // Get random unscored album
            getRandomUnscoredAlbum() {
                const unscored = this.albums.filter(a => a.score === null || a.score === undefined || a.score === '');
                if (unscored.length === 0) return null;
                return unscored[Math.floor(Math.random() * unscored.length)];
            }

            // Statistics methods
            getMonthlyStats() {
                const stats = {};
                this.albums.forEach(album => {
                    if (album.dateListened) {
                        const date = new Date(album.dateListened);
                        const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                        if (!stats[key]) {
                            stats[key] = { count: 0, scores: [] };
                        }
                        stats[key].count++;
                        if (album.score !== null && album.score !== undefined && album.score !== '') {
                            stats[key].scores.push(parseFloat(album.score));
                        }
                    }
                });
                return stats;
            }

            getYearlyStats() {
                const stats = {};
                this.albums.forEach(album => {
                    if (album.dateListened) {
                        const date = new Date(album.dateListened);
                        const key = String(date.getFullYear());
                        if (!stats[key]) {
                            stats[key] = { count: 0, scores: [] };
                        }
                        stats[key].count++;
                        if (album.score !== null && album.score !== undefined && album.score !== '') {
                            stats[key].scores.push(parseFloat(album.score));
                        }
                    }
                });
                return stats;
            }

            getAverageScoreByArtist() {
                const artistScores = {};
                this.albums.forEach(album => {
                    if (album.score !== null && album.score !== undefined && album.score !== '') {
                        if (!artistScores[album.artist]) {
                            artistScores[album.artist] = [];
                        }
                        artistScores[album.artist].push(parseFloat(album.score));
                    }
                });

                const averages = {};
                Object.keys(artistScores).forEach(artist => {
                    const scores = artistScores[artist];
                    averages[artist] = {
                        average: scores.reduce((a, b) => a + b, 0) / scores.length,
                        count: scores.length
                    };
                });

                return Object.entries(averages)
                    .sort((a, b) => b[1].average - a[1].average)
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }

            getAverageScoreByGenre() {
                const genreScores = {};
                this.albums.forEach(album => {
                    if (album.score !== null && album.score !== undefined && album.score !== '') {
                        const genres = this.parseMultiValue(album.genre);
                        genres.forEach(genre => {
                            if (!genreScores[genre]) {
                                genreScores[genre] = [];
                            }
                            genreScores[genre].push(parseFloat(album.score));
                        });
                    }
                });

                const averages = {};
                Object.keys(genreScores).forEach(genre => {
                    const scores = genreScores[genre];
                    averages[genre] = scores.reduce((a, b) => a + b, 0) / scores.length;
                });

                return Object.entries(averages)
                    .sort((a, b) => b[1] - a[1])
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }

            getSourceListStats() {
                const sources = this.getAllSources();
                const stats = {};

                sources.forEach(source => {
                    const albums = this.albums.filter(album => {
                        const albumSources = this.parseMultiValue(album.reason);
                        return albumSources.includes(source);
                    });

                    const listened = albums.filter(a => a.dateListened).length;
                    const scored = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '');
                    const avgScore = scored.length > 0 
                        ? scored.reduce((sum, a) => sum + parseFloat(a.score), 0) / scored.length 
                        : null;

                    stats[source] = {
                        total: albums.length,
                        listened,
                        avgScore
                    };
                });

                return stats;
            }

            getGenreCounts() {
                const genreCounts = {};
                this.albums.forEach(album => {
                    const genres = this.parseMultiValue(album.genre);
                    genres.forEach(genre => {
                        if (!genreCounts[genre]) {
                            genreCounts[genre] = 0;
                        }
                        genreCounts[genre]++;
                    });
                });

                return Object.entries(genreCounts)
                    .sort((a, b) => b[1] - a[1])
                    .reduce((obj, [key, val]) => ({ ...obj, [key]: val }), {});
            }
        }

        // OneDrive Sync Manager
        class OneDriveSyncManager {
            constructor() {
                // IMPORTANT: Replace this with your own Azure App Registration Client ID
                // Instructions: https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app
                
                // Your Azure App Registration Client ID
                this.clientId = 'b19c334e-f1e3-432d-9d79-c50a88eeef0f';
                
                // Redirect URI - automatically detect the current URL
                this.redirectUri = window.location.origin + window.location.pathname;
                this.scopes = ['Files.ReadWrite', 'offline_access'];
                this.fileName = 'album-tracker-data.json';
                this.folderName = 'AlbumTracker';
                
                // Log setup instructions with the actual redirect URI
                console.log('');
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë                  ‚ö†Ô∏è  AZURE SETUP REQUIRED  ‚ö†Ô∏è                ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.log('');
                console.log('üìã STEP 1: COPY THIS REDIRECT URI (select and copy):');
                console.log('');
                console.log('   http://localhost');
                console.log('');
                console.log('üìã STEP 2: ADD TO AZURE PORTAL:');
                console.log('');
                console.log('   1. Go to: https://portal.azure.com');
                console.log('   2. Find app: b19c334e-f1e3-432d-9d79-c50a88eeef0f');
                console.log('   3. Click: Authentication (left sidebar)');
                console.log('   4. Scroll to: "Single-page application"');
                console.log('   5. Click: "Add URI"');
                console.log('   6. Paste: http://localhost');
                console.log('   7. Scroll to: "Implicit grant and hybrid flows"');
                console.log('   8. Check: ‚úÖ Access tokens');
                console.log('   9. Check: ‚úÖ ID tokens');
                console.log('   10. Click: Save');
                console.log('');
                console.log('‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó');
                console.log('‚ïë  After setup, click the sync indicator to connect OneDrive   ‚ïë');
                console.log('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù');
                console.log('');
                
                this.accessToken = localStorage.getItem('onedrive_access_token');
                this.refreshToken = localStorage.getItem('onedrive_refresh_token');
                this.tokenExpiry = localStorage.getItem('onedrive_token_expiry');
                
                this.syncInProgress = false;
                this.lastSyncTime = localStorage.getItem('last_sync_time');
                
                this.updateUI();
                
                // Check if we're returning from OAuth
                this.handleOAuthCallback();
                
                // Auto-sync on load if connected
                if (this.isConnected()) {
                    this.syncFromOneDrive();
                }
            }

            isConnected() {
                return !!this.accessToken && new Date().getTime() < parseInt(this.tokenExpiry || '0');
            }

            async ensureValidToken() {
                if (!this.accessToken) {
                    throw new Error('Not authenticated');
                }

                // Check if token is expired or will expire in next 5 minutes
                const now = new Date().getTime();
                const expiry = parseInt(this.tokenExpiry || '0');
                
                if (now >= expiry - 300000) { // 5 minutes before expiry
                    await this.refreshAccessToken();
                }
            }

            async refreshAccessToken() {
                if (!this.refreshToken) {
                    throw new Error('No refresh token available');
                }

                try {
                    const response = await fetch('https://login.microsoftonline.com/consumers/oauth2/v2.0/token', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: new URLSearchParams({
                            client_id: this.clientId,
                            scope: this.scopes.join(' '),
                            refresh_token: this.refreshToken,
                            grant_type: 'refresh_token'
                        })
                    });

                    if (!response.ok) {
                        throw new Error('Failed to refresh token');
                    }

                    const data = await response.json();
                    this.saveTokens(data);
                } catch (error) {
                    console.error('Token refresh failed:', error);
                    this.disconnect();
                    throw error;
                }
            }

            connectToOneDrive() {
                // Check if client ID is configured
                if (this.clientId === 'YOUR_CLIENT_ID_HERE') {
                    alert('OneDrive integration requires setup!\n\nPlease follow these steps:\n\n1. Go to Azure Portal (portal.azure.com)\n2. Register a new app\n3. Get your Client ID\n4. Replace YOUR_CLIENT_ID_HERE in the code\n\nSee the console for more details.');
                    console.log('%cOneDrive Setup Instructions:', 'font-size: 16px; font-weight: bold; color: #0078d4;');
                    console.log('1. Go to https://portal.azure.com');
                    console.log('2. Navigate to "Azure Active Directory" > "App registrations" > "New registration"');
                    console.log('3. Name: "Album Tracker"');
                    console.log('4. Supported account types: "Personal Microsoft accounts only"');
                    console.log('5. Redirect URI: "Single-page application (SPA)" - http://localhost');
                    console.log('6. After registration, copy the "Application (client) ID"');
                    console.log('7. Go to "API permissions" > "Add a permission" > "Microsoft Graph" > "Delegated permissions"');
                    console.log('8. Add: Files.ReadWrite and offline_access');
                    console.log('9. Replace YOUR_CLIENT_ID_HERE in the code with your Client ID');
                    console.log('10. Under "Authentication", enable "Access tokens" and "ID tokens" in Implicit grant section');
                    return;
                }

                console.log('Redirect URI: http://localhost');
                console.log('Please add this exact URI to your Azure app registration under Authentication > Single-page application');

                // Show helpful instructions
                const proceed = confirm(
                    'üîê Important:\n\n' +
                    '1. You\'ll be redirected to Microsoft login\n' +
                    '2. After login, you\'ll be sent to http://localhost\n' +
                    '3. IMPORTANT: After redirect, manually open this site again\n' +
                    '4. The app will detect your login and connect automatically\n\n' +
                    '‚ö†Ô∏è Make sure you\'ve added "http://localhost" to your Azure app\'s redirect URIs!\n\n' +
                    'Click OK to continue to Microsoft login.'
                );

                if (!proceed) {
                    return;
                }

                // Use implicit flow with token response (works for local files)
                // Use 'consumers' to force personal Microsoft accounts only
                const authUrl = `https://login.microsoftonline.com/consumers/oauth2/v2.0/authorize?` +
                    `client_id=${this.clientId}` +
                    `&response_type=token` +
                    `&redirect_uri=${encodeURIComponent(this.redirectUri)}` +
                    `&response_mode=fragment` +
                    `&scope=${encodeURIComponent(this.scopes.join(' '))}` +
                    `&state=${Date.now()}` +
                    `&prompt=select_account`;

                // Redirect in the same window (works better for local files)
                window.location.href = authUrl;
            }

            async handleOAuthCallback() {
                // Check for implicit flow token in URL fragment (hash)
                const hash = window.location.hash.substring(1);
                const params = new URLSearchParams(hash);
                const accessToken = params.get('access_token');
                const expiresIn = params.get('expires_in');

                if (accessToken) {
                    try {
                        this.updateUI('syncing', 'Connecting to OneDrive...');
                        
                        // Save the token (implicit flow doesn't provide refresh token)
                        const tokenData = {
                            access_token: accessToken,
                            expires_in: parseInt(expiresIn) || 3600,
                            refresh_token: null // Implicit flow doesn't provide refresh tokens
                        };
                        
                        this.saveTokens(tokenData);

                        // Clean URL (remove hash)
                        window.history.replaceState({}, document.title, window.location.pathname);

                        // Sync data
                        await this.syncFromOneDrive();
                        
                        showAlert('success', 'Connected to OneDrive successfully!');
                    } catch (error) {
                        console.error('OAuth callback error:', error);
                        showAlert('error', 'Failed to connect to OneDrive');
                        this.updateUI('offline', 'Offline Mode');
                    }
                }
            }

            saveTokens(data) {
                this.accessToken = data.access_token;
                this.refreshToken = data.refresh_token;
                const expiresIn = data.expires_in || 3600;
                this.tokenExpiry = (new Date().getTime() + (expiresIn * 1000)).toString();

                localStorage.setItem('onedrive_access_token', this.accessToken);
                localStorage.setItem('onedrive_refresh_token', this.refreshToken);
                localStorage.setItem('onedrive_token_expiry', this.tokenExpiry);

                this.updateUI('connected', 'Connected to OneDrive');
            }

            disconnect() {
                this.accessToken = null;
                this.refreshToken = null;
                this.tokenExpiry = null;

                localStorage.removeItem('onedrive_access_token');
                localStorage.removeItem('onedrive_refresh_token');
                localStorage.removeItem('onedrive_token_expiry');
                localStorage.removeItem('last_sync_time');

                this.updateUI('offline', 'Offline Mode');
                showAlert('info', 'Disconnected from OneDrive');
            }

            async syncToOneDrive() {
                if (!this.isConnected()) {
                    throw new Error('Not connected to OneDrive');
                }

                if (this.syncInProgress) {
                    return;
                }

                try {
                    this.syncInProgress = true;
                    this.updateUI('syncing', 'Syncing to OneDrive...');

                    await this.ensureValidToken();

                    // Get current data
                    const data = db.getAllAlbums();
                    const jsonData = JSON.stringify(data, null, 2);

                    // Get or create folder
                    const folderId = await this.ensureFolder();

                    // Check if file exists
                    const fileId = await this.getFileId(folderId);

                    if (fileId) {
                        // Update existing file
                        await this.updateFile(fileId, jsonData);
                    } else {
                        // Create new file
                        await this.createFile(folderId, jsonData);
                    }

                    this.lastSyncTime = new Date().toISOString();
                    localStorage.setItem('last_sync_time', this.lastSyncTime);

                    this.updateUI('connected', 'Synced to OneDrive');
                    setTimeout(() => this.updateUI(), 2000);

                } catch (error) {
                    console.error('Sync to OneDrive failed:', error);
                    this.updateUI('error', 'Sync failed');
                    setTimeout(() => this.updateUI(), 3000);
                    throw error;
                } finally {
                    this.syncInProgress = false;
                }
            }

            async syncFromOneDrive() {
                if (!this.isConnected()) {
                    throw new Error('Not connected to OneDrive');
                }

                if (this.syncInProgress) {
                    return;
                }

                try {
                    this.syncInProgress = true;
                    this.updateUI('syncing', 'Loading from OneDrive...');

                    await this.ensureValidToken();

                    // Get or create folder
                    const folderId = await this.ensureFolder();

                    // Check if file exists
                    const fileId = await this.getFileId(folderId);

                    if (fileId) {
                        // Download and merge data
                        const data = await this.downloadFile(fileId);
                        
                        if (data && Array.isArray(data)) {
                            // Merge with local data
                            const localAlbums = db.getAllAlbums();
                            const mergedData = this.mergeAlbumData(localAlbums, data);
                            
                            // Update database
                            db.albums = mergedData;
                            db.saveToStorage();

                            this.lastSyncTime = new Date().toISOString();
                            localStorage.setItem('last_sync_time', this.lastSyncTime);

                            this.updateUI('connected', 'Loaded from OneDrive');
                            
                            // Refresh UI if on browse section
                            if (document.getElementById('browse').classList.contains('active')) {
                                loadBrowseSection();
                            }
                        }
                    } else {
                        // No file exists, upload current data
                        await this.syncToOneDrive();
                    }

                    setTimeout(() => this.updateUI(), 2000);

                } catch (error) {
                    console.error('Sync from OneDrive failed:', error);
                    this.updateUI('error', 'Sync failed');
                    setTimeout(() => this.updateUI(), 3000);
                    throw error;
                } finally {
                    this.syncInProgress = false;
                }
            }

            mergeAlbumData(localAlbums, remoteAlbums) {
                const merged = new Map();

                // Add all local albums
                localAlbums.forEach(album => {
                    const key = `${album.albumName}|${album.artist}`;
                    merged.set(key, album);
                });

                // Merge remote albums
                remoteAlbums.forEach(album => {
                    const key = `${album.albumName}|${album.artist}`;
                    const existing = merged.get(key);

                    if (existing) {
                        // Merge: prefer newer data
                        const mergedAlbum = { ...existing };
                        
                        // Use remote score if local doesn't have one
                        if (album.score && !existing.score) {
                            mergedAlbum.score = album.score;
                        }
                        
                        // Use newer date listened
                        if (album.dateListened && (!existing.dateListened || 
                            new Date(album.dateListened) > new Date(existing.dateListened))) {
                            mergedAlbum.dateListened = album.dateListened;
                        }
                        
                        // Merge notes
                        if (album.notes && album.notes !== existing.notes) {
                            mergedAlbum.notes = existing.notes 
                                ? `${existing.notes}\n\n[From OneDrive]: ${album.notes}`
                                : album.notes;
                        }

                        merged.set(key, mergedAlbum);
                    } else {
                        // Add new album from remote
                        merged.set(key, album);
                    }
                });

                return Array.from(merged.values());
            }

            async ensureFolder() {
                try {
                    // Try to get existing folder
                    const response = await fetch(
                        `https://graph.microsoft.com/v1.0/me/drive/root:/${this.folderName}`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );

                    if (response.ok) {
                        const folder = await response.json();
                        return folder.id;
                    }

                    // Create folder if it doesn't exist
                    const createResponse = await fetch(
                        'https://graph.microsoft.com/v1.0/me/drive/root/children',
                        {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`,
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                name: this.folderName,
                                folder: {},
                                '@microsoft.graph.conflictBehavior': 'fail'
                            })
                        }
                    );

                    if (!createResponse.ok) {
                        throw new Error('Failed to create folder');
                    }

                    const folder = await createResponse.json();
                    return folder.id;

                } catch (error) {
                    console.error('Error ensuring folder:', error);
                    throw error;
                }
            }

            async getFileId(folderId) {
                try {
                    const response = await fetch(
                        `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}/children?$filter=name eq '${this.fileName}'`,
                        {
                            headers: {
                                'Authorization': `Bearer ${this.accessToken}`
                            }
                        }
                    );

                    if (!response.ok) {
                        return null;
                    }

                    const data = await response.json();
                    return data.value && data.value.length > 0 ? data.value[0].id : null;

                } catch (error) {
                    console.error('Error getting file ID:', error);
                    return null;
                }
            }

            async createFile(folderId, content) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${folderId}:/${this.fileName}:/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to create file');
                }

                return await response.json();
            }

            async updateFile(fileId, content) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to update file');
                }

                return await response.json();
            }

            async downloadFile(fileId) {
                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/items/${fileId}/content`,
                    {
                        headers: {
                            'Authorization': `Bearer ${this.accessToken}`
                        }
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to download file');
                }

                return await response.json();
            }

            updateUI(status, text) {
                const indicator = document.getElementById('syncIndicator');
                const statusText = document.getElementById('syncText');
                const syncStatus = document.getElementById('syncStatus');

                if (!indicator || !statusText || !syncStatus) return;

                // Remove all status classes
                indicator.classList.remove('connected', 'syncing', 'offline', 'error');
                syncStatus.classList.remove('compact');

                if (status) {
                    indicator.classList.add(status);
                    if (status === 'connected') {
                        // Use compact mode for connected status
                        syncStatus.classList.add('compact');
                        const lastSync = this.lastSyncTime 
                            ? new Date(this.lastSyncTime).toLocaleString()
                            : 'Never';
                        statusText.innerHTML = `
                            <span class="sync-main-text">Synced</span>
                            <span class="sync-details">
                                <span class="sync-sub-text">Last: ${lastSync}</span>
                            </span>
                        `;
                    } else {
                        statusText.textContent = text;
                    }
                } else {
                    // Default status based on connection
                    if (this.isConnected()) {
                        indicator.classList.add('connected');
                        syncStatus.classList.add('compact');
                        const lastSync = this.lastSyncTime 
                            ? new Date(this.lastSyncTime).toLocaleString()
                            : 'Never';
                        statusText.innerHTML = `
                            <span class="sync-main-text">Synced</span>
                            <span class="sync-details">
                                <span class="sync-sub-text">Last: ${lastSync}</span>
                            </span>
                        `;
                    } else {
                        indicator.classList.add('offline');
                        statusText.textContent = 'Offline Mode';
                    }
                }

                this.updateSyncMenu();
            }

            updateSyncMenu() {
                const menuContent = document.getElementById('syncMenuContent');
                if (!menuContent) return;

                if (this.isConnected()) {
                    const lastSync = this.lastSyncTime 
                        ? new Date(this.lastSyncTime).toLocaleString()
                        : 'Never';

                    menuContent.innerHTML = `
                        <div style="padding: 10px; color: #666; font-size: 0.9em;">
                            <strong>OneDrive Connected</strong><br>
                            Last sync: ${lastSync}
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.syncFromOneDrive()">
                            <span>‚¨áÔ∏è</span>
                            <span>Load from OneDrive</span>
                        </div>
                        <div class="sync-menu-item" onclick="syncManager.syncToOneDrive()">
                            <span>‚¨ÜÔ∏è</span>
                            <span>Save to OneDrive</span>
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.disconnect()">
                            <span>üîå</span>
                            <span>Disconnect</span>
                        </div>
                    `;
                } else {
                    menuContent.innerHTML = `
                        <div style="padding: 10px; color: #666; font-size: 0.9em;">
                            <strong>Offline Mode</strong><br>
                            Data stored locally only
                        </div>
                        <div class="sync-menu-divider"></div>
                        <div class="sync-menu-item" onclick="syncManager.connectToOneDrive()">
                            <span>‚òÅÔ∏è</span>
                            <span>Connect to OneDrive</span>
                        </div>
                    `;
                }
            }
        }

        // Initialize database
        const db = new AlbumDatabase();
        
        // Initialize OneDrive sync
        const syncManager = new OneDriveSyncManager();

        // Navigation
        function showSection(sectionId, event) {
            console.log('showSection called with:', sectionId);
            
            // Update active button
            const navButtons = document.querySelectorAll('.nav button');
            console.log('Found nav buttons:', navButtons.length);
            navButtons.forEach(btn => btn.classList.remove('active'));
            if (event && event.target) {
                event.target.classList.add('active');
            }

            // Show section
            const sections = document.querySelectorAll('.section');
            console.log('Found sections:', sections.length);
            sections.forEach(section => section.classList.remove('active'));
            
            const targetSection = document.getElementById(sectionId);
            console.log('Target section:', targetSection);
            if (targetSection) {
                targetSection.classList.add('active');
            }

            // Load section-specific content
            if (sectionId === 'browse') {
                loadBrowseSection();
            } else if (sectionId === 'stats') {
                loadStatsSection();
            }
        }

        // Show/Hide Add Album Form
        function showAddAlbumForm() {
            document.getElementById('addAlbumFormContainer').style.display = 'block';
            document.getElementById('albumNameInline').focus();
        }

        function hideAddAlbumForm() {
            document.getElementById('addAlbumFormContainer').style.display = 'none';
            document.getElementById('addAlbumFormInline').reset();
        }

        function addAlbumInline(event) {
            event.preventDefault();
            
            const albumData = {
                albumName: document.getElementById('albumNameInline').value,
                artist: document.getElementById('artistInline').value,
                year: document.getElementById('yearInline').value,
                artworkUrl: document.getElementById('artworkUrlInline').value,
                genre: document.getElementById('genreInline').value || '',
                score: document.getElementById('scoreInline').value || null,
                reason: 'Manual',
                dateListened: null,
                notes: ''
            };

            if (db.isDuplicate(albumData.albumName, albumData.artist)) {
                alert('This album already exists in your collection!');
                return;
            }

            db.addAlbum(albumData);
            alert('Album added successfully!');
            hideAddAlbumForm();
            loadBrowseSection();
        }

        // Download Import Template
        function downloadImportTemplate() {
            const headers = ['ID', 'Album Name', 'Artist', 'Year', 'Reason', 'Album Artwork URL', 'Discogs URL', 'Artist ID', 'Genre', 'Style', 'Score', 'Date Listened', 'Notes'];
            
            const wb = XLSX.utils.book_new();
            const ws = XLSX.utils.aoa_to_sheet([headers]);
            
            // Set column widths
            ws['!cols'] = [
                { wch: 5 },   // ID
                { wch: 30 },  // Album Name
                { wch: 25 },  // Artist
                { wch: 6 },   // Year
                { wch: 20 },  // Reason
                { wch: 50 },  // Album Artwork URL
                { wch: 50 },  // Discogs URL
                { wch: 15 },  // Artist ID
                { wch: 20 },  // Genre
                { wch: 20 },  // Style
                { wch: 6 },   // Score
                { wch: 12 },  // Date Listened
                { wch: 30 }   // Notes
            ];
            
            XLSX.utils.book_append_sheet(wb, ws, 'Template');
            XLSX.writeFile(wb, 'album_import_template.xlsx');
        }

        // Pick Random Album (from vinyl button)
        function pickRandomAlbum() {
            // Get a random unscored album
            const album = db.getRandomUnscoredAlbum();
            
            if (!album) {
                alert('üéâ All albums have been rated! Add more albums to continue discovering.');
                return;
            }
            
            // Display the album directly in a modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
                animation: fadeIn 0.3s;
            `;
            
            modal.innerHTML = `
                <div style="background: white; border-radius: 20px; padding: 40px; max-width: 600px; width: 90%; box-shadow: 0 20px 60px rgba(0,0,0,0.3); position: relative;">
                    <button onclick="this.closest('[style*=fixed]').remove()" style="position: absolute; top: 20px; right: 20px; background: none; border: none; font-size: 24px; cursor: pointer; color: #999; line-height: 1;">&times;</button>
                    <h2 style="text-align: center; margin-bottom: 30px; color: #667eea;">üéµ Your Random Album</h2>
                    <div style="text-align: center;">
                        ${album.artwork ? `<img src="${album.artwork}" alt="${album.album}" style="max-width: 300px; width: 100%; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.2);">` : ''}
                        <h3 style="margin: 20px 0 10px; color: #333;">${album.album}</h3>
                        <p style="color: #666; font-size: 1.1em; margin-bottom: 10px;">${album.artist}</p>
                        ${album.year ? `<p style="color: #999; margin-bottom: 20px;">${album.year}</p>` : ''}
                        ${album.genre ? `<p style="color: #667eea; margin-bottom: 20px;"><strong>Genre:</strong> ${album.genre}</p>` : ''}
                        <div style="margin-top: 30px;">
                            <button onclick="rateAlbumFromModal(${album.id}, this.closest('[style*=fixed]'))" class="btn btn-success" style="padding: 12px 30px; font-size: 1.1em;">Rate This Album</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Close on background click
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }
        
        function rateAlbumFromModal(albumId, modal) {
            modal.remove();
            showSection('browse');
            setTimeout(() => {
                const albumCard = document.querySelector(`[data-album-id="${albumId}"]`);
                if (albumCard) {
                    albumCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    albumCard.style.animation = 'highlight 2s';
                }
            }, 100);
        }

        // Random Album Selection
        function selectRandomAlbum() {
            const album = db.getRandomUnscoredAlbum();
            const display = document.getElementById('randomAlbumDisplay');

            if (!album) {
                display.innerHTML = `
                    <div class="empty-state" style="color: white;">
                        <h3>üéâ All albums have been rated!</h3>
                        <p>You've completed your collection. Add more albums or browse your ratings.</p>
                    </div>
                `;
                return;
            }

            const genres = db.parseMultiValue(album.genre);
            const styles = db.parseMultiValue(album.style);
            const sources = db.parseMultiValue(album.reason);

            display.innerHTML = `
                <div class="random-album-content">
                    <div>
                        <img src="${album.artworkUrl}" alt="${album.albumName}" class="album-artwork" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22300%22%3E%3Crect fill=%22%23ddd%22 width=%22300%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2220%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    </div>
                    <div class="album-details">
                        <h2>${album.albumName}</h2>
                        <p><strong>Artist:</strong> ${album.artist}</p>
                        <p><strong>Year:</strong> ${album.year}</p>
                        ${genres.length > 0 ? `<p><strong>Genre:</strong> ${genres.join(', ')}</p>` : ''}
                        ${styles.length > 0 ? `<p><strong>Style:</strong> ${styles.join(', ')}</p>` : ''}
                        ${sources.length > 0 ? `<p><strong>Source:</strong> ${sources.join(', ')}</p>` : ''}
                        
                        <div class="rating-form">
                            <h3 style="margin-bottom: 15px;">Rate This Album</h3>
                            <form onsubmit="rateAlbum(event, ${album.id})">
                                <div class="form-group">
                                    <label>Score (0-10) *</label>
                                    <input type="number" id="ratingScore" min="0" max="10" step="0.1" required>
                                </div>
                                <div class="form-group">
                                    <label>Date Listened</label>
                                    <input type="date" id="ratingDate" value="${new Date().toISOString().split('T')[0]}">
                                </div>
                                <div class="form-group">
                                    <label>Notes</label>
                                    <textarea id="ratingNotes" placeholder="Your thoughts..."></textarea>
                                </div>
                                <button type="submit" class="btn btn-success">Submit Rating</button>
                                <button type="button" class="btn btn-secondary" onclick="selectRandomAlbum()" style="margin-left: 10px;">Skip</button>
                            </form>
                        </div>
                    </div>
                </div>
            `;
        }

        function rateAlbum(event, albumId) {
            event.preventDefault();
            
            const score = parseFloat(document.getElementById('ratingScore').value);
            const dateListened = document.getElementById('ratingDate').value;
            const notes = document.getElementById('ratingNotes').value;

            db.updateAlbum(albumId, {
                score,
                dateListened,
                notes
            });

            autoSyncToOneDrive();
            showAlert('success', 'Album rated successfully!');
            selectRandomAlbum();
        }

        // Browse Section
        function loadBrowseSection() {
            // Populate filter dropdowns
            const genres = db.getAllGenres();
            const sources = db.getAllSources();

            const genreSelect = document.getElementById('filterGenre');
            genreSelect.innerHTML = '<option value="">All Genres</option>';
            genres.forEach(genre => {
                genreSelect.innerHTML += `<option value="${genre}">${genre}</option>`;
            });

            const sourceSelect = document.getElementById('filterSource');
            sourceSelect.innerHTML = '<option value="">All Sources</option>';
            sources.forEach(source => {
                sourceSelect.innerHTML += `<option value="${source}">${source}</option>`;
            });

            applyFilters();
            setupSearch();
        }

        function setupSearch() {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            if (!searchInput || !searchResults) {
                console.error('Search elements not found:', { searchInput, searchResults });
                return;
            }
            
            console.log('Search setup complete');

            let searchTimeout;

            // Handle input with debouncing
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                const query = e.target.value.trim();

                if (query.length === 0) {
                    searchResults.classList.remove('active');
                    searchResults.innerHTML = '';
                    return;
                }

                // Debounce search by 300ms
                searchTimeout = setTimeout(() => {
                    performSearch(query);
                }, 300);
            });

            // Close search results when clicking outside
            document.addEventListener('click', (e) => {
                if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
                    searchResults.classList.remove('active');
                }
            });

            // Show results when focusing on input with text
            searchInput.addEventListener('focus', (e) => {
                if (e.target.value.trim().length > 0) {
                    performSearch(e.target.value.trim());
                }
            });
        }

        function performSearch(query) {
            console.log('Performing search for:', query);
            const searchResults = document.getElementById('searchResults');
            const allAlbums = db.getAllAlbums();
            console.log('Total albums:', allAlbums.length);
            if (allAlbums.length > 0) {
                console.log('Sample album:', allAlbums[0]);
                console.log('albumName type:', typeof allAlbums[0].albumName);
                console.log('albumName value:', allAlbums[0].albumName);
            }
            
            // Search in album name and artist name (case insensitive)
            const lowerQuery = query.toLowerCase();
            const matches = allAlbums.filter(album => {
                const albumName = String(album.albumName || '').toLowerCase();
                const artistName = String(album.artist || '').toLowerCase();
                return albumName.includes(lowerQuery) || artistName.includes(lowerQuery);
            });
            console.log('Matches found:', matches.length);

            // Sort matches by relevance (exact matches first, then starts with, then contains)
            matches.sort((a, b) => {
                const aAlbum = String(a.albumName || '').toLowerCase();
                const bAlbum = String(b.albumName || '').toLowerCase();
                const aArtist = String(a.artist || '').toLowerCase();
                const bArtist = String(b.artist || '').toLowerCase();

                // Exact match
                if (aAlbum === lowerQuery || aArtist === lowerQuery) return -1;
                if (bAlbum === lowerQuery || bArtist === lowerQuery) return 1;

                // Starts with
                if (aAlbum.startsWith(lowerQuery) || aArtist.startsWith(lowerQuery)) return -1;
                if (bAlbum.startsWith(lowerQuery) || bArtist.startsWith(lowerQuery)) return 1;

                return 0;
            });

            // Limit to 10 results
            const limitedMatches = matches.slice(0, 10);

            if (limitedMatches.length === 0) {
                searchResults.innerHTML = '<div class="search-no-results">No albums found</div>';
            } else {
                searchResults.innerHTML = limitedMatches.map(album => `
                    <div class="search-result-item" onclick="openAlbumFromSearch(${album.id})">
                        ${album.artworkUrl ? 
                            `<img src="${album.artworkUrl}" alt="${album.albumName}" class="search-result-artwork" onerror="this.style.display='none'">` :
                            '<div class="search-result-artwork"></div>'
                        }
                        <div class="search-result-info">
                            <div class="search-result-album">${album.albumName}</div>
                            <div class="search-result-artist">${album.artist}</div>
                        </div>
                    </div>
                `).join('');
            }

            searchResults.classList.add('active');
        }

        function openAlbumFromSearch(albumId) {
            const searchInput = document.getElementById('searchInput');
            const searchResults = document.getElementById('searchResults');
            
            // Clear search
            searchInput.value = '';
            searchResults.classList.remove('active');
            searchResults.innerHTML = '';
            
            // Open album modal
            showAlbumDetail(albumId);
        }

        function applyFilters() {
            const genreEl = document.getElementById('filterGenre');
            const sourceEl = document.getElementById('filterSource');
            const statusEl = document.getElementById('filterStatus');
            const sortByEl = document.getElementById('sortBy');

            // Check if elements exist
            if (!genreEl || !sourceEl || !statusEl || !sortByEl) {
                console.error('Filter elements not found');
                return;
            }

            const filters = {
                genre: genreEl.value,
                source: sourceEl.value,
                status: statusEl.value
            };

            const sortBy = sortByEl.value;

            let albums = db.filterAlbums(filters);
            albums = db.sortAlbums(albums, sortBy);

            displayAlbums(albums);
        }

        function clearFilters() {
            document.getElementById('filterGenre').value = '';
            document.getElementById('filterSource').value = '';
            document.getElementById('filterStatus').value = '';
            document.getElementById('sortBy').value = 'name-asc';
            applyFilters();
        }

        // Infinite scroll state
        let allFilteredAlbums = [];
        let displayedAlbumsCount = 0;
        const ALBUMS_PER_BATCH = 500;
        let isLoadingMore = false;
        let multiSelectMode = false;
        let selectedAlbumIds = new Set();

        function displayAlbums(albums) {
            const grid = document.getElementById('albumGrid');

            // Store all albums and reset display count
            allFilteredAlbums = albums;
            displayedAlbumsCount = 0;

            if (albums.length === 0) {
                grid.innerHTML = `
                    <div class="empty-state" style="grid-column: 1 / -1;">
                        <h3>No albums found</h3>
                        <p>Try adjusting your filters or add some albums to get started.</p>
                    </div>
                `;
                return;
            }

            // Clear existing content
            grid.innerHTML = '';

            // Load first batch
            loadMoreAlbums();

            // Setup infinite scroll
            setupInfiniteScroll();
        }

        function loadMoreAlbums() {
            if (isLoadingMore) return;
            
            const grid = document.getElementById('albumGrid');
            if (!grid) return;

            isLoadingMore = true;

            // Get next batch
            const nextBatch = allFilteredAlbums.slice(
                displayedAlbumsCount, 
                displayedAlbumsCount + ALBUMS_PER_BATCH
            );

            if (nextBatch.length === 0) {
                isLoadingMore = false;
                return;
            }

            // Create document fragment for better performance
            const fragment = document.createDocumentFragment();

            nextBatch.forEach(album => {
                const scoreClass = album.score >= 8 ? 'score-high' : 
                                 album.score >= 5 ? 'score-medium' : 
                                 album.score ? 'score-low' : 'score-unrated';
                const scoreText = album.score !== null && album.score !== undefined && album.score !== '' 
                    ? `${album.score}/10` 
                    : 'Not Rated';

                const albumCard = document.createElement('div');
                albumCard.className = 'album-card';
                albumCard.dataset.albumId = album.id;
                
                if (multiSelectMode) {
                    albumCard.classList.add('multi-select-mode');
                    if (selectedAlbumIds.has(album.id)) {
                        albumCard.classList.add('selected');
                    }
                    albumCard.onclick = (e) => {
                        e.stopPropagation();
                        toggleAlbumSelection(album.id);
                    };
                } else {
                    albumCard.onclick = () => showAlbumDetail(album.id);
                }
                
                albumCard.innerHTML = `
                    ${multiSelectMode ? `<input type="checkbox" class="album-checkbox" ${selectedAlbumIds.has(album.id) ? 'checked' : ''} onclick="event.stopPropagation(); toggleAlbumSelection(${album.id})">` : ''}
                    <img src="${album.artworkUrl}" alt="${album.albumName}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    <div class="album-card-info">
                        <h3>${album.albumName}</h3>
                        <p>${album.artist}</p>
                        <p>${album.year}</p>
                        <span class="score-badge ${scoreClass}">${scoreText}</span>
                    </div>
                `;
                
                fragment.appendChild(albumCard);
            });

            grid.appendChild(fragment);
            displayedAlbumsCount += nextBatch.length;

            // Add loading indicator if there are more albums
            if (displayedAlbumsCount < allFilteredAlbums.length) {
                let loadingIndicator = document.getElementById('loadingIndicator');
                if (!loadingIndicator) {
                    loadingIndicator = document.createElement('div');
                    loadingIndicator.id = 'loadingIndicator';
                    loadingIndicator.style.cssText = 'grid-column: 1 / -1; text-align: center; padding: 40px; color: #666;';
                    loadingIndicator.innerHTML = '<p>Loading more albums...</p>';
                }
                if (!grid.contains(loadingIndicator)) {
                    grid.appendChild(loadingIndicator);
                }
            } else {
                // Remove loading indicator if we're done
                const loadingIndicator = document.getElementById('loadingIndicator');
                if (loadingIndicator) {
                    loadingIndicator.remove();
                }
            }

            isLoadingMore = false;
        }

        function setupInfiniteScroll() {
            // Remove existing scroll listener if any
            if (window.infiniteScrollHandler) {
                window.removeEventListener('scroll', window.infiniteScrollHandler);
            }

            // Create new scroll handler
            window.infiniteScrollHandler = () => {
                if (displayedAlbumsCount >= allFilteredAlbums.length) return;
                if (isLoadingMore) return;

                const scrollPosition = window.innerHeight + window.scrollY;
                const threshold = document.documentElement.scrollHeight - 1000; // Load 1000px before bottom

                if (scrollPosition >= threshold) {
                    loadMoreAlbums();
                }
            };

            window.addEventListener('scroll', window.infiniteScrollHandler);
        }

        function toggleMultiSelectMode() {
            multiSelectMode = !multiSelectMode;
            selectedAlbumIds.clear();
            
            const controlsDiv = document.getElementById('multiSelectControls');
            const modeBtn = document.getElementById('multiSelectModeBtn');
            
            if (multiSelectMode) {
                controlsDiv.style.display = 'block';
                modeBtn.textContent = '‚ùå Exit Multi-Select';
            } else {
                controlsDiv.style.display = 'none';
                modeBtn.textContent = 'üìã Multi-Select';
            }
            
            updateSelectedCount();
            applyFilters(); // Refresh display
        }

        function toggleAlbumSelection(albumId) {
            if (selectedAlbumIds.has(albumId)) {
                selectedAlbumIds.delete(albumId);
            } else {
                selectedAlbumIds.add(albumId);
            }
            
            // Update the card's visual state
            const card = document.querySelector(`[data-album-id="${albumId}"]`);
            if (card) {
                card.classList.toggle('selected');
                const checkbox = card.querySelector('.album-checkbox');
                if (checkbox) {
                    checkbox.checked = selectedAlbumIds.has(albumId);
                }
            }
            
            updateSelectedCount();
        }

        function toggleSelectAll() {
            const allCurrentIds = allFilteredAlbums.map(a => a.id);
            
            if (selectedAlbumIds.size === allCurrentIds.length) {
                // Deselect all
                selectedAlbumIds.clear();
                document.getElementById('selectAllText').textContent = 'Select All';
            } else {
                // Select all filtered albums
                allCurrentIds.forEach(id => selectedAlbumIds.add(id));
                document.getElementById('selectAllText').textContent = 'Deselect All';
            }
            
            updateSelectedCount();
            applyFilters(); // Refresh display
        }

        function updateSelectedCount() {
            const count = selectedAlbumIds.size;
            document.getElementById('selectedCount').textContent = count;
            document.getElementById('deleteSelectedBtn').disabled = count === 0;
            
            // Update Select All button text
            const allCurrentIds = allFilteredAlbums.map(a => a.id);
            if (selectedAlbumIds.size === allCurrentIds.length && allCurrentIds.length > 0) {
                document.getElementById('selectAllText').textContent = 'Deselect All';
            } else {
                document.getElementById('selectAllText').textContent = 'Select All';
            }
        }

        function deleteSelectedAlbums() {
            const count = selectedAlbumIds.size;
            if (count === 0) return;
            
            const confirmMsg = `Are you sure you want to delete ${count} album${count > 1 ? 's' : ''}? This action cannot be undone.`;
            
            if (confirm(confirmMsg)) {
                // Delete each selected album
                selectedAlbumIds.forEach(id => {
                    db.deleteAlbum(id);
                });
                
                autoSyncToOneDrive();
                showAlert('success', `Successfully deleted ${count} album${count > 1 ? 's' : ''}!`);
                
                // Clear selection and exit multi-select mode
                selectedAlbumIds.clear();
                multiSelectMode = false;
                document.getElementById('multiSelectControls').style.display = 'none';
                document.getElementById('multiSelectModeBtn').textContent = 'üìã Multi-Select';
                
                // Refresh the display
                applyFilters();
            }
        }

        function showAlbumDetail(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            const genres = db.parseMultiValue(album.genre);
            const styles = db.parseMultiValue(album.style);
            const sources = db.parseMultiValue(album.reason);

            const modalContent = document.getElementById('albumModalContent');
            modalContent.innerHTML = `
                <div style="display: grid; grid-template-columns: 300px 1fr; gap: 30px; margin-top: 40px;">
                    <div>
                        <img src="${album.artworkUrl}" alt="${album.albumName}" style="width: 100%; border-radius: 12px;" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22300%22 height=%22300%22%3E%3Crect fill=%22%23ddd%22 width=%22300%22 height=%22300%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2220%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                    </div>
                    <div>
                        <h2 style="margin-bottom: 20px;">${album.albumName}</h2>
                        <p style="margin-bottom: 10px;"><strong>Artist:</strong> ${album.artist}</p>
                        <p style="margin-bottom: 10px;"><strong>Year:</strong> ${album.year}</p>
                        ${album.artistId ? `<p style="margin-bottom: 10px;"><strong>Artist ID:</strong> ${album.artistId}</p>` : ''}
                        ${album.discogsUrl ? `<p style="margin-bottom: 10px;"><a href="${album.discogsUrl}" target="_blank" style="color: #667eea; text-decoration: none;">View on Discogs</a></p>` : ''}
                        
                        ${genres.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Genres:</strong>
                                <div class="tags-container">
                                    ${genres.map(g => `<span class="tag">${g}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${styles.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Styles:</strong>
                                <div class="tags-container">
                                    ${styles.map(s => `<span class="tag">${s}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${sources.length > 0 ? `
                            <div style="margin: 15px 0;">
                                <strong>Source Lists:</strong>
                                <div class="tags-container">
                                    ${sources.map(s => `<span class="tag">${s}</span>`).join('')}
                                </div>
                            </div>
                        ` : ''}
                        
                        ${album.score !== null && album.score !== undefined && album.score !== '' ? `
                            <p style="margin: 15px 0;"><strong>Score:</strong> <span style="font-size: 1.5em; color: #667eea;">${album.score}/10</span></p>
                        ` : '<p style="margin: 15px 0; color: #6c757d;">Not yet rated</p>'}
                        
                        ${album.dateListened ? `<p style="margin-bottom: 10px;"><strong>Date Listened:</strong> ${new Date(album.dateListened).toLocaleDateString()}</p>` : ''}
                        
                        ${album.notes ? `
                            <div style="margin-top: 20px;">
                                <strong>Notes:</strong>
                                <p style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 8px;">${album.notes}</p>
                            </div>
                        ` : ''}
                        
                        <div style="margin-top: 30px;">
                            <button class="btn" onclick="editAlbum(${album.id})">Edit Album</button>
                            <button class="btn btn-danger" onclick="deleteAlbumConfirm(${album.id})" style="margin-left: 10px;">Delete</button>
                        </div>
                    </div>
                </div>
            `;

            document.getElementById('albumModal').classList.add('active');
        }

        function closeModal() {
            document.getElementById('albumModal').classList.remove('active');
        }

        let previousSection = 'browse'; // Track which section we were in before editing

        function editAlbum(albumId) {
            const album = db.getAlbum(albumId);
            if (!album) return;

            // Remember which section we're currently in
            const sections = ['browse', 'stats', 'import', 'add'];
            for (const section of sections) {
                if (document.getElementById(section).classList.contains('active')) {
                    previousSection = section;
                    break;
                }
            }

            closeModal();
            showSection('add');
            
            // Populate form
            document.getElementById('albumName').value = album.albumName;
            document.getElementById('artist').value = album.artist;
            document.getElementById('artistId').value = album.artistId || '';
            document.getElementById('year').value = album.year;
            document.getElementById('artworkUrl').value = album.artworkUrl;
            document.getElementById('discogsUrl').value = album.discogsUrl || '';
            document.getElementById('genre').value = album.genre || '';
            document.getElementById('style').value = album.style || '';
            document.getElementById('reason').value = album.reason || '';
            document.getElementById('score').value = album.score || '';
            document.getElementById('dateListened').value = album.dateListened || '';
            document.getElementById('notes').value = album.notes || '';

            // Change form to edit mode
            const form = document.getElementById('addAlbumForm');
            form.onsubmit = (e) => updateAlbum(e, albumId);
            document.querySelector('#add h2').textContent = 'Edit Album';
            form.querySelector('button[type="submit"]').textContent = 'Update Album';
        }

        function updateAlbum(event, albumId) {
            event.preventDefault();

            const updates = {
                albumName: document.getElementById('albumName').value,
                artist: document.getElementById('artist').value,
                artistId: document.getElementById('artistId').value,
                year: parseInt(document.getElementById('year').value),
                artworkUrl: document.getElementById('artworkUrl').value,
                discogsUrl: document.getElementById('discogsUrl').value,
                genre: document.getElementById('genre').value,
                style: document.getElementById('style').value,
                reason: document.getElementById('reason').value || 'Manual',
                score: document.getElementById('score').value ? parseFloat(document.getElementById('score').value) : null,
                dateListened: document.getElementById('dateListened').value || null,
                notes: document.getElementById('notes').value
            };

            db.updateAlbum(albumId, updates);
            autoSyncToOneDrive();
            showAlert('success', 'Album updated successfully!');
            
            // Reset form
            document.getElementById('addAlbumForm').reset();
            document.getElementById('addAlbumForm').onsubmit = addAlbum;
            document.querySelector('#add h2').textContent = 'Add New Album';
            document.querySelector('#add button[type="submit"]').textContent = 'Add Album';
            document.getElementById('reason').value = 'Manual';
            
            // Return to the section we were in before editing
            showSection(previousSection);
            if (previousSection === 'browse') {
                loadBrowseSection();
            }
        }

        function deleteAlbumConfirm(albumId) {
            if (confirm('Are you sure you want to delete this album? This action cannot be undone.')) {
                db.deleteAlbum(albumId);
                autoSyncToOneDrive();
                closeModal();
                showAlert('success', 'Album deleted successfully!');
                if (document.getElementById('browse').classList.contains('active')) {
                    loadBrowseSection();
                }
            }
        }

        // Fetch album data from Discogs
        async function fetchFromDiscogs() {
            const discogsUrlInput = document.getElementById('discogsUrl');
            const statusEl = document.getElementById('discogsStatus');
            const url = discogsUrlInput.value.trim();

            if (!url) {
                statusEl.textContent = 'Please enter a Discogs URL first';
                statusEl.style.color = '#e74c3c';
                return;
            }

            // Extract master or release ID from URL
            const masterMatch = url.match(/discogs\.com\/master\/(\d+)/);
            const releaseMatch = url.match(/discogs\.com\/release\/(\d+)/);
            
            if (!masterMatch && !releaseMatch) {
                statusEl.textContent = 'Invalid Discogs URL format';
                statusEl.style.color = '#e74c3c';
                return;
            }

            const isMaster = !!masterMatch;
            const id = isMaster ? masterMatch[1] : releaseMatch[1];
            const apiUrl = isMaster 
                ? `https://api.discogs.com/masters/${id}`
                : `https://api.discogs.com/releases/${id}`;

            statusEl.textContent = 'Fetching data from Discogs...';
            statusEl.style.color = '#3498db';

            try {
                // Use CORS proxy to avoid CORS issues
                const proxyUrl = 'https://corsproxy.io/?';
                const response = await fetch(proxyUrl + encodeURIComponent(apiUrl));

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                let data = await response.json();
                
                // If it's a master release and images are empty, fetch the main release instead
                if (isMaster && data.main_release_url && (!data.images || !data.images[0]?.uri)) {
                    console.log('Master images empty, fetching main release...');
                    const mainReleaseResponse = await fetch(proxyUrl + encodeURIComponent(data.main_release_url));
                    if (mainReleaseResponse.ok) {
                        data = await mainReleaseResponse.json();
                        console.log('Main release data:', JSON.stringify(data, null, 2));
                    }
                } else {
                    console.log('Full Discogs response:', JSON.stringify(data, null, 2));
                }

                // Populate form fields
                document.getElementById('albumName').value = data.title || '';
                document.getElementById('artist').value = data.artists?.[0]?.name || '';
                document.getElementById('artistId').value = data.artists?.[0]?.id || '';
                document.getElementById('year').value = data.year || '';
                
                // Get the best quality image
                if (data.images && data.images.length > 0) {
                    // Try to get the highest resolution image
                    // Discogs provides: uri, uri150, resource_url
                    const image = data.images[0];
                    const artworkUrl = image.resource_url || image.uri || image.uri150 || '';
                    document.getElementById('artworkUrl').value = artworkUrl;
                    console.log('Image data:', image);
                    console.log('Using artwork URL:', artworkUrl);
                }

                // Join genres with semicolons
                if (data.genres && data.genres.length > 0) {
                    document.getElementById('genre').value = data.genres.join('; ');
                }

                // Join styles with semicolons
                if (data.styles && data.styles.length > 0) {
                    document.getElementById('style').value = data.styles.join('; ');
                }

                statusEl.textContent = '‚úì Successfully fetched album data!';
                statusEl.style.color = '#27ae60';

                // Clear status after 3 seconds
                setTimeout(() => {
                    statusEl.textContent = '';
                }, 3000);

            } catch (error) {
                console.error('Error fetching from Discogs:', error);
                statusEl.textContent = '‚úó Error fetching data. Please check the URL and try again.';
                statusEl.style.color = '#e74c3c';
            }
        }

        // Add Album
        function addAlbum(event) {
            event.preventDefault();

            const album = {
                albumName: document.getElementById('albumName').value,
                artist: document.getElementById('artist').value,
                artistId: document.getElementById('artistId').value,
                year: parseInt(document.getElementById('year').value),
                artworkUrl: document.getElementById('artworkUrl').value,
                discogsUrl: document.getElementById('discogsUrl').value,
                genre: document.getElementById('genre').value,
                style: document.getElementById('style').value,
                reason: document.getElementById('reason').value || 'Manual',
                score: document.getElementById('score').value ? parseFloat(document.getElementById('score').value) : null,
                dateListened: document.getElementById('dateListened').value || null,
                notes: document.getElementById('notes').value
            };

            if (db.isDuplicate(album.albumName, album.artist)) {
                showAlert('error', 'This album already exists in your collection!');
                return;
            }

            db.addAlbum(album);
            autoSyncToOneDrive();
            showAlert('success', 'Album added successfully!');
            document.getElementById('addAlbumForm').reset();
            document.getElementById('reason').value = 'Manual';
            
            // Return to Browse Albums section
            showSection('browse');
        }

        // Import Excel
        async function importExcel(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Show loading indicator
            document.getElementById('importStatus').innerHTML = `
                <div class="alert alert-info" style="margin-top: 20px;">
                    <strong>Processing...</strong><br>
                    Reading file and preparing data...
                </div>
            `;

            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet);

                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-info" style="margin-top: 20px;">
                            <strong>Processing...</strong><br>
                            Importing ${jsonData.length} albums...
                        </div>
                    `;

                    // Allow UI to update
                    await new Promise(resolve => setTimeout(resolve, 100));

                    const albums = jsonData.map(row => {
                        // Helper to get value, allowing falsy values like 0 but not null/undefined
                        const getValue = (primary, secondary, defaultVal = '') => {
                            const val = primary !== undefined && primary !== null ? primary : secondary;
                            return val !== undefined && val !== null ? val : defaultVal;
                        };

                        // Helper to parse Excel date (which can be a serial number or string)
                        const parseExcelDate = (dateValue) => {
                            if (!dateValue) return null;
                            
                            // If it's already a string in YYYY-MM-DD format, return it
                            if (typeof dateValue === 'string' && dateValue.match(/^\d{4}-\d{2}-\d{2}$/)) {
                                return dateValue;
                            }
                            
                            // If it's a string in other formats, try to parse it
                            if (typeof dateValue === 'string') {
                                const parsed = new Date(dateValue);
                                if (!isNaN(parsed.getTime())) {
                                    return parsed.toISOString().split('T')[0];
                                }
                            }
                            
                            // If it's an Excel serial number (number of days since 1900-01-01)
                            if (typeof dateValue === 'number') {
                                // Excel date serial number conversion
                                const excelEpoch = new Date(1899, 11, 30); // Excel's epoch (Dec 30, 1899)
                                const date = new Date(excelEpoch.getTime() + dateValue * 86400000);
                                return date.toISOString().split('T')[0];
                            }
                            
                            return null;
                        };

                        return {
                            albumName: getValue(row['Album Name'], getValue(row['Album'], row['albumName'], ''), ''),
                            artist: getValue(row['Artist'], row['artist'], ''),
                            artistId: getValue(row['Artist ID'], row['artistId'], ''),
                            year: parseInt(row['Year'] || row['year']) || new Date().getFullYear(),
                            artworkUrl: getValue(row['Album Artwork URL'], getValue(row['Album Artwork'], row['artworkUrl'], ''), ''),
                            discogsUrl: getValue(row['Discogs URL'], getValue(row['Discogs'], row['discogsUrl'], ''), ''),
                            genre: getValue(row['Genre'], row['genre'], ''),
                            style: getValue(row['Style'], row['style'], ''),
                            reason: getValue(row['Reason'], row['reason'], 'Manual'),
                            score: row['Score'] || row['score'] ? parseFloat(row['Score'] || row['score']) : null,
                            dateListened: parseExcelDate(row['Date Listened'] || row['Listened on'] || row['dateListened']),
                            notes: getValue(row['Notes'], row['notes'], '')
                        };
                    });

                    const result = await db.importAlbumsAsync(albums, (progress) => {
                        document.getElementById('importStatus').innerHTML = `
                            <div class="alert alert-info" style="margin-top: 20px;">
                                <strong>Processing...</strong><br>
                                Progress: ${progress.processed} / ${progress.total} albums<br>
                                Added: ${progress.added}, Updated: ${progress.updated}, Skipped: ${progress.skipped}
                            </div>
                        `;
                    });
                    
                    autoSyncToOneDrive();
                    
                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-success" style="margin-top: 20px;">
                            <strong>Import Complete!</strong><br>
                            Added: ${result.added} albums<br>
                            Updated: ${result.updated} albums<br>
                            Skipped (no changes): ${result.skipped} albums
                        </div>
                    `;

                    // Reset file input
                    event.target.value = '';

                } catch (error) {
                    document.getElementById('importStatus').innerHTML = `
                        <div class="alert alert-error" style="margin-top: 20px;">
                            <strong>Import Failed!</strong><br>
                            ${error.message}
                        </div>
                    `;
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // Export Data
        function exportData() {
            const albums = db.getAllAlbums();
            
            if (albums.length === 0) {
                showAlert('error', 'No albums to export!');
                return;
            }

            // Prepare data for export
            const exportData = albums.map(album => ({
                'ID': album.id,
                'Album Name': album.albumName,
                'Artist': album.artist,
                'Artist ID': album.artistId || '',
                'Year': album.year,
                'Album Artwork URL': album.artworkUrl,
                'Discogs URL': album.discogsUrl || '',
                'Genre': album.genre || '',
                'Style': album.style || '',
                'Reason': album.reason || '',
                'Score': album.score !== null && album.score !== undefined && album.score !== '' ? album.score : '',
                'Date Listened': album.dateListened || '',
                'Notes': album.notes || ''
            }));

            // Create worksheet
            const ws = XLSX.utils.json_to_sheet(exportData);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Albums');

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().split('T')[0];
            const filename = `album-tracker-${timestamp}.xlsx`;

            // Download
            XLSX.writeFile(wb, filename);
            showAlert('success', 'Data exported successfully!');
        }

        // Statistics
        function loadStatsSection() {
            const statsContent = document.getElementById('statsContent');
            
            const albums = db.getAllAlbums();
            if (albums.length === 0) {
                statsContent.innerHTML = `
                    <div class="empty-state">
                        <h3>No data available</h3>
                        <p>Add some albums to see statistics.</p>
                    </div>
                `;
                return;
            }

            const monthlyStats = db.getMonthlyStats();
            const artistAvg = db.getAverageScoreByArtist();
            const genreAvg = db.getAverageScoreByGenre();
            const genreCounts = db.getGenreCounts();
            const sourceStats = db.getSourceListStats();

            let html = '<div class="stats-grid">';

            // Overall Stats
            const totalAlbums = albums.length;
            const listenedAlbums = albums.filter(a => a.dateListened).length;
            const ratedAlbums = albums.filter(a => a.score !== null && a.score !== undefined && a.score !== '').length;
            const listenedPercentage = totalAlbums > 0 ? ((listenedAlbums / totalAlbums) * 100).toFixed(1) : '0';
            const avgScore = ratedAlbums > 0 
                ? (albums.filter(a => a.score).reduce((sum, a) => sum + parseFloat(a.score), 0) / ratedAlbums).toFixed(2)
                : 'N/A';

            html += `
                <div class="stat-card">
                    <h3>üìä Overall Statistics</h3>
                    <div class="stat-item">
                        <span>Total Albums</span>
                        <strong>${totalAlbums}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Albums Listened</span>
                        <strong>${listenedAlbums} (${listenedPercentage}%)</strong>
                    </div>
                    <div class="stat-item">
                        <span>Albums Rated</span>
                        <strong>${ratedAlbums}</strong>
                    </div>
                    <div class="stat-item">
                        <span>Average Score</span>
                        <strong>${avgScore}</strong>
                    </div>
                </div>
            `;

            // Monthly Listening Stats
            const currentYear = new Date().getFullYear();
            const availableYears = [...new Set(Object.keys(monthlyStats).map(m => m.split(' ')[1]))].sort().reverse();
            const selectedYear = window.monthlyStatsYear || currentYear.toString();
            
            html += `
                <div class="stat-card">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0;">üìÖ Monthly Listening</h3>
                        ${availableYears.length > 0 ? `
                            <select id="monthlyYearSelector" onchange="filterMonthlyStatsByYear(this.value)" style="padding: 5px 10px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer;">
                                ${availableYears.map(year => `<option value="${year}" ${year === selectedYear ? 'selected' : ''}>${year}</option>`).join('')}
                            </select>
                        ` : ''}
                    </div>
                    ${Object.keys(monthlyStats).length > 0 ? 
                        Object.entries(monthlyStats)
                            .filter(([month]) => month.endsWith(selectedYear))
                            .sort((a, b) => {
                                const monthOrder = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                                const aMonth = a[0].split(' ')[0];
                                const bMonth = b[0].split(' ')[0];
                                return monthOrder.indexOf(bMonth) - monthOrder.indexOf(aMonth);
                            })
                            .map(([month, data]) => {
                                const avgScore = data.scores.length > 0 
                                    ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2)
                                    : 'N/A';
                                return `
                                    <div class="stat-item" style="cursor: pointer;" onclick="showMonthDrilldown('${month}')">
                                        <span>${month}</span>
                                        <strong>${data.count} albums (Avg: ${avgScore})</strong>
                                    </div>
                                `;
                            }).join('')
                        : '<p style="color: #6c757d;">No listening data yet</p>'
                    }
                </div>
            `;
            
            // Yearly Stats
            const yearlyStats = db.getYearlyStats();
            if (Object.keys(yearlyStats).length > 0) {
                html += `
                    <div class="stat-card">
                        <h3>üìÜ Yearly Listening</h3>
                        ${Object.entries(yearlyStats)
                            .sort((a, b) => b[0].localeCompare(a[0]))
                            .map(([year, data]) => {
                                const avgScore = data.scores.length > 0 
                                    ? (data.scores.reduce((a, b) => a + b, 0) / data.scores.length).toFixed(2)
                                    : 'N/A';
                                return `
                                    <div class="stat-item" style="cursor: pointer;" onclick="showYearDrilldown('${year}')">
                                        <span>${year}</span>
                                        <strong>${data.count} albums (Avg: ${avgScore})</strong>
                                    </div>
                                `;
                            }).join('')
                        }
                    </div>
                `;
            }

            html += '</div>';

            // Top Artists by Average Score
            if (Object.keys(artistAvg).length > 0) {
                html += `
                    <div class="chart">
                        <h3>üé§ Top Artists by Average Score</h3>
                        ${Object.entries(artistAvg).slice(0, 10).map(([artist, data]) => `
                            <div class="chart-bar" style="cursor: pointer;" onclick="showArtistDrilldown('${artist.replace(/'/g, "\\'")}')">
                                <div class="chart-label">${artist}</div>
                                <div class="chart-bar-fill" style="width: ${(data.average / 10) * 100}%;">
                                    ${data.average.toFixed(2)} (${data.count} album${data.count !== 1 ? 's' : ''})
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Top Genres by Album Count
            if (Object.keys(genreCounts).length > 0) {
                const maxCount = Math.max(...Object.values(genreCounts));
                html += `
                    <div class="chart">
                        <h3>üé∏ Top Genres by Album Count</h3>
                        ${Object.entries(genreCounts).slice(0, 15).map(([genre, count]) => `
                            <div class="chart-bar" style="cursor: pointer;" onclick="showGenreDrilldown('${genre.replace(/'/g, "\\'")}')">
                                <div class="chart-label" style="background: rgba(255,255,255,0.9); padding: 2px 8px; border-radius: 4px; color: #333; font-weight: 600; margin-right: 10px; white-space: nowrap;">${genre}</div>
                                <div class="chart-bar-fill" style="width: ${(count / maxCount) * 100}%; background: linear-gradient(90deg, #667eea 0%, #764ba2 100%); color: white; padding: 8px 12px; border-radius: 4px; font-weight: 600; text-align: right;">
                                    ${count} albums
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Top Genres by Average Score
            if (Object.keys(genreAvg).length > 0) {
                html += `
                    <div class="chart">
                        <h3>üé∏ Top Genres by Average Score</h3>
                        ${Object.entries(genreAvg).slice(0, 10).map(([genre, score]) => `
                            <div class="chart-bar" style="cursor: pointer;" onclick="showGenreDrilldown('${genre.replace(/'/g, "\\'")}')">
                                <div class="chart-label" style="background: rgba(255,255,255,0.9); padding: 2px 8px; border-radius: 4px; color: #333; font-weight: 600; margin-right: 10px; white-space: nowrap;">${genre}</div>
                                <div class="chart-bar-fill" style="width: ${(score / 10) * 100}%; background: linear-gradient(90deg, #28a745 0%, #20c997 100%); color: white; padding: 8px 12px; border-radius: 4px; font-weight: 600; text-align: right;">
                                    ${score.toFixed(2)}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `;
            }

            // Highest and Lowest Scoring Albums (Side by Side with Filter)
            html += `
                <div style="margin-top: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0;">üèÜ Top & Bottom Albums</h3>
                        <select id="scoreFilterSelect" onchange="updateScoreFilter()" style="padding: 8px 15px; border-radius: 6px; border: 1px solid #ddd; background: white; cursor: pointer; font-size: 14px;">
                            <option value="all-time">All Time</option>
                            <option value="this-month">This Month</option>
                            <option value="previous-month">Previous Month</option>
                            <option value="last-year">Last Year</option>
                            <option value="select-month">Select Month...</option>
                            <option value="select-year">Select Year...</option>
                        </select>
                    </div>
                    <div id="scoreFilteredAlbums" style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                        <!-- Will be populated by updateScoreFilter() -->
                    </div>
                </div>
            `;

            // Source List Statistics (Moved to bottom)
            if (Object.keys(sourceStats).length > 0) {
                html += `
                    <div class="chart" style="margin-top: 30px;">
                        <h3>üìö Source List Statistics</h3>
                        <div class="stats-grid">
                            ${Object.entries(sourceStats).map(([source, stats]) => `
                                <div class="stat-card" style="cursor: pointer;" onclick="showSourceDrilldown('${source.replace(/'/g, "\\'")}')">
                                    <h4 style="font-size: 1em; margin-bottom: 10px;">${source}</h4>
                                    <div class="stat-item">
                                        <span>Total Albums</span>
                                        <strong>${stats.total}</strong>
                                    </div>
                                    <div class="stat-item">
                                        <span>Listened</span>
                                        <strong>${stats.listened}</strong>
                                    </div>
                                    <div class="stat-item">
                                        <span>Average Score</span>
                                        <strong>${stats.avgScore ? stats.avgScore.toFixed(2) : 'N/A'}</strong>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }

            statsContent.innerHTML = html;
            
            // Initialize score filter
            updateScoreFilter();
        }

        // Update score filter for highest/lowest albums
        function updateScoreFilter() {
            const filterValue = document.getElementById('scoreFilterSelect')?.value || 'all-time';
            const albums = db.getAllAlbums();
            let filteredAlbums = albums;

            // Apply date filter
            const now = new Date();
            if (filterValue === 'this-month') {
                const thisMonth = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(thisMonth));
            } else if (filterValue === 'previous-month') {
                const prevDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                const prevMonth = `${prevDate.getFullYear()}-${String(prevDate.getMonth() + 1).padStart(2, '0')}`;
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(prevMonth));
            } else if (filterValue === 'last-year') {
                const lastYear = (now.getFullYear() - 1).toString();
                filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(lastYear));
            } else if (filterValue === 'select-month') {
                // Get all unique months
                const months = [...new Set(albums.filter(a => a.dateListened).map(a => a.dateListened.substring(0, 7)))].sort().reverse();
                if (months.length > 0) {
                    const selected = prompt('Select month (format: YYYY-MM):\n\n' + months.map((m, i) => `${i + 1}. ${new Date(m + '-01').toLocaleDateString('en-US', { month: 'short', year: '2-digit' })}`).join('\n'));
                    if (selected) {
                        const index = parseInt(selected) - 1;
                        if (index >= 0 && index < months.length) {
                            filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(months[index]));
                        }
                    }
                }
            } else if (filterValue === 'select-year') {
                // Get all unique years
                const years = [...new Set(albums.filter(a => a.dateListened).map(a => a.dateListened.substring(0, 4)))].sort().reverse();
                if (years.length > 0) {
                    const selected = prompt('Select year:\n\n' + years.map((y, i) => `${i + 1}. ${y}`).join('\n'));
                    if (selected) {
                        const index = parseInt(selected) - 1;
                        if (index >= 0 && index < years.length) {
                            filteredAlbums = albums.filter(a => a.dateListened && a.dateListened.startsWith(years[index]));
                        }
                    }
                }
            }

            const highScoring = filteredAlbums
                .filter(a => a.score >= 8)
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);

            const lowScoring = filteredAlbums
                .filter(a => a.score && a.score <= 4)
                .sort((a, b) => a.score - b.score)
                .slice(0, 10);

            const container = document.getElementById('scoreFilteredAlbums');
            if (!container) return;

            container.innerHTML = `
                <div class="chart" style="margin: 0;">
                    <h4 style="color: #28a745;">‚≠ê Highest Scoring Albums (‚â•8)</h4>
                    ${highScoring.length > 0 ? highScoring.map(album => `
                        <div class="stat-item" style="cursor: pointer;" onclick="showAlbumDetail(${album.id})">
                            <span>${album.albumName} - ${album.artist}</span>
                            <strong style="color: #28a745;">${album.score}/10</strong>
                        </div>
                    `).join('') : '<p style="color: #999; padding: 20px; text-align: center;">No albums found</p>'}
                </div>
                <div class="chart" style="margin: 0;">
                    <h4 style="color: #dc3545;">üìâ Lowest Scoring Albums (‚â§4)</h4>
                    ${lowScoring.length > 0 ? lowScoring.map(album => `
                        <div class="stat-item" style="cursor: pointer;" onclick="showAlbumDetail(${album.id})">
                            <span>${album.albumName} - ${album.artist}</span>
                            <strong style="color: #dc3545;">${album.score}/10</strong>
                        </div>
                    `).join('') : '<p style="color: #999; padding: 20px; text-align: center;">No albums found</p>'}
                </div>
            `;
        }

        // Drilldown functions
        function showArtistDrilldown(artist) {
            const albums = db.getAllAlbums().filter(a => a.artist === artist);
            showDrilldownModal(`Albums by ${artist}`, albums);
        }

        function showGenreDrilldown(genre) {
            const albums = db.getAllAlbums().filter(a => {
                const genres = db.parseMultiValue(a.genre);
                return genres.includes(genre);
            });
            showDrilldownModal(`Albums in ${genre}`, albums);
        }

        function showSourceDrilldown(source) {
            const albums = db.getAllAlbums().filter(a => {
                const sources = db.parseMultiValue(a.reason);
                return sources.includes(source);
            });
            showDrilldownModal(`Albums from ${source}`, albums);
        }

        function filterMonthlyStatsByYear(year) {
            window.monthlyStatsYear = year;
            loadStatsSection();
        }

        function showMonthDrilldown(month) {
            const albums = db.getAllAlbums().filter(a => {
                if (!a.dateListened) return false;
                const date = new Date(a.dateListened);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                return key === month;
            });
            showDrilldownModal(`Albums listened in ${month}`, albums);
        }

        function showYearDrilldown(year) {
            const albums = db.getAllAlbums().filter(a => {
                if (!a.dateListened) return false;
                const date = new Date(a.dateListened);
                return String(date.getFullYear()) === year;
            });
            showDrilldownModal(`Albums listened in ${year}`, albums);
        }

        function showDrilldownModal(title, albums) {
            const modalContent = document.getElementById('albumModalContent');
            
            // Store albums for re-sorting
            window.drilldownAlbums = albums;
            window.drilldownTitle = title;
            
            // Default sort by score
            renderDrilldownAlbums('score');
        }

        function renderDrilldownAlbums(sortBy) {
            const modalContent = document.getElementById('albumModalContent');
            const albums = [...window.drilldownAlbums]; // Clone array
            const title = window.drilldownTitle;
            
            // Sort albums based on selection
            if (sortBy === 'score') {
                albums.sort((a, b) => {
                    if (a.score && b.score) return b.score - a.score;
                    if (a.score) return -1;
                    if (b.score) return 1;
                    return String(a.albumName).localeCompare(String(b.albumName));
                });
            } else if (sortBy === 'date') {
                albums.sort((a, b) => {
                    if (!a.dateListened && !b.dateListened) return 0;
                    if (!a.dateListened) return 1;
                    if (!b.dateListened) return -1;
                    return new Date(b.dateListened) - new Date(a.dateListened);
                });
            }

            modalContent.innerHTML = `
                <div style="margin-top: 40px;">
                    <h2 style="margin-bottom: 20px;">${title}</h2>
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <p style="color: #6c757d;">Total: ${albums.length} albums</p>
                        <div>
                            <label style="font-size: 0.9em; color: #666; margin-right: 8px;">Sort by:</label>
                            <select id="drilldownSort" onchange="renderDrilldownAlbums(this.value)" style="padding: 5px 10px; border-radius: 4px; border: 1px solid #ddd; background: white; cursor: pointer;">
                                <option value="score" ${sortBy === 'score' ? 'selected' : ''}>Score (Highest First)</option>
                                <option value="date" ${sortBy === 'date' ? 'selected' : ''}>Date Listened (Newest First)</option>
                            </select>
                        </div>
                    </div>
                    <div class="album-grid">
                        ${albums.map(album => `
                            <div class="album-card" onclick="showAlbumDetail(${album.id})">
                                <img src="${album.artworkUrl}" alt="${album.albumName}" onerror="this.src='data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 width=%22200%22 height=%22200%22%3E%3Crect fill=%22%23ddd%22 width=%22200%22 height=%22200%22/%3E%3Ctext x=%2250%25%22 y=%2250%25%22 text-anchor=%22middle%22 dy=%22.3em%22 fill=%22%23999%22 font-size=%2216%22%3ENo Image%3C/text%3E%3C/svg%3E'">
                                <div class="album-card-info">
                                    <h3>${album.albumName}</h3>
                                    <p>${album.artist}</p>
                                    <p>${album.year}</p>
                                    ${album.score !== null && album.score !== undefined && album.score !== '' ? 
                                        `<span class="score-badge ${
                                            album.score >= 8 ? 'score-high' : 
                                            album.score >= 6 ? 'score-medium' : 
                                            album.score >= 4 ? 'score-low' : 'score-low'
                                        }">${album.score}/10</span>` : 
                                        '<span class="score-badge score-unrated">Not Rated</span>'
                                    }
                                    ${album.dateListened ? `<p style="font-size: 0.8em; margin-top: 5px;">Listened: ${new Date(album.dateListened).toLocaleDateString()}</p>` : ''}
                                </div>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            document.getElementById('albumModal').classList.add('active');
        }

        // Sync Menu Toggle
        function toggleSyncMenu() {
            const menu = document.getElementById('syncMenu');
            menu.classList.toggle('active');
        }

        // Close sync menu when clicking outside
        document.addEventListener('click', function(e) {
            const syncStatus = document.getElementById('syncStatus');
            const syncMenu = document.getElementById('syncMenu');
            
            if (syncStatus && syncMenu && 
                !syncStatus.contains(e.target) && 
                !syncMenu.contains(e.target)) {
                syncMenu.classList.remove('active');
            }
        });

        // Auto-sync to OneDrive after data changes
        function autoSyncToOneDrive() {
            if (syncManager && syncManager.isConnected()) {
                // Debounce sync to avoid too many requests
                clearTimeout(window.autoSyncTimeout);
                window.autoSyncTimeout = setTimeout(() => {
                    syncManager.syncToOneDrive().catch(err => {
                        console.error('Auto-sync failed:', err);
                    });
                }, 2000); // Wait 2 seconds after last change
            }
        }

        // Alert System
        function showAlert(type, message) {
            const alertClass = type === 'success' ? 'alert-success' : 
                             type === 'error' ? 'alert-error' : 'alert-info';
            
            const alert = document.createElement('div');
            alert.className = `alert ${alertClass}`;
            alert.textContent = message;
            alert.style.position = 'fixed';
            alert.style.top = '20px';
            alert.style.right = '20px';
            alert.style.zIndex = '10000';
            alert.style.minWidth = '300px';
            alert.style.animation = 'slideIn 0.3s';

            document.body.appendChild(alert);

            setTimeout(() => {
                alert.style.animation = 'slideOut 0.3s';
                setTimeout(() => alert.remove(), 300);
            }, 3000);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Load initial section
            loadBrowseSection();
            
            // Close modal on outside click
            document.getElementById('albumModal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeModal();
                }
            });
        });
    </script>

    <style>
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }
    </style>
</body>
</html>